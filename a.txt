The file a.txt contains:

The file Akuna_Binary_wal.py contains:
import codecs
import re
from datetime import datetime
'''
class WAL(object):
    def __init__(self,binary_wal):
        self.binary_wal = binary_wal.hex()
        self.res = []


    def get_events(self):
        a = []
        a.append(str(int(self.binary_wal[:16], 16)))
        if int(self.binary_wal[16:18], 16) == 0:
            a.append("INSERT")
        elif int(self.binary_wal[16:18], 16) == 1:
            a.append("UPSERT")
        if int(self.binary_wal[16:18], 16) == 2:
            a.append("DELETE")
        key_length = int(self.binary_wal[18:22], 16)
        key_length = (key_length * 2)
        key_value = codecs.decode(self.binary_wal[22:22 + key_length], "hex")
        key_value = str(key_value)
        key_value = key_value.replace("b'", '')
        key_value = key_value.replace("'", "")
        a.append(key_value)
        if int(self.binary_wal[16:18],16)!=2:
            value_length = int(self.binary_wal[22 + key_length:22+ key_length+4],16)
            value_length = 22 + key_length + 4
            value_value = str(codecs.decode(self.binary_wal[value_length:], "hex"))
            value_value = value_value.replace("b'", '')
            value_value = value_value.replace("'", "")
            a.append(value_value)

        x = '|'.join(a)
        self.res.append(x)
        return sorted(self.res,key=lambda a :a[0])
'''

def bytes_to_int(bytes):
    result = 0
    for b in bytes:
        result = result * 256 + int(b)
    return result

def wal(a):
    n = 0
    while n < len(a):
        if len(a)==0:
            print("..........")
        epoch = bytes_to_int(a[:8])
        #print(a[:8])
        res.append(str(epoch))
        #########################################
        msg_id = bytes_to_int(a[8:9])
        if msg_id == 0:
            res.append("INSERT")
        elif msg_id == 1:
            res.append("UPSERT")
        elif msg_id == 2:
            res.append("DELETE")
        # res.append(str(msg_id))
        #########################################
        key_length = bytes_to_int(a[9:11])
        # res.append(key_length)
        key_value = a[11:11 + key_length].decode('utf-8')
        buf = 11 + key_length
        res.append(key_value)
        #########################################
        if msg_id != 2:
            value_length = bytes_to_int(a[buf:buf+2])
            if value_length<=0:
                return res
            # res.append(value_length)
            buf2 = buf + 2
            value_string = a[buf2:buf2+value_length].decode('utf-8')
            res.append(value_string)
        #########################################
        #print(res)
        else:
            buf2 = buf
            value_length = 0
        x = '|'.join(res)
        print(x)
        n +=len(a[:buf2+value_length])
        #print(n)
        if n!=len(a):
            a =a[n:]

if __name__ == '__main__':

    #print(WAL(b'\x00\x00\x01l\x05-\xcfA\x00\x00\x0etest_key_09812\x00\x10test_value_12876').get_events())
    #temp = '0000016c052dcf4100000e746573745f6b65795f30393831320010746573745f76616c75655f3132383736'
    temp1 = '0000016c052dcf4101000d746573745f6b65795f313233340012746573745f76616c75655f31323339393038'
    temp2 = '0000016c052dcf4102000f746573745f6b65795f313233383937'
    #print(bytes.fromhex('0000016c052dcf42'))
    temp = bytes.fromhex('0000016c052dcf4100000e')
    x = '0000016c052dcf4100000e746573745f6b65795f30393831320010746573745f76616c75655f31323837360000016c052dcf4101000d746573745f6b65795f313233340012746573745f76616c75655f31323339393038'
    all = bytes.fromhex(x)
    upsert = bytes.fromhex(temp1)
    delete = bytes.fromhex(temp2)
    #insert = b'\x00\x00\x01l\x05-\xcfB\x00\x00\x0etest_key_09812\x00\x10test_value_12876'
    insert = b''
    new = [all]
    res = []
    #st = '\x00\x00\x01l\x05-\xcfA\x00\x00\x0etest_key_09812\x00\x10test_value 12876'
    for i in range(len(new)):
        wal(new[i])




The file Akuna_Medha_Python.py contains:
def process(num):
    if len(num) != 8:
        return "INVALID"
    try:
        s = int(num[2:],16)
    except:
        return  "INVALID"
    sum =0
    while s!=0:
        sum+=int(s%10)
        s = s//10
    if hex(sum)[2:] == num[:2].lower():
        return "INVALID"
    else:
        "INVALID"

def process_2(line):
    if len(line) != 8:
        return "INVALID"
    try:
        a = int(line, 16)
    except:
        return "INVALID"
    try:
        s = int(line[2:], 16)
        x = int(line[:2], 16)
    except:
        return "INVALID A"
    sum = 0
    while(s > 0):
        sum = sum + s%10
        s = s//10
    if x == sum:
        return "VALID"
    return "INVALID"


print(process())
The file Akuna_Python_dev.py contains:
class PathCalculator:
    distance = {}  # dictionary that maintains distance between cities
    def process(self, line: str) -> str:
        if line == None:
            return "NONE"
        possible_route = {}
        city1, city2, dis = list(line.split(':'))
        if not city1 in self.distance:
            self.distance[city1] = {}
        self.distance[city1][city2] = int(dis)
        if not city2 in self.distance:
            self.distance[city2] = {}
        self.distance[city2][city1] = int(dis)
        for start_city in self.distance:
            d = self.distance[start_city]
            # print(d.keys())
            for inter_city in d:
                d1 = self.distance[inter_city]
                final_city = max(d1.keys(), key=(lambda k: d1[k]))
                if start_city != final_city and (inter_city in self.distance[start_city]):
                    total_dis = self.distance[start_city][inter_city] + self.distance[inter_city][final_city]
                    if start_city > final_city:
                        start_city, final_city = final_city, start_city
                    if total_dis in possible_route:
                        start_city_old = possible_route[total_dis][0]
                        if start_city_old > start_city:
                            possible_route[total_dis] = (start_city, inter_city, final_city)
                    else:
                        possible_route[total_dis] = (start_city, inter_city, final_city)

        if possible_route == {}:
            return "NONE"
        else:
            max_dis = max(possible_route)
            c1, c2, c3 = possible_route[max_dis]
            return ':'.join([str(max_dis), c1, c2, c3])

ob=PathCalculator()
l1='SEA:NYC:200'
l2='CHI:AUS:200'
l3='NYC:AUS:1000'
l4='NYC:HAWAII:4393'
l5='CHI:AUS:719'
l6='AUS:LA:2414'
print(ob.process(l1))
# print(ob.process(l2))
# print(ob.process(l3))
# # print(ob.process(l4))
# # print(ob.process(l5))
# # print(ob.process(l6))

ob=PathCalculator()
l1='CHI:NYC:200'
l2='SEATTLE:LA:200'
l3='NYC:SEATTLE:1000'
ob.process(l1)
ob.process(l2)
ob.process(l3)
The file Akuna_Sumedh_publicOfeereing.py contains:
import operator as op
def getUnallottedUsers(bids, totalShares):
    price_dict = dict()
    output =[]
    for i in bids:
        if i[2] not in price_dict:
            price_dict[i[2]] = [[i[0],i[1],i[3]]]
        else:
            price_dict[i[2]].append([i[0],i[1],i[3]])
    for i in price_dict:
        price_dict[i] = sorted(price_dict[i],key= op.itemgetter(2))
    while totalShares > 0:
        max_price = max(price_dict.keys())
        if len(price_dict[max_price]) == 1:
            totalShares -= price_dict[max_price][1]
            price_dict.pop(max_price)
        else:
            if (totalShares // len(price_dict[max_price])) > 0:
                x = totalShares // len(price_dict[max_price])
                for i in price_dict[max_price]:
                    i[1] -= x
                    totalShares -= x
                y = totalShares % len(price_dict[max_price])
                i = 0
                while y > 0 and i<len(price_dict[max_price]):
                    if price_dict[max_price][i][1] == 0:
                        i+=1
                        continue
                    price_dict[max_price][i][1] -= 1
                    totalShares -= 1
                    i+=1
                    y-=1
            else:
                y = totalShares % len(price_dict[max_price])
                i = 0
                while y > 0 and i < len(price_dict[max_price]):

                    price_dict[max_price][i][1] -= 1
                    totalShares -= 1
                    i += 1
                    y -= 1
                for j in range(i,len(price_dict[max_price])-1):
                    output.append(price_dict[max_price][i][0])

            price_dict.pop(max_price)

    for key,value in price_dict:
        for i in range(0,len(value)-1):
            output.append(value[i][0])



    return output



 print(getUnallottedUsers([
     [1,5,5,0],
     [2,7,8,1],
     [3,7,5,1],
     [4,10,3,3]
 ], 18))

The file Akuna_watermark.py contains:
from datetime import datetime
class HashTable:
    def __init__(self, rawEvents):
        self.hwm = None
        self.hashtable = {}
        for i in rawEvents:
            query = i.split('|')
            self.operate_HT(query)

    def operate_HT(self,query):
        if query[1] == 'INSERT':
            self.insert(query[2],query[3])
        elif query[1] == 'UPSERT':
            self.upsert(query[2], query[3])
        elif query[1] == 'DELETE':
            self.delete(query[2])
        x = int(query[0])/1000
        self.hwm = datetime.utcfromtimestamp(x)

    def insert(self,key,value):
        if key not in self.hashtable:
            self.hashtable[key] = value
    def upsert(self,key, value):
        self.hashtable[key] = value

    def delete(self,key):
        if key in self.hashtable:
            self.hashtable.pop(key)
    def table(self):
        print(self.hashtable)
        return self.hashtable

    def high_watermark(self):
        return self.hwm

h = HashTable(['1563454984001|INSERT|test|123','1563454984002|UPSERT|test|123','1563454984003|DELETE|test'])

s = h.table
The file allFactorsConsidered.py contains:
def print_factors(x):
    factors = []
    #print("The factors of",x,"are:")
    for i in range(1, x):
        if x % i == 0:
            factors.append(i)
            #print(i)
    return factors

temp = [3,6,7,21,100]
q = []
for i in range(len(temp)):
    f  = print_factors(temp[i])
    if len(f)==3:
        res = 1
        for i in range(len(f)):
            res = res * f[i]
        q.append(res)


print("Final Output",sum(q))




The file allLevelOfFriends.py contains:
import copy
def allLevelFriends(dict,name):
    res = []
    initial= namesofConnections(dict,name)
    #res = res.append(copy.deepcopy(initial))
    #res = copy.deepcopy(initial)
    res.append(initial[:])
    s= set()
    #print(initial)
    flag = True
    print("Start of while")
    while flag:
        print("--")
        if len(initial)==0:
            break
        #print(initial)
        temp = namesofConnections(dict,initial[0])
        #print("Set: -",s)
        if initial[0] not in s:
            s.add(initial[0])
            if temp==None:
                break
            if name in temp:
                temp.remove(name)
            if len(temp)!=0:
                res.append(temp[:])
                #print("Res after insertion", res)
                initial.extend(temp)
            #print(temp)
            initial.remove(initial[0])
            #print("Intial after removing",initial)
        else:
            initial.remove(initial[0])
            if temp[0] in s:
                temp.remove(temp[0])


    print(res)

def namesofConnections(dict,name):
    if name not in dict:
        return None
    else:
        return dict[name]



if __name__ == '__main__':
    dict={"Bob":["Alice","Sandra","Eric"],
          "Sandra":["Bob","Don"],
          "Alice":["Bob"],
          "Eric":["Bob"],
          "Don":["Sandra","Tim"],
          "Tim":["Don"]
          }
    allLevelFriends(dict,"Bob")
The file all_akuna.py contains:
#------------Heta Akuna-------------------

#----------------Changed Sort----------------

def returnlarge(s,a):
    s = sorted(s)
    i=0
    try:
        while a >= s[i]:
            i+=1
    except:
        return None
    return s[i]
def returnsmall(s,a):
    s = sorted(s,reverse= True)
    i=0
    try:
        while a <= s[i]:
            i+=1
    except:
        return None
    return s[i]
def changedSort(s):
    s = list(s)
    res = []
    res.append(s.pop(s.index(min(s))))
    i = 0
    #print(s,res)
    while i < len(s):
        # print(i,len(s))
        x = returnlarge(s,res[-1])
        if x:
            res.append(s.pop(s.index(x)))
            i+=1
        else:
            break
    x = returnlarge(s, res[-1])
    if x:
        res.append(s.pop(s.index(x)))
    i=0
    while i < len(s):
        x = returnsmall(s[i:],res[-1])
        if x:
            res.append(s.pop(s.index(x)))
            i+=1
        else:
            break
    x = returnsmall(s, res[-1])
    if x:
        res.append(s.pop(s.index(x)))
    if s:
        res += s
    return ''.join(res)

# print(changedSort('aaazzz'))

#-------------Roman Names-----------------

import operator as op


def romanToInt(s):
    num = 0
    my_funcs = {
        'I': (lambda num: -1 if num >= 5 else 1),
        'V': (lambda num: 5),
        'X': (lambda num: -10 if num >= 50 else 10),
        'L': (lambda num: 50),
        'C': (lambda num: -100 if num >= 500 else 100),
        'D': (lambda num: 500),
        'M': (lambda num: 1000)
    }
    for el in reversed(list(s)):
        # print(el)
        num += my_funcs[el](num)

    return num
def sortRoman(names):
    res = []
    for i in names:
        res.append(i.split(' '))
    for i in range(len(res)):
        x = romanToInt(res[i][1])
        res[i].append(x)
    res = sorted(res, key= op.itemgetter(0,2))
    for i in range(len(res)):
        res[i].pop(-1)
        res[i] = ' '.join(res[i])
    return res



#print(sortRoman(['Philippe I','Philip II','Bill L','Bill IX','Bill V','Bill X']))


#----------------------Minimum Operations------------------------

def searchInsert(nums, target):
    i = 0
    if nums == []:
        return i
    if nums[-1] < target:
        return len(nums)
    while (nums[i] < target):
        i += 1
    return i

def minimumOperations(a):
    res = []
    i = 0
    count = 0
    while i < len(a):
        j = searchInsert(res,a[i])
        count += min(j-0, len(res) - j)*2 + 1
        # print(min(j-0, len(res) - j)*2 + 1)
        res.insert(j,a[i])
        i+=1
    print(res,count)
a = [2,5,6,10]
# minimumOperations(a)

class Queue1:
    def _init_(self):
        self.s1 = []
        self.s2 = []
    def put(self,n):
        while self.s1:
            self.s2.append(self.s1.pop())

        self.s1.append(n)

        while self.s2:
            self.s1.append(self.s2.pop())
    def get(self):
        if self.s1:
            return self.s1.pop()
        return None

import queue as q
class Fifo:
    def _init_(self,size):
        self.fifo = q.Queue(size)
        self.cache = dict()

    def put(self,key, value):
        if self.fifo.full():
            self.cache.pop(self.fifo.get())

        self.fifo.put(key)
        self.cache[key] = value

    def get(self, key):
        try:
            return self.cache[key]
        except:
            return None

# fifo = Fifo(3)
# fifo.put(1,5)
# fifo.put(2,6)
# fifo.put(3,7)
# print(fifo.get(2))
# fifo.put(4,7)
# fifo.put(5,1)
# print(fifo.get(4))
# print(fifo.get(2))
# print(list(fifo.fifo.queue))
# print(fifo.cache)
# x = ['10','1','2','11']
# import heapq as hq
# print(hq.nsmallest(2,x))

# def listMax(n,operations):
#     x = [0]*n
#     for i in operations:
#         for j in range(i[0]-1,i[1]):
#             x[j] += i[2]
#     print(max(x))


def create(n):
    size = 1
    while n >= size:
        size *= 2
    return [0] * size


def range_add(fwam, fwaa, low, high, val):
    _update(fwam, fwaa, low, val, -val * (low - 1))
    _update(fwam, fwaa, high, -val, val * high)


def _update(fwam, fwaa, at, m, a):
    s = len(fwam)
    while at < s:
        fwam[at] += m
        fwaa[at] += a
        at += at & (-at)


def range_query(fwam, fwaa, at):
    m, a, st = 0, 0, at
    while at > 0:
        m += fwam[at]
        a += fwaa[at]
        at -= at & (-at)

    return m * st + a


def listMax(n, operations):
    fwam, fwaa = create(n), create(n)
    for a, b, k in operations:
        range_add(fwam, fwaa, a, b, k)

    best, prev = 0, 0
    for i in range(1, n + 1):
        curr = range_query(fwam, fwaa, i)
        best = max(best, curr - prev)
        prev = curr
    print(best)
    return best

# listMax(4,[
#         [2,3,603],
#         [1,1,286],
#         [4,4,882]
#         ])

# a = 'abpqrspqrs'
# minLen, maxLen = 2,4
# x = []
# for i in range(len(a)):
#     if i+maxLen > len(a):
#         break
#     j = i+minLen
#     while j < len(a) and j < i+maxLen+1:
#         x.append(a[i:j])
#         j+=1
#
# print(x)

#--------------Akuna 2-----------------
def wall():
    wallposition = [1,2,4,7]
    wallheight = [4,5,7,11]
    total_wallheight = [0]*max(wallposition)
    j=0
    for i in wallposition:
        total_wallheight[i-1] = wallheight[j]
        j+=1
    x = total_wallheight.copy()
    max_mud_length = -1
    for i in range(1,len(total_wallheight)-1):
        if total_wallheight[i] == 0:
            if total_wallheight[i+1] == 0:
                total_wallheight[i] = total_wallheight[i-1] + 1
                #max_mud_length = max(max_mud_length,total_wallheight[i])
            else:
                total_wallheight[i] = min(total_wallheight[i-1],total_wallheight[i+1])+1
                #max_mud_length = max(max_mud_length, total_wallheight[i])
    print(total_wallheight)
    total_wallheight1 = total_wallheight.copy()
    total_wallheight = x.copy()
    i = len(total_wallheight) - 1
    while i > 0:
        if total_wallheight[i] == 0:
            if total_wallheight[i-1] == 0:
                total_wallheight[i] = total_wallheight[i+1] + 1
                #max_mud_length = max(max_mud_length,total_wallheight[i])
            else:
                total_wallheight[i] = min(total_wallheight[i-1],total_wallheight[i+1])+1
                #max_mud_length = max(max_mud_length, total_wallheight[i])
        i-=1
    for i in range(len(total_wallheight)):
        total_wallheight[i] = min(total_wallheight[i],total_wallheight1[i])
        if x[i] == 0:
            max_mud_length = max(max_mud_length,total_wallheight[i])
    print(total_wallheight)
    print(x)
    print(max_mud_length)

import operator as op
def rearrange(elements):
    bin_array = []
    for i in elements:
        x = (i,bin(i).replace('0b','').count('1'))
        bin_array.append(x)
    bin_array.sort(key=op.itemgetter(1,0))
    a=[]
    for i in bin_array:
        a.append(i[0])
    return a
rearrange([5,3,7,10,14])

def getUnallottedUsers1(bids, totalShares):
    price_dict = dict()
    for i in bids:
        if i[2] not in price_dict:
            price_dict[i[2]] = [[i[0],i[1],i[3]]]
        else:
            price_dict[i[2]].append([i[0],i[1],i[3]])
    for i in price_dict:
        price_dict[i] = sorted(price_dict[i],key= op.itemgetter(2))
    while totalShares > 0:
        max_price = max(price_dict.keys())
        if len(price_dict[max_price]) == 1:
            totalShares -= price_dict[max_price][1]
            price_dict.pop(max_price)
        else:
            if (totalShares // len(price_dict[max_price])) > 0:
                x = totalShares // len(price_dict[max_price])
                for i in price_dict[max_price]:
                    i[1] -= x
                    totalShares -= x
                y = totalShares % len(price_dict[max_price])
                i = 0
                while y > 0 and i<len(price_dict[max_price]):
                    if price_dict[max_price][i][1] == 0:
                        i+=1
                        continue
                    price_dict[max_price][i][1] -= 1
                    totalShares -= 1
                    i+=1
                    y-=1
            else:
                y = totalShares % len(price_dict[max_price])
                i = 0
                while y > 0 and i < len(price_dict[max_price]):
                    if price_dict[max_price][i][1] == 0:
                        i += 1
                        continue
                    price_dict[max_price][i][1] -= 1
                    totalShares -= 1
                    i += 1
                    y -= 1
    return price_dict



# print(getUnallottedUsers([
#     [1,5,5,0],
#     [2,7,8,1],
#     [3,7,5,1],
#     [4,10,3,3]
# ], 18))

import math


def findCombination(n, min, max):
    result = 0
    m = {}

    for i in range(min, max):
        for j in range(min, max):
            if math.gcd(i, j) == 1:
                if m.get(i):
                    m[i] += 1
                else:
                    m[i] = 1

    for i in m:
        result += i ** (n - 1)

    return result

#print(findCombination(2,1,3))

def getUnallottedUsers(bids, totalShares):
    price_dict = dict()
    output = []
    for i in bids:
        if i[2] not in price_dict:
            price_dict[i[2]] = [[i[0], i[1], i[3]]]
        else:
            price_dict[i[2]].append([i[0], i[1], i[3]])
    for i in price_dict:
        price_dict[i] = sorted(price_dict[i], key=op.itemgetter(2))
    while totalShares > 0:
        max_price = max(price_dict.keys())
        if len(price_dict[max_price]) == 1:
            print(price_dict)
            print(price_dict[max_price])
            totalShares -= price_dict[max_price][0][1]
            price_dict.pop(max_price)
        else:
            if (totalShares // len(price_dict[max_price])) > 0:
                x = totalShares // len(price_dict[max_price])
                for i in price_dict[max_price]:
                    i[1] -= x
                    totalShares -= x
                y = totalShares % len(price_dict[max_price])
                i = 0
                while y > 0 and i < len(price_dict[max_price]):
                    if price_dict[max_price][i][1] == 0:
                        i += 1
                        continue
                    price_dict[max_price][i][1] -= 1
                    totalShares -= 1
                    i += 1
                    y -= 1
            else:
                y = totalShares % len(price_dict[max_price])
                i = 0
                while y > 0 and i < len(price_dict[max_price]):
                    price_dict[max_price][i][1] -= 1
                    totalShares -= 1
                    i += 1
                    y -= 1
                for j in range(i, len(price_dict[max_price]) - 1):
                    output.append(price_dict[max_price][i][0])

            price_dict.pop(max_price)

    for key in price_dict:
        for i in range(0, len(price_dict[key])):
            output.append(price_dict[key][i][0])

    return output


# print(getUnallottedUsers([
#     [1, 5, 5, 0],
#     [2, 7, 8, 1],
#     [3, 7, 5, 1],
#     [4, 10, 3, 3]
# ], 18))

from datetime import datetime
class HashTable:
    def _init_(self, rawEvents):
        self.hwm = datetime.utcfromtimestamp(0)
        self.hashtable = dict()
        for i in rawEvents:
            query = i.split('|')
            self.operate_HT(query)

    def operate_HT(self,query):
        if query[1] == 'INSERT':
            self.insert(query[2],query[3])
        elif query[1] == 'UPSERT':
            self.upsert(query[2], query[3])
        elif query[1] == 'DELETE':
            self.delete(query[2])
        x = int(query[0])/1000
        self.hwm = datetime.utcfromtimestamp(x)

    def insert(self,key,value):
        if key not in self.hashtable:
            self.hashtable[key] = value
    def upsert(self,key, value):
        self.hashtable[key] = value

    def delete(self,key):
        if key in self.hashtable:
            self.hashtable.pop(key)
    def table(self):
        return self.hashtable

    def high_watermark(self):
        return self.hwm

# h = HashTable([
#     '1563454984001|INSERT|test|123',
#     '1563454984002|UPSERT|test|123',
#     '1563454984003|DELETE|test'])
# print(h.table())
# print(h.high_watermark())
import codecs
def Akuna_12(s):
    a = []
    a.append(str(int(s[:16],16)))
    if int(s[16:18],16) == 0:
        a.append("INSERT")
    elif int(s[16:18],16) == 1:
        a.append("UPSERT")
    if int(s[16:18],16) == 2:
        a.append("DELETE")
    key_length = int(s[18:22],16)
    key_length = (key_length*2)
    key_value = codecs.decode(s[22:22+key_length],"hex")
    key_value = str(key_value)
    key_value = key_value.replace("b'",'')
    key_value = key_value.replace("'","")
    a.append(key_value)
    # value_length = int(s[22 + key_length:22+ key_length+4],16)
    value_length = 22+ key_length+4
    value_value = str(codecs.decode(s[value_length:],"hex"))
    value_value = value_value.replace("b'",'')
    value_value = value_value.replace("'","")
    a.append(value_value)
    return a
s = '0000016c052dcf4101000d746573745f6b65795f313233340012746573745f76616c75655f31323339393038'

def bytes_to_int(bytes):
    result = 0
    for b in bytes:
        result = result * 256 + int(b)
    return result
def someFunc():
    a = b'\x00\x00\x01l\x05-\xcfA\x00\x00\x0etest_key_09812\x00\x10test_value 12876'
    res = []
    #st = '\x00\x00\x01l\x05-\xcfA\x00\x00\x0etest_key_09812\x00\x10test_value 12876'
    epoch = bytes_to_int(a[:8])
    res.append(str(epoch))
    msg_id = bytes_to_int(a[8:9])
    msg_id = bytes_to_int(a[8:9])
    if msg_id == 0:
        res.append("INSERT")
    elif msg_id == 1:
        res.append("UPSERT")
    if msg_id == 2:
        res.append("DELETE")
    key_length = bytes_to_int(a[9:11])
    #res.append(key_length)
    key_value = a[11:11+key_length].decode('utf-8')
    res.append(key_value)
    value_length = bytes_to_int(a[25:27])
    #res.append(value_length)
    value_string = a[27:43].decode('utf-8')
    res.append(value_string)
    print(res)
    x= '|'.join(res)
    print(x)

#-----------------------Medha Akuna--------------------------

class PathCalculator:
    distance = {}  # dictionary that maintains distance between cities

    def process(self, line: str) -> str:

        possible_route = {}  # dictianery that maintains distance if there is possibility of two ticket route

        city1, city2, dis = list(line.split(':'))
        if not city1 in self.distance:  # Updating distance with respect to city1
            self.distance[city1] = {}
        self.distance[city1][city2] = int(dis)

        if not city2 in self.distance:  # Upadting distance with respect to city2
            self.distance[city2] = {}
        self.distance[city2][city1] = int(dis)

        for start_city in self.distance:  # Checking two ticket distance for each city
            d = self.distance[start_city]
            inter_city = max(d.keys(), key=(lambda k: d[k]))
            d = self.distance[inter_city]
            final_city = max(d.keys(), key=(lambda k: d[k]))
            if start_city != final_city:
                total_dis = self.distance[start_city][inter_city] + self.distance[inter_city][final_city]
                if start_city > final_city:
                    start_city, final_city = final_city, start_city
                if possible_route.get(total_dis):
                    if possible_route[total_dis] > (start_city, inter_city, final_city):
                        possible_route[total_dis] = (start_city, inter_city, final_city)
                else:
                    possible_route[total_dis] = (start_city, inter_city, final_city)
        print(self.distance)
        print(possible_route)
        if possible_route == {}:
            return "NONE"
        else:
            max_dis = max(possible_route)
            c1, c2, c3 = possible_route[max_dis]
            return ':'.join([str(max_dis),c1,c2,c3])
# ob=PathCalculator()
# l1='AAA:NYC:200'
# l2='CHI:AUS:200'
# l3='NYC:AUS:1000'
# l4='NYC:HAWAII:4393'
# l5='CHI:AUS:719'
# l6='AUS:LA:2414'
# print(ob.process(l1))
# print(ob.process(l2))
# print(ob.process(l3))
# print(ob.process(l4))
# print(ob.process(l5))
# print(ob.process(l6))

# ob=PathCalculator()
# l1='CHI:NYC:719'
# l2='NYC:LA:2414'
# l3='NYC:SEATTLE:2448'
# l4='NYC:HAWAII:4924'
# ob.process(l1)
# ob.process(l2)
# ob.process(l3)
# ob.process(l4)

# def prefixString(a,b):
#     pString = [a[0]]
#     for i in range(1,len(a)):
The file all_akuna_2.py contains:

def getEventsOrder(team1, team2, events1, events2):
    # Write your code here
    football = list()
    football.append({"team": team1, "event": events1})
    football.append({"team": team2, "event": events2})

    game_details_list = list()
    original_event = list()
    event_priority = ['G', 'Y', 'R', 'S']

    for f in football:
        for event in f["event"]:
            original_event.append(f["team"] + " " + event)

            # split events string to get details
            pattern = re.compile("([a-zA-Z\s])(\d+)[+]?(\d).([G,Y,R,S])([a-zA-Z\s]*)")
            split_event = pattern.search(event)

            # create a list of format ["team name", "player name", "time", "extra time", "event", "second player name"]
            record = list()
            record.append(f["team"])  # team name
            if split_event:
                record.append(split_event.group(1).strip())  # player name
                record.append(int(split_event.group(2).strip()))  # time
                record.append(
                    int(split_event.group(3).strip()) if len(split_event.group(3).strip()) > 0 else 0)  # extra time
                record.append(event_priority.index(split_event.group(4).strip()))  # event
                record.append(split_event.group(5).strip())  # second player
            game_details_list.append(record)

    # sorting the list to return index position of the sorted list
    new_num_index_sorted = (sorted(range(len(game_details_list)),
                                   key=lambda k: (
                                       game_details_list[k][2],  # time
                                       game_details_list[k][3],  # extra time
                                       game_details_list[k][4],  # event
                                       game_details_list[k][0],  # team name
                                       game_details_list[k][1],  # player name
                                       game_details_list[k][5])))

    # based on the index position, fetching result from original event list and appending in answer
    answer = list()
    for i in new_num_index_sorted:
        answer.append(original_event[i])
    return answer
# team1 = 'ABC'
# team2 = 'CBA'
# events1 = ['Mo Sa 45+2 Y','A 13 G']
# events2 = ['D 23 S F', 'Z 46 G']
# print(getEventsOrder(team1,team2,events1,events2))
# print(getEventsOrder("nolh","nzrdrrc",["inmuucz jzbkica 70 Y","ton wfnt 10 S inmuucz jzbkica","ecya kqvqy 20 S fkfk fuiyb senmofw"],["mysior pqfcz bxlnpn 49 G","mysior pqfcz bxlnpn 18 G","enc otagavd oevfg 86 Y"]))
# def minNum(A,n):
#     previous_letter_status, no_of_unread_letters, no_of_unread_segments = 0, 0, 0
#     for i in range(0,n):
#         if A[i] == 1:
#             no_of_unread_letters += 1
#         if previous_letter_status == 0 and A[i] == 1:
#             no_of_unread_segments += 1
#
#         previous_letter_status = A[i]
#
#     no_of_operations = no_of_unread_letters + max(no_of_unread_segments-1,0)
#     print(no_of_operations)
# minNum([0,0],2)

# int findCombination(int n, int min, int max)
# {
# 	long result = 0;
# 	unordered_map<int, int> m;
# 	for (int i = min; i <= max; i++)
# 	{
# 		for (int j = min; j <= max; j++)
# 		{
# 			if (std::gcd(i, j) == 1)
# 				m[i]++;
# 		}
# 	}
# 	auto iter = m.begin();
# 	while (iter != m.end())
# 	{
# 		result += pow(iter->second, n - 1);
# 		iter++;
# 	}
# 	return result;
# }
# import math
# def findCombination(rotorCount,minRotorValue,maxRotorValue):
#     result = 0
#     map = dict()
#     for i in range(minRotorValue,maxRotorValue+1):
#         if i % 2 == 0:
#             flag = True
#         else:
#             flag = False
#         for j in range(minRotorValue,maxRotorValue+1):
#             if j % 2 == 0 and flag:
#                 continue
#             if math.gcd(i,j) == 1:
#                 if i in map:
#                     map[i] += 1
#                 else:
#                     map[i] = 1
#     print(map)
#     for i in map:
#         result += map[i] ** (rotorCount-1)
#     return result

# print(findCombination(3,2,6))
import networkx
from networkx import (
    draw,
    DiGraph,
    Graph,
)
# def minOperations(n,fro,to):
#     undirected = Graph()
#     undirected.add_edges_from(list(zip(fro, to)))
#     for i in range(1,n+1):
#         if i not in undirected.nodes():
#             undirected.add_node(i)
#     # print(undirected.nodes())
#     # draw(undirected, with_labels=True)
#     nCC = networkx.number_connected_components(undirected)
#     s = networkx.connected_components(undirected)
#     s = (list(s))
#     H = 0
#     for i in range(len(s)):
#         h = undirected.subgraph(list(s[i]))
#         H += (len(h.edges()) - len(s[i]) + 1)
#     if H >= nCC - 1:
#         print(nCC-1)
#     else:
#         print(-1)
# n = 4
# fro = [1,3]
# to = [2,4]

# # minOperations(n,fro,to)
# import operator as op
# def reduce_values(d):
#     for i in d:
#         d[i] -= 10
#     return d
# def minimum(s):
#     res = 0.0
#     gumDict = dict()
#     for i in s:
#         if i in gumDict:
#             gumDict[i] = 1000
#         else:
#             if len(gumDict) > 2:
#                 s = min(gumDict.items(), key=op.itemgetter(1))
#                 gumDict.pop(s[0])
#                 res += s[1]/100
#             gumDict[i] = 1000
#         gumDict = reduce_values(gumDict)
#     return float(round(res,1))
#
# minimum(['red','red'])








class PathCalculator:
    # You may enter code here.

    distance = {}  # dictionary that maintains distance between cities

    def process(self, line: str) -> str:
        if line == None:
            return "NONE"
        possible_route = {}
        flag1, flag2 = False, False
        city1, city2, dis = list(line.split(':'))
        if city1 not in self.distance:
            self.distance[city1] = {}
            flag1 = True
        self.distance[city1][city2] = int(dis)

        if city2 not in self.distance:
            self.distance[city2] = {}
            flag2 = True
        self.distance[city2][city1] = int(dis)
        if flag1 and flag2:
            return "NONE"
        for start_city in self.distance:
            d = self.distance[start_city]
            # print(d.keys())
            for inter_city in d:
                d1 = self.distance[inter_city]

                final_city = max(d1.keys(), key=(lambda k: d1[k]))
                if start_city != final_city and (inter_city in self.distance[start_city]):

                    total_dis = self.distance[start_city][inter_city] + self.distance[inter_city][final_city]
                    if start_city > final_city:
                        start_city, final_city = final_city, start_city
                    if total_dis in possible_route:
                        start_city_old = possible_route[total_dis][0]
                        if start_city_old > start_city:
                            possible_route[total_dis] = (start_city, inter_city, final_city)
                    else:
                        possible_route[total_dis] = (start_city, inter_city, final_city)
        print(self.distance)
        if possible_route == {}:
            return "NONE"
        else:
            max_dis = max(possible_route)
            c1, c2, c3 = possible_route[max_dis]
            return ':'.join([str(max_dis), c1, c2, c3])

# ob=PathCalculator()
# l1='AUS:CHI:200'
# l2='AUS:SEATTLE:100'
# l3='NYC:CLT:100'
# l4='NYC:AUS:4393'
# l5='CHI:AUS:719'
# l6='AUS:LA:2414'
# print(ob.process(l1))
# print(ob.process(l2))
# print(ob.process(l3))
#print(ob.process(l4))
# class PathCalculator:
#     city = dict()
#     def process(self,path):
#         path = path.split(':')
#         if path[0] in self.city:
#             self.city[path[0]][path[1]] = path[2]
#         else:
#             self.city[path[0]] = {path[1]:path[2]}
#
#         if path[1] in self.city:
#             self.city[path[1]][path[0]] = path[2]
#         else:
#             self.city[path[1]] = {path[0]:path[2]}
#
#         if path[0]
#

# ob=PathCalculator()
# l1='AUS:CHI:200'
# l2='AUS:SEATTLE:100'
# l3='NYC:CLT:100'
# l4='NYC:AUS:4393'
# ob.process(l1)
# ob.process(l2)
# # ob.process(l3)
# # ob.process(l4)
# print(ob.city)




# public static int balancedSum(List<Integer> sales) {
#     // Write your code here
# 		int sum =0;
#         for(int i=0;i<list.size();i++){
#             sum += list.get(i);
#         }
#         int curr =list.get(0);
#         for(int i=1;i<list.size();i++){
#             if(curr == sum - curr - list.get(i)){
#                 return i;
#             }
#             curr += list.get(i);
#         }
#         return -1;
#     }
# def balancedSum(s):
#     sum = 0
#     for i in s:
#         sum += i
#     x = s[0]
#     for i in range(1,len(s)):
#         if x == (sum - x - s[i]):
#             return i
#         x += s[i]
#     return -1
# print(balancedSum([1,2,3,4,6]))
from collections import Counter as c
# Print subarray between
# current starting
# and ending points

# a = [25,35,872,228,53,278,872]
# for i in range(len(a)):
#     a[i] = "".join(sorted(str(a[i])))
# pair ={}
# count=0
# for i in range(len(a)):
#     if a[i] in pair:
#         pair[a[i]] +=1
#     else:
#         pair[a[i]] =1
# for keys in pair.keys():
#     count+= pair[keys]*(pair[keys]-1) //2
# print(count)


# import collections
# def anagram(a,b):
#     count = 0
#     if len(a) != len(b):
#         return -1
#
#     dic = collections.Counter(a)
#
#     for i in b:
#         if i in dic:
#             if dic[i]:
#                 dic[i] -= 1
#             else:
#                 count += 1
#         else:
#             count += 1
#     return count

# def getMinimumDifference(a,b):
#     res = []
#     for i,j in zip(a,b):
#         res.append(anagram(i,j))
#     return res

# def traverse(a,s,i,j):
#     if a[i][j] != s:
#         return False
#     if i < len(a)-1 and j < len(a[i])-1 and i>-1 and j>-1:
#         traverse(a,s,i+1,j)
#         traverse(a,s,i,j+1)
#         traverse(a,s,i-1,j)
#         traverse(a,s,i,j-1)
# def prime_count():
#     s = "CABa"
#     Hset = {67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113}
#     s = list(s)
#     asc = []
#     for i in s:
#         asc.append(ord(i))
#     print(asc)
#     for i in range(len(asc)):
#         j = 1
#         while True:
#             if asc[i] in Hset:
#                 asc[i] = chr(asc[i])
#                 break
#             if asc[i]-j in Hset:
#                 asc[i] = chr(asc[i]-j)
#                 break
#             elif asc[i]+j in Hset:
#                 asc[i] = chr(asc[i]+j)
#                 break
#             j+=1
#     print(asc)
#
#
# def solve(a, n, m):
#     # s = set()
#     # for i in range(len(a)):
#     #     for j in a[i]:
#     #         if j not in s:
#     #             s.add(j)
#     for i in range(n):
#         for j in range(m):
#             print(traverse(a,a[i][j],i,j))
#     # print(s)
#
#
# c = [
#     ['B','B','B','B','B','B','B'],
#     ['B','G','G','G','G','B','B'],
#     ['B','G','B','B','G','B','B'],
#     ['B','G','B','B','G','B','B'],
#     ['B','G','G','G','G','B','B'],
#     ['B','B','B','B','B','B','B']
# ]
# def color_loop(n,m,mat):
#     for i in range(0,n):
#         for j in range(0,m):
#             c = mat[i][j]
#             for k in range(j+1,m):
#                 if mat[i][k] != c:
#                     break
#             k-=1
#             if k>j:
#                 for l in range(i+1,n):
#                     if mat[l][k] != c:
#                         break
#                 l-=1
#                 if l>i:
#                     p=k
#                     while p >= j:
#                         if mat[l][p] != c:
#                             break
#                         p -= 1
#                     p+=1
#                     if p == j:
#                         q=l
#                         while q >= i:
#                             if mat[q][p] != c:
#                                 break
#                             q-=1
#                         q+=1
#                         if q==i:
#                             return True
#     return False
# print(color_loop(len(c),len(c[0]),c))

# s = "ab12c"
# t = "1zz456"
# def removeOneDigit(s,t):
#     sList = list(s)
#     tList = list(t)
#     count = 0
#     for i in range(len(tList)):
#         tl = tList.copy()
#         if tList[i].isdigit():
#             tl.pop(i)
#             if s < ''.join(tl):
#                 count+=1
#
#     for i in range(len(sList)):
#         sl = sList.copy()
#         if sList[i].isdigit():
#             sl.pop(i)
#             if ''.join(sl) < t:
#                 count+=1
#     return count

s = "123456 ab-cd+ef"
a = s.split(' ')[0]
b = s.split(' ')[1]
result = 0
sign = '+'
word_before_operator = ""
j=0

for i in range(len(b)):
    if b[i] == '+':
        if sign == '+':
            result += int(word_before_operator)
        elif sign == '-':
            result -= int(word_before_operator)
        sign = '+'
        word_before_operator = ""
    elif b[i] == '-':
        if sign == '+':
            result += int(word_before_operator)
        elif sign == '-':
            result -= int(word_before_operator)
        sign = '-'
        word_before_operator = ""
    else:
        word_before_operator += a[j]
        j+=1
if sign == '+':
    result += int(word_before_operator)
elif sign == '-':
    result -= int(word_before_operator)
print(result)
The file amazonMock.py contains:
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def mergeKLists(self, lists):
        def mergeTwo(l1,l2):
            dummyNode = head = ListNode(0)
            while l1 and l2:
                if l1.val>l2.val:
                    dummyNode.next = l2
                    l2 =l2.next
                else:
                    dummyNode.next = l1
                    l1 = l1.next
                dummyNode = dummyNode.next

            if l1:
                dummyNode.next = l1
            elif l2:
                dummyNode.next = l2
            return head.next
        if len(lists)==0:
            return 0
        while len(lists)>1:
            l1 = lists.pop(0)
            l2 = lists.pop(0)
            lists.append(mergeTwo(l1,l2))

        return lists[0]












        '''
        temp = []
        for i in range(len(lists)):
            l1 = lists[i]
            while l1:
                temp.append(l1.val)
                l1 = l1.next

        temp.sort()

        dummyNode = head = ListNode(0)

        for i in range(len(temp)):
            dummyNode.next = ListNode(temp[i])
            dummyNode = dummyNode.next

        return head.next
        '''




The file Anagram_Difference.py contains:

import collections
def anagram(a,b):
    count = 0
    if len(a) != len(b):
        return -1

    dic = collections.Counter(a)

    for i in b:
        if i in dic:
            if dic[i]:
                dic[i] -= 1
            else:
                count += 1
        else:
            count += 1
    return count
a = 'abc'
b = 'def'
x = ['a','jk','abb','mn','abc']
y = ['bb','kj','bbc','op','def']
print(anagram(a,b))
for i in range(len(x)):
    print(anagram(x[i],y[i]))
#print(anagram(x,y))
The file appendZeroAtEnd.py contains:
def appendZeroAtEnd(arr):
    #temp = [1,0,2,3,0,4,5]
    ptr  = 0
    for i in range(len(arr)):
        if arr[i]!=0:
            arr[ptr]=arr[i]
            ptr+=1
    for i in range(ptr,len(arr)):
        arr[i] = 0
    print(arr)


if __name__ == '__main__':
    arr = [1,0,2,3,0,4,5]
    arr1 = [0, 2, 3, 0, 4, 5]
    arr2 = []
    arr3 = [0, 0, 0, 0]
    appendZeroAtEnd(arr)
    appendZeroAtEnd(arr1)
    appendZeroAtEnd(arr2)
    appendZeroAtEnd(arr3)


The file Array_Journey.py contains:
def journey(arr, k):
    sum = 0
    length = len(arr)
    end = length
    i = 0
    max = 0
    flag = 0
    ind = -1
    while (i < length):
        if (arr[i] >= 0):
            sum += arr[i]
        else:
            temp = i + k
            max = -9999
            ind = -1
            for j in range(i, temp):
                if (j < length):
                    if (arr[j] >= 0):
                        i = j
                        sum += arr[j]
                        flag = 1
                        break;
                    else:
                        if (arr[j] > max):
                            max = arr[j]
                        ind = j
                else:
                    break
            if (flag == 0):
                sum += max
                i = ind
        i += 1
    return sum


def journey1(path, k):
    d = {}

    def helper(path, k, i):
        if i >= len(path):
            return 0
        allPresent = True
        t = [x for x in range(i + 1, i + k + 1)]
        for x in t:
            if x not in d:
                allPresent = False
        if allPresent:
            maxi = 0
            for x in t:
                if d[x] > maxi:
                    maxi = d[x]
            return maxi
        else:
            maxi = 0
            for x in t:
                temp = path[i] + helper(path, k, x)
                if temp > maxi:
                    maxi = temp
            d[i] = maxi
            return maxi

    return helper(path, k, 0)

#arr = [10,2,-10,5,20]
#arr = [10,-20,-5]
arr = [3,-4,-3,-5,0]
k = 2
print("The array is:",arr)
print("The value of the k is:",k)
print("Maximu score achievable is:",journey(arr,2))
The file Ascending_Binary_Sorting.py contains:
count_1 ={}
answer = []
a = [5,3,10,7,14]
for i in range(len(a)):
    m = bin(a[i])[2:].count('1')
    if m not in count_1:
        count_1[m] = []
    count_1[m].append(a[i])
for k in sorted(count_1.keys()):
    count_1[k].sort()
    for inp in count_1[k]:
        answer.append(inp)

print(answer)


The file balancedSalesArray.py contains:
def getBalancedIndex(sales):
    sumAsc = [0] * len(sales)
    sumDesc = [0] * len(sales)
    for i in range(len(sales)):
        if i ==0:
            sumAsc[i] = sales[i]
        else:
            sumAsc[i] = sumAsc[i-1]+ sales[i]

    for i in range(len(sales)-1, -1, -1):
        if i == len(sales) -1:
            sumDesc[i] = sales[i]
        else:
            sumDesc[i] = sumDesc[i+1] + sales[i]

    for i in range(len(sales)):
        if sumAsc[i] == sumDesc[i]:
            return i
    return -1

print(getBalancedIndex([1,2,3,3]))
print(getBalancedIndex([3,1,2,1]))


The file balanceParanthesis.py contains:
def validParanthesis(s):
    d  ={"(":")","[":"]","{":"}"}
    stack =[]

    for i in range(len(s)):
        if stack:
            if stack[-1] in d and d[stack[-1]]==s[i]:
                stack.pop(-1)
            else:
                stack.append(s[i])
        else:
            stack.append(s[i])

    if stack:
        return False
    return True


if __name__ == '__main__':
    print(validParanthesis("("))
The file balancingElements.py contains:
def balancingElements(arr):
    print("-----------------------------")
    print(arr)
    n = len(arr)
    odd = 0
    even =0
    leftOdd= [0]*len(arr)
    leftEven = [0] * len(arr)
    rightOdd = [0]*len(arr)
    rightEven = [0]*len(arr)
    for i in range(n):
        print(i,arr[i])
        leftOdd[i] = odd
        leftEven[i] = even
        if i%2==0:
            even+=arr[i]
        else:
            odd+=arr[i]
        #print("Left Odd", leftOdd, "Left Even", leftEven)
    odd = 0
    even= 0
    for i in range(n-1,-1,-1):
        rightOdd[i] = odd
        rightEven[i] = even

        if i%2==0:
            even+=arr[i]
        else:
            odd+=arr[i]

    count = 0
    print("Left Odd",leftOdd,"Left Even",leftEven)
    print("Right Even", rightEven, "Right Odd", rightOdd)
    for i in range(n):
        if leftOdd[i]+rightEven[i] == leftEven[i]+rightOdd[i]:
            #print("Remove index:- ",i)

            #print("Remove character:- ", arr[i])
            count+=1

    print(count)



if __name__ == '__main__':
    num1 = [5,5,2,5,8]
    num2 = [2,2,2]
    num3 = [2, 1,6,4]
    balancingElements(num1)
    balancingElements(num2)
    balancingElements(num3)


The file basics.py contains:
import copy
a = [1,2,3,4,5,6,7]
#print(id(a),a)
############# Pass by Reference ############
print("................Pass by Reference..............")
def updateList(list1):
    list2 = list1
    list2 += [10]
n = [5, 6]
print(id(n))                  # 140312184155336
updateList(n)
print(n)                      # [5, 6, 10]
print(id(n))                  # 140312184155336

############# Pass by Value ############
print("................Pass by Value..............")
def updateNumber(n):
    n += 10
b = 5
print(id(b))                   # 10055680
updateNumber(b)                # 10055680
print(b)

########### Tuple ##########
##### Tuples are IMUTABLE #####
##### The “value” of an immutable object can’t change, but it’s constituent objects can #####
print("................ Tuple ..............")
a = [1,2,3]
x = "Sumedh"
t = (x,a)
print(t)
a.append(4)
print(t)















####### References ########
#https://medium.com/@meghamohan/mutable-and-immutable-side-of-python-c2145cf72747
The file bestSquare_find_sum_of_all_squares_of_size_kxk.py contains:
from collections import defaultdict
def printSumSimple(mat, k):
    n = len(mat)
    m = len(mat[1])
    if (k > n):
        return
    dic = defaultdict(list)
    for i in range(n - k + 1):
        for j in range(m - k + 1):
            l = []
            sum1 = 0
            for p in range(i, k + i):
                for q in range(j, k + j):
                    sum1 += mat[p][q]
                    l.append(mat[p][q])
            dic[sum1].extend(l)
    res = dic[max(dic.keys())]
    unique = set(res)
    print(sum(unique))







# Driver Code
if __name__ == "__main__":

    mat = [[1, 0, 1, 5, 6],
           [3, 3, 0, 3, 3],
           [2, 9, 2, 1, 2],
           [0, 2, 4, 2, 0]
           ]

    '''    mat = [[1, 1, 1, 1, 1],
               [2, 2, 2, 2, 2],
               [3, 3, 3, 3, 3],
               [4, 4, 4, 4, 4],
               [5, 5, 5, 5, 5]]
    '''

    k = 2
    printSumSimple(mat, k)
The file binaryAutocomplete.py contains:
from collections import defaultdict
from operator import  itemgetter

def binaryAutocomplete(command):
    res= []
    res.append(0)
    for i in range(1,len(command)):
        #print("_________________________________")
        temp = command[i]
        latest = -1
        initialK = 0
        for j in range(i-1,-1,-1):
            flag = True
            k = 0
            l =0
            #print("Comparing: - ",i,j,command[i],command[j])
            while flag:
                #print(k,initialK)
                if k<len(command[j]) and l<len(command[i]) and command[j][k]==command[i][l]:
                    #print("------")
                    #print("Checking: - ",command[j][k], command[i][l])
                    k+=1
                    l+=1
                else:
                    flag = False
            #print(k,initialK)
            if k>initialK:
                initialK = k
                latest = j
                #print("k,InitiaK",k,initialK,"Index: - ", latest + 1)
        if latest==-1:
            res.append(i)
        else:
            res.append(latest+1)
    print(res)


class Trie:
    def __init__(self):
        self.d ={}
        self.index= []

class sol:
    def indexing(self,arr):
        print("----"*40)
        root = Trie()
        res=defaultdict(list)
        final = []

        for id,elem in enumerate(arr):
            trie = root
            level = 0
            for char in elem:
                level+=1
                if char not in trie.d:
                    trie.d[char] = Trie()
                #print(trie.d.items())
                #print(trie.index)
                trie = trie.d[char]
                trie.index.append((id,level))
                #trie.index.append((id,elem))

        originalRoot = root

        for elem in arr:
            root = originalRoot
            for j in elem:
                if root:
                    root = root.d.get(j)
                    if root:
                        res[elem].extend(root.index)


        for k,v in res.items():
            res[k] = sorted(list(set(v)),key=lambda x: (x[1],x[0]),reverse=True)

        for i in range(len(arr)):
            temp = res[arr[i]]
            flag = False
            for j in range(len(temp)):
                if temp[j][0]<i:
                    #print("Candidates: -",temp[j])
                    final.append(temp[j][0]+1)
                    flag = True
                    break
            if not flag:
                final.append(i)
        print(res)
        print("Final Output: -",final)




if __name__ == '__main__':
    #binaryAutocomplete(["000","1110","01","001","110","11"])
    #binaryAutocomplete(["100110","1001","1001111"])
    #binaryAutocomplete(["1","10","11010"])


    s = sol()
    s.indexing(["000","1110","01","001","110","11"])
    s.indexing(["100110","1001","1001111"])
    s.indexing(["1","10","11010"])


The file binaryPatterMatching.py contains:
#s = "amazing"
#pattern = "010"
s = "codesignal"
pattern  = "100"
s = list(s)
vowel = ['a','e','i','o','u','y']
def occurrences(string, sub):
    count = start = 0
    while True:
        start = string.find(sub, start) + 1
        if start > 0:
            count+=1
        else:
            return count
for i in range(len(s)):
    if s[i] in vowel:
        s[i] = "0"
    else:
        s[i]="1"
s =''.join(map(str, s))
print(s,pattern)
print(occurrences(s,pattern))


The file borderSort.py contains:
def matrix(x):
    n = len(x)
    temp = []
    for i in range(n):
        for j in range(n):
            if i==0 or j==0 or i==n-1 or j==n-1:
                temp.append(x[i][j])



if __name__ == '__main__':
    x = [[9,7,4,5],[1,6,2,-6],[12,20,2,0],[-5,-6,7,-2]]
    print(len(x))
    matrix(x)



The file breadth_first_search.py contains:
class Node:
    def __init__(self,root):
        self.val = root
        self.left = None
        self.right = None

class bfs:
    res = []
    def traverse(self,r):
        queue = []
        if r:
            queue.append(r)
        while len(queue)>0:
            data = queue.pop(0)
            self.res.append(data.val)
            if data.left:
                queue.append(data.left)
            if data.right:
                queue.append(data.right)

        return self.res

if __name__ == '__main__':
    root = Node(1)
    root.left = Node(2)
    root.right = Node(3)
    root.left.left = Node(4)
    root.left.right = Node(5)
    traverse = bfs()
    print(traverse.traverse(root))

The file bst_sum_of_nodes.py contains:

class Node:
    def __init__(self,root):
        self.left = None
        self.val = root
        self.right = None

class traverse:
    def sumOfNodes(self,r):
        res = 0
        if r:
            res+=self.sumOfNodes(r.left)+r.val+self.sumOfNodes(r.right)

        print("--------", res)
        return res

    def recursive(self,r):
        def helper(r,res):
            if r:
                helper(r.left, res)
                res.append(r.val)
                helper(r.right,res)
        res =[]
        helper(r,res)
        return res

    def iterative(self,r):
        queue = []
        res =[]
        if r:
            queue.append(r)
        while queue:
            data = queue.pop(0)
            res.append(data.val)
            if data.left:
                queue.append(data.left)
            if data.right:
                queue.append(data.right)

        return res

if __name__ == '__main__':
    op =[]
    root = Node(1)
    root.left = Node(2)
    root.right = Node(3)
    root.left.left = Node(4)
    root.left.right = Node(5)
    root.right.left = Node(6)
    root.right.right = Node(7)
    root.right.left.left = Node(8)
    tr = traverse()
    #op = tr.sumOfNodes(root.right)
    #print(op)

    #print(tr.recursive(root))
    print(tr.iterative(root))
The file calculateCoffeeStats.py contains:
import collections
def calculate_coffee_stats(office_stats_list):
    d = collections.defaultdict(dict)
    op = []
    for i in range(len(office_stats_list)):
        office_stats_list[i] = office_stats_list[i].replace("\r","")
        temp = office_stats_list[i].split(',')
        j = 0
        if temp[j] in d:
            d[temp[j]] [temp[j + 1]] = temp[j + 2]
        else:
            d[temp[j]] = {temp[j+1]:temp[j+2]}

    #print(d)
    for k,v in d.items():
        t = ""
        t+=k
        avg  =0
        for j,l in v.items():
            avg  = avg + int(l)
        t+=","+(str(avg))
        t+=","+(str(avg//len(v)))
        op.append(t)
    return op


if __name__ == '__main__':
    #l = ['Auc,Aug,9160','Auc,Jan,9160','Auc,Feb,9160']
    '''
    l = ['Auckland,Jan,9160','Auckland,Feb,5640', 'Auckland, Mar, 2323',
         'Auckland, Apr, 3214',
         'Auckland,May, 5645',
         'Auckland, Jun, 5678',
         'Auckland,Jul, 4175',
         'Auckland,Aug, 2020',
         'Auckland,Oct, 9823',
         'Auckland,Nov, 6540',
         'Auckland,Dec, 2563']
    '''

    l = ['Auckland, Jan, 9160',
         'Auckland, Feb, 5640',
         'Auckland, Mar, 2323',
         'Auckland, Apr, 3214',
         'Auckland, May, 5645',
         'Auckland, Jun, 5678',
         'Auckland, Jul, 4175',
         'Auckland, Aug, 2020',
         'Auckland, Oct, 9823',
         'Auckland, Nov, 6540',
         'Auckland, Dec, 2563',
         'Wellington, Jan, 5678',
         'Wellington, Feb, 4175',
         'Wellington, Mar, 2020',
         'Wellington, Apr, 9823',
         'Wellington, May, 6540',
         'Wellington, Jun, 2563',
         'Wellington, Jul, 9160',
         'Wellington, Aug, 5640',
         'Wellington, Oct, 2323',
         'Wellington, Nov, 3214',
         'Wellington, Dec, 5645']


print(calculate_coffee_stats(l))

The file canMakeTriangle.py contains:
def canMakeTriangle(arr):
    res = []
    for  i in range(len(arr)-2):
        if arr[i]+arr[i+1]>arr[i+2] and arr[i]+arr[i+2]>arr[i+1] and arr[i+1]+arr[i+2]>arr[i]:
            res.append(1)
        else:
            res.append(0)
    return res

if __name__ == '__main__':
    print(canMakeTriangle([1,2,2,4]))
    print(canMakeTriangle([2,10,2,10,2]))
    #print(canMakeTriangle([1000000000,])
The file can_make_palindrome.py contains:
import  collections
def canMakePaliQueries(s, l,r,k):
    queries=[]
    for i in range(len(l)):
        queries.append([l[i],r[i],k[i]])

    print(queries)
    N = 26
    S = len(s) + 1
    ints = list(map(lambda c: ord(c) - ord('a'), s))

    dp = [0] * S
    for i in range(1, S):
        dp[i] = dp[i-1] ^ (1 << ints[i-1])

    ones = lambda x: bin(x).count('1')
    return str(''.join(map(str,[
        int(ones(dp[r+1] ^ dp[l]) >> 1 <= k)
        for l, r, k in queries
    ])))


def canMakePaliQueries_2(s,queries):
    odds = [[False] * 26]
    for i, c in enumerate(s):
        odds.append(odds[i][:])
        odds[i + 1][ord(c) - ord('a')] ^= True
    return [sum(odds[hi + 1][i] ^ odds[lo][i] for i in range(26)) // 2 <= k for lo, hi, k in queries]


#print(canMakePaliQueries("bcba",1,2,1))
#print(canMakePaliQueries("bcba",[1,2,1],[3,3,1],[2,0,0]))
print(canMakePaliQueries("bcbab",[1,1,2],[4,3,3],[3,3,0]))
#print(canMakePaliQueries_2("bcba",[[1,3,2],[2,3,0],[1,1,0]]))
The file cerealSegment.py contains:
def cerealSegment(x,arr):
    b = []
    for i in range(len(arr)-x+1):
        v = []
        for j in range(i,i+x):
            v.append(arr[j])
        v = sorted(v)
        b.append(v[0])
    b = sorted(b,reverse=True)
    print(b[0])

if __name__ == '__main__':
    arr = [8, 2, 4]
    cerealSegment(2,arr)



The file check_balanced.py contains:
def balancedOrNot(expressions, maxReplacements):
    return_array = []
    for i in range(0, len(maxReplacements)):
        return_array.append(0)

    for count, each_data in enumerate(expressions):
        check_str = expressions[count]
        replacement_count = 0

        continue_loop = True
        while len(check_str) >= 1 and continue_loop:
            opening_count = check_str.count('<')
            closing_count = check_str.count('>')

            if opening_count > closing_count:
                replacement_count = maxReplacements[count] + 1
                continue_loop = False
            elif check_str[0] == '>':
                replacement_count += 1
                check_str = check_str[1:]
            else:
                check_str = check_str.replace('<>', '')

        if replacement_count <= maxReplacements[count]:
            return_array[count] = 1

    return return_array


print(balancedOrNot(expressions=["<>", "<<><>>"], maxReplacements=[0, 0]))  # [1,0]
print(balancedOrNot(expressions=["<>>>", "<>>>>"], maxReplacements=[2, 2]))  # [1,0]
print(balancedOrNot(expressions=["<>", "<>><"], maxReplacements=[2, 2]))  # [1, 0]
print(balancedOrNot(expressions=["<<<>", "<<><><"], maxReplacements=[2, 2]))  # [0,0]

print(balancedOrNot(expressions=["<<<>>>", "<>"], maxReplacements=[2, 2]))  # [0,1]
print(balancedOrNot(expressions=["<<><>>", "<><>"], maxReplacements=[2, 2]))  # [0,1]

print(balancedOrNot(expressions=["<<><>><", "><><><"], maxReplacements=[2, 2]))  # [0,0]
The file circularArray.py contains:
import operator
from collections import Counter

def prints(a, n, ind,end):
    visited = []
    b = [None] * 2 * n
    i = 0
    while i < n:
        b[i] = b[n + i] = a[i]
        i = i + 1
    i = ind
    visited.append(ind)
    while i < n + ind:
        visited.append(b[i])
        i = i + 1
        if b[i] == end:
            #print(end)
            visited.append(end)
            return visited

def prints1(a,n,start ,end):
    st= start
    visited = []
    #print(start,end)
    for i in range(0,(end-start)+1):
        if st%n ==0:
            visited.append(n)
        else:
            visited.append(st%n)
        st += 1
    return visited

def prints2(a,n,start ,end):
    st= start
    en = end
    visited = []
    print("Start",st,"End",en)
    while en < n + i :
        print(a[(i % n)], end = " ")
        i = i + 1
    return visited

def circularArray(n,endNode):
    i =0
    visitedDict = {}
    a = [item for item in range(1, n + 1)]
    #print(a)

    while i < len(endNode)-1:
        #print(a)
        visited = prints(a,n,endNode[i],endNode[i+1])
        #visitedDict.extend(visited)

        for each in visited:
            if each in visitedDict:
                visitedDict[each] += 1
            else:
                visitedDict[each] = 1
        i += 1
    #print(visitedDict)
    new  = sorted(visitedDict, key=lambda k: (-visitedDict[k], k))
    print(new)
    #occurence_count = Counter(visitedDict)
    #return max(visitedDict.items(), key=operator.itemgetter(1))[0]
    #print(occurence_count.most_common())
    return new[0]
    #return  occurence_count.most_common(1)[0][0]

#print(circularArray(5,[1,5]))
#print(circularArray(10,[1,5,10,5]))
print(circularArray(10,[1,5,10,5]))
#print(circularArray(3,[1,3,2,3]))

#start = 5
# Driver Code
'''a = [1,2,3,4,5,6,7,8,9,10]
n = 10
end = 1
print(prints(a, n, start,end))'''
The file circularPrime.py contains:
def findPrime(start,end):
    res =[]
    for val in range(start,end+1):
        temp = str(val)
        if int(temp[0])%2==0 or int(temp[-1])%2==0:
            continue
        if val>1:
            for n in range(2,val):
                if val%n==0:
                    break
            else:
                res.append(val)
    return res

def ifCircular(op,re):
    reverNum=0
    temp = re
    while re > 0:
        a = re % 10
        reverNum = reverNum * 10 + a
        re = re // 10
    print(reverNum,temp)
    if reverNum==temp:
        return False
    elif reverNum in op:
        return True

if __name__ == '__main__':
    op = findPrime(1,100)
    res =[]
    for i in range(len(op)):
        if ifCircular(op,op[i]):
            res.append(op[i])

    print(res)
    print(len(res))
The file Circular_Array_Loop.py contains:
class Solution:
    def circularArrayLoop(self,nums):
        s, l = [], len(nums)
        for i, n in enumerate(nums):
            if i in s: continue  # check repeated i
            d = []
            while n * nums[i] > 0:  # forward or backward movements only
                if i in d:
                    if d[-1] != i:
                        return True  # the cycle's length must be greater than 1
                    else:
                        break
                d.append(i)  # store i for a cycle
                s.append(i)  # store i without checking the repetition in the following
                i = (i + nums[i]) % l
        return False


if __name__ == '__main__':
    s = Solution()
    print(s.circularArrayLoop([1, 1, 1, 1,1, 0, 0, 1,1, 1, 1, 1]))

    #[[1, 1, 1, 1], [1, 0, 0, 1], [1, 1, 0, 1]]
The file citrix_climb_hill.py contains:
a = [9,8,7,2,2,3]
b = a.copy()
cost = 0
cost1 = 0
print(max(a))
print(a.index(9))

for i in range(len(a)):
    if i != a.index(max(a)):
        cost = cost -a[i]

cost = cost + max(a)
for i in range(len(a)-1):
    if a[i+1]>a[i]:
        min(a[i],a[i+2])
        cost1 = cost1 + (min(a[i],a[i+2])+a[i])
print(cost1)
The file citrix_photo_album.py contains:

'''
for i in range(len(a)):
    c.insert(a[i],b[i])
print(c)
'''
class Node:
    def __init__(self, val):
        self.val = val
        self.next = None

def photoAlbum(index, identity):
    head = Node(identity.pop(0))
    index.pop(0)
    while identity:
        i = index.pop(0) - 1
        if i == -1:
            temp = Node(identity.pop(0))
            temp.next = head
            head = temp
            continue
        temp = head
        while i > 0:
            temp = temp.next
            i -= 1;
        new_node = Node(identity.pop(0))
        new_node.next = temp.next
        temp.next = new_node
    out = []
    while head:
        out.append(head.val)
        head = head.next
    return out

if __name__ == '__main__':
    n = 2
    a = [0, 1, 0]
    b = [0, 1, 2]
    print(photoAlbum(a,b))
The file City_Attrations.py contains:
import math
import os
import random
import re
import sys

#path = []


def findBestPath(n, m, max_t, beauty, u, v, t):
    path = [[] for i in range(m)]
    for i in range(m-1):
        path[u[i]].append([v[i], t[i]])
        #print(i,n,m,u,v,t)
        path[v[i]].append([u[i], t[i]])

    return [0, 1]


if __name__ == '__main__':

    n = int(input().strip())

    m = int(input().strip())

    max_t = int(input().strip())

    beauty_count = int(input().strip())

    beauty = []

    for _ in range(beauty_count):
        beauty_item = int(input().strip())
        beauty.append(beauty_item)

    u_count = int(input().strip())

    u = []

    for _ in range(u_count):
        u_item = int(input().strip())
        u.append(u_item)

    v_count = int(input().strip())

    v = []

    for _ in range(v_count):
        v_item = int(input().strip())
        v.append(v_item)

    t_count = int(input().strip())

    t = []

    for _ in range(t_count):
        t_item = int(input().strip())
        t.append(t_item)

    result = findBestPath(n, m, max_t, beauty, u, v, t)

    print(str(result) + '\n')
The file Colored_Loop.py contains:
def color_loop(n,m,mat):
    for i in range(n-1):
        for j in range(m):
            #print(i,j)
            c = mat[i][j]
            for k in range(j+1,m):
                if mat[i][k] != c:
                    break
            k-=1
            if k>j:
                for l in range(i+1,n-1):
                    #print(l,k)
                    if mat[l][k] != c:
                        break
                l-=1
                print(l,i)
                if l>i:
                    p=k
                    while p-j >= 0:
                        if mat[l][p] != c:
                            break
                        p -= 1
                    p+=1
                    if p == j:
                        q=l
                        while q >= i:
                            if mat[q][p] != c:
                                break
                            q-=1
                        q+=1
                        if q==i:
                            return True
    return False
x = [
    ['B','B','B','B','B','B','B'],
    ['B','R','G','G','G','B','B'],
    ['B','G','B','B','G','B','B'],
    ['B','G','G','G','G','B','B'],
    ['B','B','B','B','B','B','B'],
    ['B','B','B','B','B','B','B']
]
print(color_loop(7,6,x))
The file combination_permutation.py contains:
#import os
import gc
from itertools import permutations
import itertools

def arraysCount(n,m,totalcost):
    idx = 0
    result = []
    while idx < len(n):
        print('answers index: ',idx)
        temp_result = []

        if n[idx] <= m[idx]:
            all_arrays = perm(n[idx],m[idx])
            print('all_arrays:',all_arrays)
        else:
            all_arrays = perm_rep(n[idx],m[idx])
            print('im here')
            print('all_arrays:', all_arrays)

        for each in all_arrays:
            if fun_totalCost(each) == totalcost[idx]:
                temp_result.append(each)
        result.append(len(temp_result))
        del(temp_result)
        gc.collect()
        idx += 1
    return result
    #print(result)


def fun_totalCost(element):
    curr_max = element[0]
    total_cost = 0

    for i in range(1,len(element)):
        if element[i] > curr_max:
            curr_max = element[i]
            total_cost += 1

    return total_cost

def perm(n,m):

    arr= []
    for i in range(1,m+1):
        arr.append(i)
    main_list = []
    for subset in permutations(arr, n):
        main_list.append(list(subset))
    return main_list

def perm_rep(n,m):
    arr = []
    for i in range(1, m + 1):
        arr.append(i)
    main_list = [list(p) for p in itertools.product(arr, repeat=n)]
    return main_list

if __name__ == '__main__':
    #fptr = open(os.environ['OUTPUT_PATH'], 'w')
    '''
    n_count = int(input().strip())

    n =[]

    for i in range(n_count):
        n_item = int(input().strip())
        n.append(n_item)


    m_count = int(input().strip())

    m =[]

    for i in range(m_count):
        m_item = int(input().strip())
        m.append(m_item)

    totalCost_count = int(input().strip())

    totalCost =[]

    for i in range(n_count):
        totalCost_item = int(input().strip())
        totalCost.append(totalCost_item)

    '''

    res = arraysCount([2,3,4],[3,3,3],[1,2,3])
    #res = arraysCount(n,m,totalCost)
    print(res)
    #fptr.write('\n'.join(map(str,res)))
    #fptr.write('\n')

    #fptr.close()
#print("Result - ",res)

#print(perm_rep(4,3))
#[2,3,4],[3,3,3],[1,2,2]



The file connectNropesWithMinCost.py contains:
import heapq
def connectNropes(arr1):
    res =[]
    for i in range(len(arr1)):
        heapq.heappush(res,arr1[i])
    count =0
    while len(res)!=1:

        data1 = heapq.heappop(res)
        data2 = heapq.heappop(res)
        #print(data1, data2)
        count+=data1+data2
        heapq.heappush(res,data1+data2)

    print(count)

if __name__ == '__main__':
    connectNropes([4,3,2,6])
The file constructorNames_Quora.py contains:
def constructorNames(a, b):
    if len(a) != len(b):
        return False
    myA = {}
    myB = {}
    for i in range(len(a)):
        if a[i] not in b or b[i] not in a:
            return False
        if a[i] not in myA:
            myA[a[i]] = 1
        else:
            myA[a[i]] += 1
        if b[i] not in myB:
            myB[b[i]] = 1
        else:
            myB[b[i]] += 1
    for ka, va in myA.items():
        for kb, vb in list(myB.items()):
            if va == vb:
                myB.pop(kb)
    if len(myB) == 0:
        return True
    return False

print(constructorNames("babczzz","abbzccc"))
print(constructorNames("aabbzqqq","aabbzzzq"))
print(constructorNames("x","y"))
The file coolFeature.py contains:
def pairwithSum(x,y,n):
    count = 0
    for k in range(len(x)):
        for j in range(len(y)):
            if x[k] + y[j] == n:
                count += 1
    #print(count)
    return count

def pairwithSum1(x,y,q):
    m ={}
    result = []
    for i in range(len(x)):
        if x[i] not in m:
            m[x[i]] =1
        else:
            m[x[i]] +=1
    for i in range(0,len(q)):
        if len(q[i]) == 3:
            index = q[i][1]

            y[index] = q[i][2]
        if len(q[i])==2:
            sum = q[i][1]
            count = 0
            for j in range(0,len(y)):
                if sum - y[j] in m:
                    count+=m[sum -y[j]]
            result.append(count)

    return  result

x = [1,2,3]
#x = [1,2,2]
y = [3,4]
#y = [2,3]
q = [[1,5],[0,0,1],[1,5]]
#q = [[1,4],[0,0,3],[1,5]]

print(pairwithSum1(x,y,q))

def coolFeature(a,b,query):
    m=[]
    if len(a) or len(b) == 0:
        return []
    for i in range(len(query)):
        count=0
        if query[i][0] == 0:
            if query[i][1]<len(query[i][1]):
                b[query[i][1]] = query[i][2]
        else:
            for k in range(len(a)):
                for j in range(len(b)):
                    if a[k] + b[j] == query[i][1]:
                        count+=1
            m.append(count)
    return m

'''
res = []
for i in range(len(q)):
    if len(q[i])==2:
        #print(pairwithSum(x,y,q[i][1]))
        res.append(pairwithSum(x,y,q[i][1]))
    elif len(q[i])==3:
        temp = q[i]
        y.pop(temp[1])
        y.insert(temp[1],temp[2])
print(res)
'''
#print(coolFeature(x,y,q))
#print(coolFeature(x,y,q))

The file countdistictpairs.py contains:
def binarySearch(arr, low, high, x):
    if (high >= low):

        mid = low + (high - low) // 2
        if x == arr[mid]:
            return (mid)
        elif (x > arr[mid]):
            return binarySearch(arr, (mid + 1), high, x)
        else:
            return binarySearch(arr, low, (mid - 1), x)

    return -1


# Returns count of pairs with
# difference k in arr[] of size n.
def countPairsWithDiffK(arr, n, k):
    count = 0
    arr.sort()  # Sort array elements
    s = set()
    for i in range(0, n - 2):
        mid = binarySearch(arr, i + 1, n - 1,abs(arr[i] - k))
        if (mid != -1):
            count += 1
            s.add((arr[i],arr[mid]))

    print(s)
    return len(s)


# Driver Code
# arr = [1, 5, 3, 4, 2]
# arr = [6,6,3,9,3,5,1]
arr = [1,3,46,1,3,9]
n = len(arr)
k = 47
print("Count of distinct pairs with given sum is ",
      countPairsWithDiffK(arr, n, k))
The file Countingbit.py contains:
def  countSetBits(n):
    res = []
    x = (bin(n).replace("0b",""))
    print(x)
    res.append(x.count('1'))
    for i in range(0,len(x)):
        if x[i] == '1':
            res.append(i+1)
    return res


def decimalToBinary(n):
   count = 0
   s = bin(n)
   res = [s.count('1')]
   for i in range(len(s)):
      if s[i] == '1':
         res.append(i-1)
   return res

print(countSetBits(37))
print(decimalToBinary(37))
The file countOfCharacterInString.py contains:
s = "SumedhJoglekar"

d  ={}
for i in s:
    if i not in d:
        d[i] = 1
    else:
        d[i]+=1

print(d)
The file criticalRouters.py contains:
import collections
'''
def FindCriticalNodes(numEdges, numNodes, edges):
    # Get all the node
    nodes = []
    for i in range(numEdges):
        # Get nodes
        if edges[i][0] not in nodes:
            nodes.append(edges[i][0])

        if edges[i][1] not in nodes:
            nodes.append(edges[i][1])

    # Get all the neighbours
    neighbours = {node: [] for node in nodes}
    for i in range(numEdges):
        # Get neighbours
        neighbours[edges[i][0]].append(edges[i][1])
        neighbours[edges[i][1]].append(edges[i][0])

    def dfs(parent, seen):
        nonlocal neighbours
        # print("Visiting node {}".format(parent))

        # Mark the parent as explored
        seen[parent] = 1

        # Get all the neighbours from parent
        neig = neighbours[parent]

        # Iterate all the neighbours
        for i in range(len(neig)):
            # return if this node was exlored
            if seen[neig[i]] == 1:
                continue

            # DFS
            dfs(neig[i], seen)

    # Loop over all the nodes
    output = []
    for i in range(numNodes):
        explored = {node: 0 for node in nodes}

        # Mark the cutting point as explored as we
        # don't wanna explore this point
        explored[nodes[i]] = 1

        # DFS
        # Traverse from 0 every time
        total_visited = 1
        dfs(nodes[0], explored)

        print("Node {}: Explores {} nodes.".format(nodes[i], sum(explored.values())))
        # If all nodes are explored, it means it's not articulate point
        if (sum(explored.values()) < numNodes):
            output.append(nodes[i])

    print(neighbours, nodes)
    print(output)


if __name__ == "__main__":
    numNodes, numEdges = 7, 7
    #edges = [[0, 1], [0, 2], [1, 3], [2, 3], [2, 5], [5, 6], [3, 4]]
    edges = [[1, 2], [1, 3], [2, 4], [3, 4], [3, 6], [6, 7], [4, 5]]
    FindCriticalNodes(numNodes, numEdges, edges)

'''

# Input:
# numNodes = 7,
# numEdges = 7,
# edges = [[0, 1], [0, 2], [1, 3], [2, 3], [2, 5], [5, 6], [3, 4]]
# Output:
# [2, 3, 5]

def findcriticalnodes(n, edges):
    g = collections.defaultdict(list)
    for conn in edges:
        g[conn[0]].append(conn[1])
        g[conn[1]].append(conn[0])
    visited = [0] * n
    isarticulationpoints = [0] * n
    order = [0] * n
    low = [0] * n
    seq = 0

    def dfs(u, p):
        nonlocal seq
        visited[u] = 1
        order[u] = low[u] = seq
        seq = seq + 1
        children = 0
        for to in g[u]:
            if to == p:
                continue
            if visited[to]:
                low[u] = min(low[u], low[to])
            else:
                dfs(to, u)
                low[u] = min(low[u], low[to])
                if order[u] <= low[to] and p != -1:
                    isarticulationpoints[u] = 1
                children += 1

        if p == -1 and children > 1:
            isarticulationpoints[u] = 1

    dfs(0, -1)
    ans = []
    for i in range(len(isarticulationpoints)):
        if isarticulationpoints[i]:
            ans.append(i)
    return ans


if __name__ == "__main__":
    a = [[1, 2], [1, 3], [2, 4], [3, 4], [3, 6], [6, 7], [4, 5]]
    print(findcriticalnodes(7, a))
The file critical_connections.py contains:
from collections import defaultdict

class Solution:
    def criticalConnections(self, n, connections):
        currentRank = 0  ## please note this rank is NOT the num (name) of the vertex itself, it is the order of your DFS level

        lowestRank = [i for i in
                      range(n)]  ## here lowestRank[i] represents the lowest order of vertex that can reach this vertex i

        visited = [False for _ in range(n)]  ## common DFS/BFS method to mark whether this node is seen before
        graph = defaultdict(list)
        for v in connections:
            graph[v[0]].append(v[1])
            graph[v[1]].append(v[0])
        print(graph)

        res = []
        prevVertex = -1  ## This -1 a dummy. Does not really matter in the beginning.
        ## It will be used in the following DFS because we need to know where the current DFS level comes from.
        ## You do not need to setup this parameter, I setup here ONLY because it is more clear to see what are passed on in the DFS method.

        currentVertex = 0  ## we start the DFS from vertex num 0 (its rank is also 0 of course)
        self._dfs(res, graph, lowestRank, visited, currentRank, prevVertex, currentVertex)
        return res


    def _dfs(self, res, graph, lowestRank, visited, currentRank, prevVertex, currentVertex):
        visited[currentVertex] = True  # it is possible
        lowestRank[currentVertex] = currentRank

        for nextVertex in graph[currentVertex]:
            if nextVertex == prevVertex:
                continue  ## do not include the the incoming path to this vertex since this is the possible ONLY bridge (critical connection) that every vertex needs.

            if not visited[nextVertex]:
                self._dfs(res, graph, lowestRank, visited, currentRank + 1, currentVertex, nextVertex)
            # We avoid visiting visited nodes here instead of doing it at the beginning of DFS -
            # the reason is, even that nextVertex may be visited before, we still need to update my lowestRank using the visited vertex's information.

            lowestRank[currentVertex] = min(lowestRank[currentVertex], lowestRank[nextVertex])
            # take the min of the current vertex's and next vertex's ranking
            if lowestRank[
                nextVertex] >= currentRank + 1:  ####### if all the neighbors lowest rank is higher than mine + 1, then it means I am one connecting critical connection ###
                res.append([currentVertex, nextVertex])

class Solution1:
    def criticalConnections(self, n, connections):
        graph = defaultdict(list)
        for v in connections:
            graph[v[0]].append(v[1])
            graph[v[1]].append(v[0])
        print(graph)
        pre = [-1 for i in range(1,n+1)]
        low = [-1 for i in range(1,n+1)]
        order = 1
        ans = []
        def dfs(par, cur, order):  # pass in parent node, current node and order
            order += 1
            pre[cur+1] = order
            low[cur+1] = pre[cur+1]
            for w in graph[cur]:
                if (pre[w+1] == -1):
                    dfs(cur, w, order)
                    low[cur+1] = min(low[cur+1], low[w+1])
                    if (low[w+1] == pre[w+1]):
                        ans.append((cur, w))

                elif (w != par):
                    low[cur+1] = min(low[cur+1], pre[w+1])

                dfs(1, 1, 0)  # only need to start from one node, since from one node you can reach any other nodes in an undirected graph, dfs(1, 1, 0) will also work
        print(ans)
        return ans

if __name__ == '__main__':
    n = 7
    #edges = [[1, 2], [1, 3], [3, 4], [1, 4], [4, 5]]
    #edges = [[1, 2], [1, 3], [3, 4], [1, 4], [4, 5]]
    #edges = [[1,2],[1,3],[2,3],[3,4],[4,5],[4,6],[5,6],[5,7],[6,7],[7,8],[8,9],[9,10]]
    #edges = [[1,2],[2,3],[3,4],[4,5],[6,3]]
    edges = [[1, 2], [1, 3], [2, 4], [3, 4], [3, 6], [6, 7], [4, 5]]
    solution = Solution()
    print(solution.criticalConnections(n, edges))

The file critical_router.py contains:
from collections import defaultdict

class Graph:
    def __init__(self, vertices):
        self.V = vertices + 1
        self.adj_list = defaultdict(list)
        self.parent = [-1] * self.V
        self.low = [float('inf')] * self.V
        self.disc = [float('inf')] * self.V
        self.visited = [False] * self.V
        self.time = 0
        self.bridges = []

    def add_edge(self, v, u):
        self.adj_list[u].append(v)
        self.adj_list[v].append(u)

    def find_bridges(self, u):
        self.visited[u] = True
        self.low[u] = self.time
        self.disc[u] = self.time
        self.time += 1
        for v in self.adj_list[u]:
            if not self.visited[v]:
                self.low[u] = min(self.low[u], self.low[v])
                if self.low[v] > self.disc[u]:
                    self.bridges.append([u, v])

            elif v != self.parent[u]:
                self.low[u] = min(self.low[u], self.disc[v])


def criticalConnection(numOfWarehouses, numOfRoads, roads):
    ans = []
    adj_list = defaultdict(list)
    for s, d in roads:
        adj_list[s].append(d)
        adj_list[d].append(s)
    for s, d in roads:
        adj_list[s].remove(d)
        adj_list[d].remove(s)
        if len(dfs(s, adj_list, set())) != numOfWarehouses:
            ans.append((s, d))
        adj_list[s].append(d)
        adj_list[d].append(s)
    return ans

def dfs(s, adj_list, visited):
    visited.add(s)
    for d in adj_list[s]:
        if d not in visited:
            dfs(d, adj_list, visited)
    return visited

if __name__ == '__main__':
    g = Graph(7)
    edges = [[1, 2], [1, 3], [2, 4], [3, 4], [3, 6], [6, 7], [4, 5]]
    #edges = [[1, 2], [1, 3], [2, 3], [3, 4], [3, 6], [4, 5], [6, 7], [6, 9], [7, 8], [8, 9]]
    #edges = [[1, 2], [1, 3], [2, 3], [3, 4], [4, 5], [4, 6], [5, 6], [5, 7], [6, 7], [7, 8],[8,9],[8,10],[9,10]]
    #edges = [[1, 2], [2, 3], [3, 4], [4, 5], [6, 3]]
    #edges = [[1, 2], [1, 3], [3, 4], [1, 4], [4, 5]]
    #edges = [[1, 2], [2, 3], [3, 4], [4, 5], [6, 3]]

    for i in edges:
        g.add_edge(i[0], i[1])

    for j in range(1, g.V):
        if not g.visited[j]:
            g.find_bridges(j)

    print(g.adj_list)
    print(sorted(g.bridges))


    print(criticalConnection(5,6,edges))
The file CTCI_1.1.py contains:
# Is Unique

def is_unique(s):
    bitVector = []
    for i in range(256):
        bitVector.append(False)
    for char in s:
        print(ord(char))
        if bitVector[ord(char)] == True:
            return "Not Unique"
        else:
            bitVector[ord(char)] = True
    return "Unique String"

def is_unique_using_set(s):
    unique_char = set()
    for char in s:
        if char in unique_char:
            return "Not Unique"
        else:
            unique_char.add(char)
    print("Set :- ", unique_char)
    return "Unique String"

def using_sort(s):
    s = sorted(s)
    print("sorted string: - ",s)
    for char in range(len(s)-1):
        if s[char]==s[char+1]:
            return "Not Unique String"
    return "Unique String"



if __name__ == '__main__':
    s = "SumedhS"
    print(is_unique(s))
    print(is_unique_using_set(s))
    print(using_sort(s))


The file CTCI_1.2.py contains:
# Check Permutation
from collections import Counter as c
def chkPermutation(str1,str2):
    if len(str1)!=len(str2):
        return False
    s = {}
    #s2 = c(str1)
    #print(s2)
    for char in str1:
        if char in s:
            s[char] +=1
        else:
            s[char]=1
    print("Before :-",s)
    for char in str2:
        if char not in s:
            print("After Removal: -", s)
            return False
        elif s[char]<=0:
            print("After Removal: -", s)
            return False
        else:
            s[char]-=1
    print("After Removal: -",s)
    return True

if __name__ == '__main__':
    str1 = "sumedha"
    str2 = "dhumess"

    print(chkPermutation(str1,str2))

The file CTCI_1.3.py contains:
# URLify
def urlift(str1,length):
    str1 = str1[:length].replace(' ','%20')
    print(str1)


if __name__ == '__main__':
    str1 = "Mr John Smith    "
    length = 13
    urlift(str1,length)
The file dam_design.py contains:

def wall(wallPositions,wallHeight):
    n = len(wallPositions)
    m = len(wallHeight)
    max_mud_len = -1
    for i in range(n - 1):
        if wallPositions[i] < wallPositions[i + 1] - 1:
            heightDiff = abs(wallHeight[i + 1] - wallHeight[i])
            gapLen = wallPositions[i + 1] - wallPositions[i] - 1
            if gapLen > heightDiff:
                low = max(wallHeight[i + 1], wallHeight[i]) + 1
                remainingGap = gapLen - heightDiff - 1
                localMax = low + remainingGap // 2
            else:
                localMax = min(wallHeight[i + 1], wallHeight[i]) + gapLen

            max_mud_len = max(max_mud_len, localMax)
    return max_mud_len

The file detectCycle.py contains:
d = {
    0:[1,2],
    1:[2],
    2:[0,3],
    3:[3]

}

# Python program to detect cycle
# in a graph

from collections import defaultdict

class Graph():
	def __init__(self,vertices):
		self.graph = defaultdict(list)
		self.V = vertices

	def addEdge(self,u,v):
		self.graph[u].append(v)

	def isCyclicUtil(self, v, visited, recStack):

		# Mark current node as visited and
		# adds to recursion stack
		visited[v] = True
		recStack[v] = True

		# Recur for all neighbours
		# if any neighbour is visited and in
		# recStack then graph is cyclic
		for neighbour in self.graph[v]:
			if visited[neighbour] == False:
				if self.isCyclicUtil(neighbour, visited, recStack) == True:
					return True
			elif recStack[neighbour] == True:
				return True

		# The node needs to be poped from
		# recursion stack before function ends
		recStack[v] = False
		return False

	# Returns true if graph is cyclic else false
	def isCyclic(self):
		visited = [False] * self.V
		recStack = [False] * self.V
		for node in range(self.V):
			if visited[node] == False:
				if self.isCyclicUtil(node,visited,recStack) == True:
					return True
		return False

g = Graph(4)
g.addEdge(0, 1)
g.addEdge(0, 2)
g.addEdge(1, 2)
g.addEdge(2, 0)
g.addEdge(2, 3)
g.addEdge(3, 3)
if g.isCyclic() == 1:
	print("Graph has a cycle")
else:
	print("Graph has no cycle")

# Thanks to Divyanshu Mehta for contributing this code

The file DiagonalsRearranging.py contains:
import itertools
def get_rows(grid):
    return [[c for c in r] for r in grid]

def get_cols(grid):
    return zip(*grid)

def get_backward_diagonals(grid):
    b = [None] * (len(grid) - 1)
    grid = [b[i:] + r + b[:i] for i, r in enumerate(get_rows(grid))]
    return [[c for c in r if c is not None] for r in get_cols(grid)]

#a = [["b", "b"],["c","a"]]
a= [["a","c","a","b","b"],["c","b","a","c","b"],["a","a","e","c","b"],["b","b","d","a","g"],["a","b","e","b","a"]]
arr = (get_backward_diagonals(a))
N = len(a)
res= {}
for j in range(len(arr)):
    shape_list = arr[j]
    g = itertools.cycle(shape_list)
    temp = []
    for i in range(N):
        shape = next(g)
        temp.append(shape)
    temp = "".join(temp)

    res[j+1] = temp

import operator

sorted_x = sorted(res.items(), key=operator.itemgetter(1))
print([x[0] for x in sorted_x])
print([x[0] for x in sorted_x])
The file digitManipulation.py contains:
def digitManipulations(n):
    n = str(n)
    product = 1
    sum1 =0
    for i in range(len(n)):
        product = product *int(n[i])
        sum1 = sum1 +int(n[i])


    print(product-sum1)


if __name__ == '__main__':
    digitManipulations(123456)
    digitManipulations(1010)

The file digitSum.py contains:

def digitSum(n1,n2):
    d = {}
    count = 0
    print(n2+1-n1)
    n2 =n2+1
    i =n1
    while i < n2:
        if i>9:
            if i%10 !=0:
                temp = int(i%10)
            else:
                n2 = n2+1
                i+=1
                continue
        else:
            temp = i
        if temp in d:
            d[temp] +=1
        else:
            d[temp] = 1
        i+=1
    key = max(d.values())
    print("Key",key)
    for i in d.values():
        if i == key:
            count+=1
    print(d)
    return (count,get_key(d,key))


def get_key(d,val):
    for key, value in d.items():
         if val == value:
             return key

print(digitSum(3,12))
print(digitSum(1,10))
print(digitSum(1,5))


The file evenOddOperations.py contains:
def getMaximumscore(integerArray,start,end, operation, sum1,score):
    if sum1 ==0:
        return score
    if operation%2 ==0:
        score -=sum1
    else:
        score +=sum1
    score1 = getMaximumscore(integerArray,start+1,end,operation+1,sum1-integerArray[start],score)
    score2 = getMaximumscore(integerArray,start,end-1,operation+1,sum1-integerArray[end],score)
    return max(score1,score2)

if __name__ == '__main__':
    #n = 6
    #n =3
    n = 1
    #integerArray = [1, 2, 3, 4, 2, 6]
    #integerArray = [1,2,3 ]
    integerArray = [10]
    initialScore = 0
    print(getMaximumscore(integerArray,0,len(integerArray)-1,1,sum(integerArray),0))

The file exampleOfMemoryView.py contains:
import time
for n in (100000, 200000, 300000, 400000):
    data = 'x'*n
    start = time.time()
    b = data
    while b:
        b = b[1:]
    print('bytes', n, time.time()-start)

for n in (100000, 200000, 300000, 400000):
    data = b'x'*n
    start = time.time()
    b = memoryview(data)
    while b:
        b = b[1:]
    print('memoryview', n, time.time()-start)



The file fastDelivery.py contains:
n = 3
boxes = [1,2,3]
#boxes =[7,4,7]#39
#boxes = [3,2,1]#15
#boxes = [4,7,2]
total_time = 0

'''
for i in range(0,len(boxes)):
    if boxes[i]>0:
        travel_time = (n-i) * boxes[i]
        count = boxes[i]
        print("Travel Time: ",travel_time)
        for j in range(i+1,len(boxes)):
            if boxes[j] != 0:
                if boxes[j]<boxes[i]:
                    count+=boxes[j]
                    boxes[j] = 0
                elif boxes[j]>=boxes[i]:
                    count+=boxes[i]
                    boxes[j] = boxes[j]-boxes[i]
        total_time += travel_time+count
        print(total_time)
        boxes[i] = 0
        count = 0
'''

def test(boxes):
    sumOfboxes = sum(boxes)
    maxNum = boxes[0]
    if boxes[0]!=0:
        travel_time= boxes[0]*(len(boxes))
    else:
        travel_time = 0
    for i in range(1,len(boxes)):
        if boxes[i]!=0:
            if boxes[i]>maxNum:
                travel_time+=(boxes[i]-maxNum)*(n-i)
        if boxes[i]>maxNum:
            maxNum = boxes[i]

    print("Travel Time",travel_time,"sum of boxes",sumOfboxes)
    return sumOfboxes+travel_time


#print(total_time)

print(test(boxes))




The file fibonacci.py contains:
def fibo_recursive(n):
    if n ==1:
        return 0
    if n ==2:
        return 1
    else:
        return fibo_recursive(n-1)+fibo_recursive(n-2)

def fibo_iterative(n):
    res =[0,1]
    for i in range(2,n,1):
        #print(res)
        res.append(res[i-1] + res[i-2])
    return res[-1]


print(fibo_recursive(9))
print(fibo_iterative(9))


The file findFile.py contains:
s = "d1/d2/a"
s1 = "a"
s2 = "d1/d2/b"
paths = [s,s1,s2]
ip_set = []
target = "d2"
op = []
'''
for i in range(len(paths)):
    # Making set of all directories in a paths by spliting on '/'
    ip_set.append(set(paths[i].split('/')))


for i in range(len(ip_set)):
    if target in ip_set[i]:
        op.append(paths[i])

print(op)
'''



import os
import sys

walk_dir = '.'

print('walk_dir = ' + walk_dir)
target_file = 'a.txt'
# If your current working directory may change during script execution, it's recommended to
# immediately convert program arguments to an absolute path. Then the variable root below will
# be an absolute path as well. Example:
# walk_dir = os.path.abspath(walk_dir)
print('walk_dir (absolute) = ' + os.path.abspath(walk_dir))

for root, subdirs, files in os.walk(walk_dir):
    print('--\nroot = ' + root)
    list_file_path = os.path.join(root, target_file)
    with open(list_file_path, 'wb') as list_file:
        for subdir in subdirs:
            print('\t- subdirectory ' + subdir)

        for filename in files:
            file_path = os.path.join(root, filename)

            print('\t- file %s (full path: %s)' % (filename, file_path))

            with open(file_path, 'rb') as f:
                f_content = f.read()
                list_file.write(('The file %s contains:\n' % filename).encode('utf-8'))
                list_file.write(f_content)
                list_file.write(b'\n')
The file findIfPermutationDivisibleBy8.py contains:
def permute(nums):
    def backtrack(first=0):
        if first == n:
            if int(''.join(map(str, nums)))%8==0:
                print("Found")
                return True
        for i in range(first, n):
            nums[first], nums[i] = nums[i], nums[first]
            op1 = backtrack(first + 1)
            if op1:
                return  True
            nums[i], nums[first] = nums[first], nums[i]

        return False

    n = len(nums)
    temp = backtrack()
    if temp == True:
        return "YES"
    else:
        return "NO"

def checkDivisibility(arr):
    op = []
    for i in range(len(arr)):
        arr[i]  = list(map(int, str(arr[i])))
        op.append(permute(arr[i]))

    return op


def solve(num):
    number = str(num)
    l = len(number)
    if l == 1:
        if int(number) % 8 == 0:
            return "YES"
        else:
            return "NO"
    elif l == 2:
        if int(number) % 8 == 0 or int(number[::-1]) % 8 == 0:
            return "YES"
        else:
            return "NO"

    # when there are 3 or more digits
    hm = [0 for _ in range(10)]
    for char in number:
        hm[int(char)] += 1

    for i in range(0, 1000, 8):
        copy = list(hm)
        s = "00" + str(i)
        j = -1
        while j >= -3:  # check 3 digits
            d = int(s[j])
            if copy[d] <= 0: break
            copy[d] -= 1
            j -= 1
        if j == -4:
            return "YES"
    return "NO"




if __name__ == '__main__':
    print(checkDivisibility([61,75,0]))

    print()
The file findIndexofFirst1.py contains:
def binarySearch(array,target):
    def helper(start,end):
        mid = (start+end)//2
        if start<=end:
            if array[mid]==target and (array[mid-1]!=target):
                return mid
            elif array[mid]>=target:
                return helper(start,mid-1)
            elif array[mid]<target:
                return helper(mid+1,end)
        else:
            return -1

    return helper(0,len(array)-1)

print(binarySearch([1,1,1,1,2,2,2,4,4,4],4))
The file findLoop.py contains:
def findLoop(n,m,arr):
    for i in range(n):
        x = arr[i]
        for j in range(m):
            if arr[i+j] != x:
                break


The file findTrip.py contains:
'''
GIVEN A LIST OF FLIGHTS (IN ANY ORDER), CONSTRUCT THE TRIP
THAT THIS LIST REPRESENTS. FOR EXAMPLE, IF WE HAVE A FLIGHT
FROM SAN FRANCISCO TO DALLAS AND A FLIGHT FROM LOS ANGELES
TO SAN FRANCISCO, THE TRIP IS "LAX TO SFO TO DFW".

ASSUMPTIONS:
EACH CITY WILL BE VISITED ONLY ONCE.
THE LIST WILL ONLY REPRESENT ONE SINGLE TRIP.

FLIGHTS = [('SFO', 'DFW'), ('LAX', 'SFO'), ('DFW', 'CLT')]
TRIP: ['LAX', 'SFO', 'DFW', 'CLT']

IF THE ABOVE WORKS, TRY YOUR PROGRAM WITH THE FOLLOWING INPUT:
FLIGHTS = [('DFW','CLT'), ('SFO','DFW'), ('WAS','NYK'), ('LAX','SFO'), ('CLT','WAS')]
TRIP: ['LAX', 'SFO', 'DFW', 'CLT', 'WAS', 'NYK']
'''

#flight = [('SFO','DFW'),('LAX','SFO'),('DFW','CLT')]
#flight = {'SFO':'DFW','LAX':'SFO','DFW':'CLT'}
flight = {'DWF':'CLT','SFO':'DWF','WAS':'NYK','LAX':'SFO','CLT':'WAS'}
tmp = []
op  =[]
for k,v in flight.items():
    res = []
    tmp.append(v)
    res.append(k)
    res.append(v)
    while tmp:
        data = tmp.pop(0)
        if data in flight.keys():
            tmp.append(flight[data])
            res.append(flight[data])
    if len(res)>len(op):
        op = res

print(op)







The file fizzbuzz.py contains:
def fizzbuzz(start,end):
    for i in range(start,end+1):
        if i%3==0 and i%5==0:
            print("FizzBuzz")
        elif i%3==0:
            print("Fizz")
        elif i%5==0:
            print("Buzz")
        else:
            print(i)


if __name__ == '__main__':
    fizzbuzz(1,20)
The file frameGenerator.py contains:
def frameGenerator(n):
    res = []
    for i in range(1, n + 1):
        s = []
        for j in range(1, n + 1):
            if (i == 1 or i == n or j == 1 or j == n):
                #print("*",end="")
                s.append("*")
            else:
                #print(" ", end="")
                s.append(" ")

 #      print("".join(s))
        res.append("".join(s))
    return res

print(frameGenerator(8))
The file frequencyofMaximumValue.py contains:
from collections import Counter
#a = [1,3,2,2,3]
#a = [5,4,5,3,2]
#a = [2,2,2]
a = [2,1,2]

#q = [1,2,3,4,5]
#q = [1,2,3]
q = [1,2,3]
res = []
print(len(a))
#occurrencesInSubarraysSumedh(a,m)
for i in range(len(q)):
    most_common, num_most_common = Counter(a[q[i]-1:]).most_common(1)[0]
    res.append(num_most_common)

print(res)




The file Frog_Hopping.py contains:
#Link - https://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/

def minJumps(arr, n):
    jumps = [0 for i in range(n)]
    for i in range(n - 2, -1, -1):
        if (arr[i] == 0):
            jumps[i] = float('inf')
        elif (arr[i] >= n - i - 1):
            jumps[i] = 1
        else:
            min = float('inf')
            for j in range(i + 1, n):
                if (j <= arr[i] + i):
                    if (min > jumps[j]):
                        min = jumps[j]
            if (min != float('inf')):
                jumps[i] = min + 1
            else:
                jumps[i] = min
    return jumps[0]

if __name__ == '__main__':
    print(minJumps([2,1,4,3,2,5,1,6],8))
    print(minJumps([4,3,2,6,8,3,1,9,6,2],10))
The file GameEvents.py contains:
import re


def getEventsOrder(team1, team2, events1, events2):
    # Write your code here
    football = list()
    football.append({"team": team1, "event": events1})
    football.append({"team": team2, "event": events2})

    game_details_list = list()
    original_event = list()
    event_priority = ['G', 'Y', 'R', 'S']

    for f in football:
        for event in f["event"]:
            original_event.append(f["team"] + " " + event)

            # split events string to get details
            pattern = re.compile("([a-zA-Z\s]*)(\d+)[+]?(\d*).([G,Y,R,S])([a-zA-Z\s]*)")
            split_event = pattern.search(event)

            # create a list of format ["team name", "player name", "time", "extra time", "event", "second player name"]
            record = list()
            record.append(f["team"])  # team name
            if split_event:
                record.append(split_event.group(1).strip())  # player name
                record.append(int(split_event.group(2).strip()))  # time
                record.append(
                    int(split_event.group(3).strip()) if len(split_event.group(3).strip()) > 0 else 0)  # extra time
                record.append(event_priority.index(split_event.group(4).strip()))  # event
                record.append(split_event.group(5).strip())  # second player
            game_details_list.append(record)

    # sorting the list to return index position of the sorted list
    new_num_index_sorted = (sorted(range(len(game_details_list)),
                                   key=lambda k: (
                                       game_details_list[k][2],  # time
                                       game_details_list[k][3],  # extra time
                                       game_details_list[k][4],  # event
                                       game_details_list[k][0],  # team name
                                       game_details_list[k][1],  # player name
                                       game_details_list[k][5])))

    # based on the index position, fetching result from original event list and appending in answer
    answer = list()
    for i in new_num_index_sorted:
        answer.append(original_event[i])
    return answer


print(getEventsOrder("ABC","CBA",["Mo Sa 45+2 Y","A 13 G"],["D 23 S F","Z 46 G"]))
print(getEventsOrder("nolh","nzrdrrc",["inmuucz jzbkica 70 Y","ton wfnt 10 S inmuucz jzbkica","ecya kqvqy 20 S fkfk fuiyb senmofw"],["mysior pqfcz bxlnpn 49 G","mysior pqfcz bxlnpn 18 G","enc otagavd oevfg 68 Y"]))

The file Gateway_Throttling.py contains:

def droppedRequest(RequestTime):
    D = {}
    drop_count = 0
    for i in RequestTime:
        if i in D:
            D[i] += 1
        else:
            D[i] = 1
        drop_count = 0
        time = [i for i in D]
        time = sorted(time)
        for i in time:
            drop_count += max(D[i]-3,0)
            drop_count += max(sum([D[i] for i in range(max(min(time),i-9),i+1) if i in D])-20,0)
            drop_count += max(sum([D[i] for i in range(max(min(time),i-59),i+1) if i in D])-60,0)
    return drop_count

def droppedRequests(requestTime):
    freq = dict()
    for r in requestTime:
        if r in freq.keys():
            freq[r] = freq[r] + 1
        else:
            freq[r] = 1
    of = sorted(freq.items(), key=lambda x: x[0])
    print(of)
    dropped = 0
    of2 = dict()
    for k, v in of:
        if v > 3:
            dropped = dropped + v - 3
            of2[k] = 3
        else:
            of2[k] = v
    #print("-single second -")
    x1 = dropped
    #print(dropped)
    #rint(of2)

    dropped = 0  ######################

    # run 10 seconds and make of3
    of3 = dict()
    for k in of2.keys():
        start = k
        ten_end = k + 9
        ten_second = 0
        for k2 in of2.keys():
            if start <= k2 <= ten_end:
                ten_second = ten_second + of2[k2]
                if ten_second > 20:
                    x = of2[k2] - (ten_second - 20)
                    if x > 0:
                        of3[k2] = x
                    else:
                        of3[k2] = 0
                else:
                    of3[k2] = of2[k2]
            if k2 > ten_second:
                break
        if ten_second > 20:
            dropped = dropped + ten_second - 20
    y1 = dropped
    #print(of3)

    dropped = 0  ######################

    for k in of3.keys():
        start = k
        minute_end = k + 59
        one_minute = 0
        for k3 in of3.keys():
            if start <= k3 <= minute_end:
                one_minute = one_minute + of3[k3]
            if k3 > minute_end:
                break
        if one_minute > 60:
            dropped = dropped + one_minute - 60
    z1 = dropped
    #print(x1)
    #print(y1)
    #print(z1)
    #print(x1 + y1)
    ans = 0


    if x1 > 0:
        ans += x1
    if y1 > 0:
        ans += x1 + y1
    if z1 > 0:
        ans += z1 + y1+ x1

    print(ans)

    return ans

class Graph:

    # init function to declare class variables
    def __init__(self, V):
        self.V = V
        self.adj = [[] for i in range(V)]

    def DFSUtil(self, temp, v, visited):
        # Mark the current vertex as visited
        visited[v] = True

        #print(v)

        # Store the vertex to list
        temp.append(v)

        # Repeat for all vertices adjacent
        # to this vertex v
        for i in self.adj[v]:
            if visited[i] == False:
                # Update the list
                temp = self.DFSUtil(temp, i, visited)

        return temp

    # method to add an undirected edge
    def addEdge(self, v, w):
        self.adj[v].append(w)
        self.adj[w].append(v)

    # Method to retrieve connected components
    # in an undirected graph
    def connectedComponents(self):
        visited = []
        cc = []
        for i in range(self.V):
            visited.append(False)
        for v in range(self.V):
            if visited[v] == False:
                temp = []
                cc.append(self.DFSUtil(temp, v, visited))
        return cc

    # Driver Code

#def totalNoEdges(arr, comp_from, comp_to):

def totalEdges(cc , comp_from, comp_to):
    if len(cc) < 2:
        return 0
    j = 0
    edges = 0
    while j < len(comp_from):
        if comp_from[j] in cc and comp_to[j] in cc:
            edges += 1
        j += 1

    return edges

#print(totalEdges([0,1,2],[0,0,2],[1,2,1]))


    # Create a graph given in the above diagram
    # 5 vertices numbered from 0 to 4
def minOperations(comp_nodes, comp_from, comp_to):
    g = Graph(comp_nodes);
    i =0
    comp_from = [x - 1 for x in comp_from]
    comp_to = [x - 1 for x in comp_to]
    while i < len(comp_from):
        g.addEdge(comp_from[i], comp_to[i])
        i +=1

    #g.addEdge(0, 1)
    #g.addEdge(0, 2)
    #g.addEdge(2, 1)
    cc = g.connectedComponents()
    #print("Following are connected components")
    #print(cc)
    r = []
    i = 1
    for eachCC in cc:
        r.append(totalEdges(eachCC,comp_from,comp_to)- (i-1))
        i += 1
    if sum(r) > len(cc) -1:
        return len(cc) -1
    else:
        return -1

print(minOperations(4, [1, 1, 3], [2, 3, 2]))
#RequestTime = [1,1,1,1,2,2,2,3,3,3,4,4,4,11,11,11,6,6,6,5,5,5]
RequestTime = [1,1,1,1,2]
drop_count = droppedRequest(RequestTime)
#print(drop_count)


droppedRequests(RequestTime)


The file gau_Trend.py contains:
import itertools


def solution(A, B, C, D):
    result = {}
    perms = itertools.permutations([A, B, C, D])
    for p in perms:
        if ((p[0] == 2 and p[1] <= 3) or p[0] <= 1) and p[2] <= 5:
            temp = str(p[0]) + str(p[1]) + str(p[2]) + str(p[3])
            result[int(temp)] = temp

    if result == {}:
        return "NOT POSSIBLE"

    m = result[max(result)]

    return m[:2] + ":" + m[2:]


if __name__ == '__main__':
    print(solution(2,4,0,0))
    print(solution(3, 0, 7, 0))
The file General.py contains:
def findFirst1(arr,tatget):
    def helper(start,end,target):
        mid = (start+end)//2
        if end>=start:
            if arr[mid]==target and arr[mid-1]!=target:
                return mid
            elif arr[mid]>=target:
                return helper(start,mid-1,tatget)
            elif arr[mid]<tatget:
                return helper(mid+1,end,tatget)
        else:
            return -1
    print(helper(0,len(arr),tatget))


def findFisrtANdLast(arr,target):
    def helper(lo,hi,left):
        found = -1
        while lo <= hi:
            mid = lo + (hi - lo) // 2
            if target > arr[mid]:
                lo = mid + 1
            elif target < arr[mid]:
                hi = mid - 1
            else:
                if left:
                    found = mid
                    hi = mid - 1
                else:
                    found=mid
                    lo = mid+1

        return found

    l = helper(0,len(arr)-1,True)
    r = helper(0,len(arr)-1,False)

    print(l,r)

class Node:
    def __init__(self,x):
        self.val = x
        self.next = None

class Node1:
    def __init__(self,root):
        self.left = None
        self.val = root
        self.right = None

def inetraverse(root):
    def helper(r, res):
        if r:
            helper(r.left,res)
            res.append(r.val)
            helper(r.right,res)


    res =[]
    helper(root,res)
    print(res)

def bfs(root):
    q= []
    q.append(root)
    res =[]
    while q:
        data = q.pop(0)
        res.append(data.val)
        if data.left:
            q.append(data.left)
        if data.right:
            q.append(data.right)

    print(res)

def over1(a,b,c):
    return a+b+c

def over1(a,b,c,d):
    return a+b+c+d

class LinkedList:
    def __init__(self):
        self.head = None

    def push(self,x):
        new_node = Node(x)
        if not self.head:
            self.head = new_node

        last = self.head
        while last.next:
            last= last.next

        last.next = new_node
        new_node.next = None

    def start(self,x):
        new_node = Node(x)
        new_node.next = self.head
        self.head = new_node

    def printAll(self):
        temp = self.head
        print("Printing ..... ")
        while temp:
            print(temp.val)
            temp = temp.next

    def delete(self,x):
        prev = None
        curr = self.head

        while curr.val!=x:
            nxt = curr.next
            prev = curr
            curr = nxt

        prev.next = curr.next

    def reverseLL(self):
        prev = None
        curr = self.head

        while curr:
            nxt = curr.next
            curr.next = prev
            prev = curr
            curr = nxt

        self.head = prev


    def middle(self):
        slow = self.head
        fast = self.head

        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next

        print("Middle Element: -",slow.val)


def Sum35():
    t = int(input().strip())
    for a0 in range(t):
        n = int(input().strip())
        i = 1
        sum = 0
        while (i < n):
            mof3 = 3 * i
            mof5 = 5 * i
            if mof3 < n:
                sum = sum + mof3
            if mof5 < n and mof5 % 3 != 0:
                sum = sum + mof5
            i = i + 1
        print(sum)

if __name__ == '__main__':
    #findFirst1([0, 0, 0, 0, 0, 0, 1, 1, 1, 1],1)
    #findFisrtANdLast([5,7,7,8,8,10],8)
    #findFisrtANdLast([5, 7, 7, 8, 8, 10,10,10,10,10,11,13,15], 10)
    #findFisrtANdLast([5, 7, 7, 8, 8, 10, 10, 10, 10, 11, 13, 15], 16)
    #findFisrtANdLast([5,7,7,8,8,10], 6)
    '''
    root = Node1(1)
    root.left = Node1(2)
    root.right = Node1(3)
    root.left.left = Node1(4)
    root.left.right = Node1(5)
    root.right.left = Node1(6)
    root.right.right = Node1(7)
    root.right.left.left = Node1(8)
    inetraverse(root)
    #bfs(root)'''
    '''
    l = LinkedList()
    l.push(2)
    l.push(3)
    l.push(4)
    l.push(1)
    l.start(5)
    l.start(6)
    l.delete(2)
    l.printAll()
    l.reverseLL()
    l.printAll()
    l.middle()
    
    print(over1(1,3,3))
    print(over1(1, 3, 3,4))
    '''

    Sum35()


The file getIdealNumber.py contains:
'''
3^x5^y is ideal number
'''
l =1
r  =10
def idealCount(l,r):
    count = 0
    if l ==1:
        l+=1
        count+=1
    for i in range(l,r+1):
        num = i

        while num%3==0:
            num//=3

        while num % 5 == 0:
            num //= 5

        if num ==1:
            count+=1
    return count
print(idealCount(1,10))
The file gettingTicketsToFan.py contains:
'''
Sample Input 1
5
2
1 1 1 40 60
2 1 4 50
3
3 3
3 2
4 3

Sample Input 2
5
2
1 1 1 40
2 1 4 50
1
3 3

Sample Input 3
6
3
1 1 2 100 100 400
2 2 4 100 200 500
3 3 1 100 200 500
3
3 3
3 3
3 3

Sample Input 4
3
2
1 2 2 100 200 400
2 1 4 40 100 200
1
2 2

Sample Input 5
4
2
1 1 2 100 200 400
2 2 4 100 200 400
2
3 3
3 3

Sample Input 6
2
1
1 2 2 60 15 90
1
2 2

Sample Input 7
2
1
1 2 2 60 15 90
1
2 2

Sample Input 8
3
2
2 2 2 400 100 200
1 4 4 40 100 200
1
2 2


Sample Input 9
7
3
2 4 4 100
1 2 2 100
3 1 3 100
4
3 3
3 3
3 3
3 3

'''
import math
def manhattan_distance(x1, y1, x2, y2):
    return abs(x1 - x2) + abs(y1 - y2)

sizeOfWorld = int(input())
numberOfEvents = int(input())
events = {}
buyer = []
ticket = {}
op = []
dist = {}
eventId = 0

for i in range(0, numberOfEvents):
    eventLine = input()
    eventLine = list(map(int, eventLine.split()))
    events[eventLine[0]] = [eventLine[1], eventLine[2]]
    ticket[eventLine[0]] = sorted(eventLine[3:])

numberOfBuyers = int(input())
for i in range(0, numberOfBuyers):
    buyerLine = input()
    buyerLine = list(map(int, buyerLine.split()))
    buyer.append(buyerLine)
print("Events:-",events,"Tickets: -",ticket,"Buyer: -",buyer)
#print("-----------------------------------------------------")
for i in range(int(numberOfBuyers)):
    minDist = math.inf
    coOrdinate = buyer[i]
    for k, v in events.items():
        preevent = eventId
        betwDist = manhattan_distance(coOrdinate[0], coOrdinate[1], v[0], v[1])
        #print("Dist",betwDist,v,coOrdinate,minDist)
        if betwDist < minDist and len(ticket[k]) != 0:
            minDist = betwDist
            eventId = k
        elif betwDist == minDist and len(ticket[k]) != 0:
            #print("--------",k,eventId)
            if ticket[k][0]<ticket[eventId][0]:
                eventId = k
            elif ticket[k][0]==ticket[eventId][0] and k<eventId:
                eventId = k

            #print(k, eventId,"--------")

    #print("-------------------------------")
    #print(ticket,eventId)
    if eventId in ticket and ticket[eventId]:
        tickets = ticket[eventId].pop(0)
    else:
        eventId = -1
        tickets = 0
    print(eventId, tickets)

'''
# The following method get the manhatten distance betwen two points (x1,y1) and (x2,y2)
import math
def manhattan_distance(x1, y1, x2, y2):
    return abs(x1 - x2) + abs(y1 - y2)


# Enter your code here. Read input from STDIN. Print output to STDOUT
sizeOfWorld = int(input())
numberOfEvents = int(input())
events = {}
buyer = []
ticket ={}
op = []
dist ={}
eventId = 0

for i in range(0,numberOfEvents) :
    eventLine = input()    
    eventLine = list(map(int,eventLine.split()))
    events[i] = [eventLine[0],eventLine[1]]
    ticket[i] = sorted(eventLine[3:])

    
numberOfBuyers = int(input())
for i in range(0,numberOfBuyers) :
    buyerLine = input()
    buyerLine = list(map(int,buyerLine.split()))
    buyer.append(buyerLine)


#print("Events:-",events,"Tickets: -",ticket,"Buyer: -",buyer) 

for i in range(int(numberOfBuyers)):
    minDist  = math.inf
    coOrdinate = buyer[i]
    for k,v in events.items():
        preevent = eventId
        betwDist = manhattan_distance(coOrdinate[0],coOrdinate[1],v[0],v[1])
        if betwDist<=minDist and len(ticket[k])!=0:
            minDist = betwDist
            eventId = k
            minprice = ticket[eventId][0]
        elif betwDist == minDist and len(ticket[k])!=0:
            if minprice > ticket[k][0]:
                eventId = preevent
                minprice = ticket[k][0]
    #print(ticket,eventId)    
    if eventId in ticket and ticket[eventId]:
            tickets = ticket[eventId].pop(0)
        #print(tickets)
    else:
        eventId = -2
        tickets = 0
    print(eventId+1,tickets)
    
# The solution to the first sample above would be to output the following to console:
# (Obviously, your solution will need to figure out the output and not just hard code it)
'''





The file Get_Requests_For_GIF_Images.py contains:
def sumedh_sol(filepath):
    s  = set()
    with open(filepath) as fp:
       for cnt, line in enumerate(fp):
           l = line.split()
           if "200" in l[-2] or "200" in l[-1]  and "gif" in l[-4].lower() and l[5].split('"')[1]=='GET':
                   temp = l[-4].split('/')
                   s.add(temp[-1])
                   #print(s)
    fp.close()
    f = open("gifs_hosts_access_log_00.txt", "w")
    s = list(s)
    for i in range(len((s))-1):
        print(s[i])
        f.write((s[i])+"\n")
    print(s[len(s)-1])
    f.write(s[len(s)-1])
    f.close()


def sakshat_sol(filepath):
    res = set()
    with open(filepath) as fp:
        for s in fp:
            s = s.split('"')
            # print(s)
            c = s[-1].strip().split(' ')
            if '200' not in c:
                continue
            b = s[1].strip().split('/')
            # print(b)
            flag = False
            for i in b:
                if 'GET' in i:
                    flag = not flag
                if 'gif' in i or 'GIF' in i:
                    temp = i.split(' ')[0]
                    if flag:
                        res.add(temp)
                    break
    print(res)

if __name__ == '__main__':
    filepath = 'hosts_access_log_00.txt'
    sumedh_sol(filepath)
    #sakshat_sol(filepath)

The file gifs_hosts_access_log_00.txt contains:

livevideo.GIF
KSC-logosmall.gif
NASA-logosmall.gif
count.gif
The file gluMandar.py contains:
'''

import collections
import datetime as d



data = [{"game_id":"Racing","user_id":"ABC123","amt":5,"date":"2020-01-01"},
        {"game_id":"Racing","user_id":"ABC123","amt":1,"date":"2020-01-04"},
        {"game_id":"Racing","user_id":"CDE123","amt":1,"date":"2020-01-04"},
        {"game_id":"DH","user_id":"CDE123","amt":100,"date":"2020-01-03"},
        {"game_id":"DH","user_id":"CDE456","amt":10,"date":"2020-01-02"},
        {"game_id":"DH","user_id":"CDE789","amt":5,"date":"2020-01-02"},
        {"game_id":"DH","user_id":"CDE456","amt":1,"date":"2020-01-03"},
        {"game_id":"DH","user_id":"CDE456","amt":1,"date":"2020-01-03"}]

no_of_players = collections.defaultdict(set)
cumulative_sum = collections.defaultdict(lambda: [0] * 4)
game_id = []

for i in range(len(data)):
    no_of_players[data[i]['game_id']].add(data[i]['user_id'])
#print(no_of_players)

dates = ["2020-01-01","2020-01-02","2020-01-03","2020-01-04"]
end_date = max(data, key=lambda r: r['date'])
print(end_date['date'])
end_date = d.datetime.strptime(end_date['date'], "%Y-%m-%d")
print(end_date)

for k,v in no_of_players.items():
    game_id.append(k)

for i in range(len(dates)):
    for j in range(len(data)):
        if data[j]['date'] == dates[i]:
            cumulative_sum[data[j]['game_id']][i] +=data[j]['amt']
#print(len(cumulative_sum))
for k,v in cumulative_sum.items():
    temp =v
    for j in range(1,len(temp)):
        temp[j] = temp[j-1]+temp[j]
    cumulative_sum[k] = temp
print(cumulative_sum)
print("Game    Age      Cum_rev     Total_unique_payers_per_game")
for k,v in cumulative_sum.items():
    for j in range(len(v)):
        print(k,"\t",j,"\t",v[j],"\t",len(no_of_players[k]))

'''


import collections
import datetime as d
data = [{"game_id":"Racing","user_id":"ABC123","amt":5,"date":"2020-01-01"},
        {"game_id":"Racing","user_id":"ABC123","amt":1,"date":"2020-01-04"},
        {"game_id":"Racing","user_id":"CDE123","amt":1,"date":"2020-01-04"},
        {"game_id":"DH","user_id":"CDE123","amt":100,"date":"2020-01-03"},
        {"game_id":"DH","user_id":"CDE456","amt":10,"date":"2020-01-02"},
        {"game_id":"DH","user_id":"CDE789","amt":5,"date":"2020-01-02"},
        {"game_id":"DH","user_id":"CDE456","amt":1,"date":"2020-01-03"},
        {"game_id":"DH","user_id":"CDE456","amt":1,"date":"2020-01-03"}]

class Cumulative:

    def __init__(self,data):
        self.data = data
        self.finalResult = list()

    def getRow(self,game, Age, Cum_rev, unique_players=0):
        d = {
            'game': game,
            'Age': Age,
            'Cum_Rev': Cum_rev,
            'Unique_Players': unique_players
        }
        return d

    def getAmt(self, game, date):
        amt = 0
        for i in self.data:
            if i['game_id'] == game and i['date'] == date:
                amt += i['amt']
        return amt

    def getUniquePlayers(self):
        no_of_players = collections.defaultdict(set)
        for i in self.data:
            no_of_players[i['game_id']].add(i['user_id'])
        return no_of_players

    def getCumulative(self):
        numberOfPlayers = self.getUniquePlayers()


        game = set()
        for i in data:
            game.add(i['game_id'])

        end_date = max(data, key=lambda r: r['date'])
        end_date = d.datetime.strptime(end_date['date'], "%Y-%m-%d")


        for g in game:
            start_date = d.datetime.strptime('2020-01-01', "%Y-%m-%d")
            age = 0
            cum_amt = 0
            while start_date <= end_date:
                amt = self.getAmt(game=g, date=start_date.strftime('%Y-%m-%d'))
                cum_amt += amt
                l = self.getRow(game=g, Age=age, Cum_rev=cum_amt, unique_players= len(numberOfPlayers[g]))
                age += 1
                self.finalResult.append(l)
                start_date += d.timedelta(days=1)
        return self.finalResult
c = Cumulative(data)
result = c.getCumulative()
print("Game    Age      Cum_rev     Total_unique_payers_per_game")
for ele in result:
    print(ele['game'],'\t',ele['Age'],'\t',ele['Cum_Rev'],'\t',ele['Unique_Players'])





The file GoldmanSachs_2D_LIst.py contains:
def sum_2d(arr,k):
    sum = 0
    print("\nFinding Sum of each row:\n")
    dict={}
    for i in range(len(arr)):
        for j in range(len(arr)):
            # Add the element
            sum += arr[i][j]
        dict[i]=sum
        sum = 0
        #print("Sum of the row", i, "=", dict)
    sorted_dict = sorted(dict.items(), key=lambda kv: kv[1],reverse=True)
    #print("Sum of the row", i, "=", sorted_dict)
    print(arr[sorted_dict[k - 1][0]])
    return sorted_dict[k - 1][0]

if __name__ == '__main__':
    a = [[80, 96, 81,77], [78, 71, 93,75],[71,98,70,95],[80,96,89,77]]
    b = [[74,92,75,73],[74,92,75,73],[73,88,99,80]]
    c =[[74,92,75,73],[74,92,75,73],[74,92,75,73]]
    k = 3
    ans = sum_2d(c,k)
    print(ans)
    # print(dict[k-1][0])
The file Goldman_Shares Purchase.py contains:
'''
def Solution(word):
    soln_set = []
    # i points to the first char and j to the last char.
    i, lenofWord = 0, len(word)
    count = 0
    for i in range(0, lenofWord-2):
        j = lenofWord
        # This would break once a word in that sequence is found which doesnt have ABC, starting from the end towards allows us to break sooner.
        while j > i:
            if checkABC(word[i:j]):
                count += 1
                j -= 1
            else:
                break

    print(count)
'''

def  Solution2(word):
    dict = {'A':[],'B':[],'C':[]}
    maxpos = []
    for i, ltr in enumerate(word):
        if ltr == 'A':
            dict['A'].append(i)
            maxpos.append(i)
        if ltr == 'B':
            dict['B'].append(i)
            maxpos.append(i)
        if ltr == 'C':
            dict['C'].append(i)
            maxpos.append(i)
    print(dict)
    print(max(maxpos))

'''
def findMin(dict):
    for i in range(0,2):
        #dict[0]







def checkABC(partWord):
    if 'A' in partWord and 'B' in partWord and 'C' in partWord:
        return True
    else:
        return False
'''

'''
Solution 2

def analyzeInvestments(s):
    count = 0
    for i in range(len(s)):
        a = False
        b = False
        c = False
        for j in range(i+1, len(s) + 1):
            if a or 'A' in s[i:j]:
                a = True
            if b or 'B' in s[i:j]:
                b = True
            if c or 'C' in s[i:j]:
                c = True
            if a and b and c:
                count = count + len(s) - j + 1
                break
    print(count)
'''
test = ["ABC", "ABCCBA", "PQACBA", "ABBCZBAC"]
Solution2("ABCACBA")
#analyzeInvestments("ABBCZBAC")
The file goodSegment.py contains:
import  math
def goodSegment(badNumber, lower, upper):
    badNumber = sorted(badNumber)
    temp = []
    #print("Sorted List",badNumber)
    for i in range(len(badNumber)):
        if lower<=badNumber[i]<=upper:
            temp.append(badNumber[i])
    #maxdiff = -math.inf
    maxdiff = temp[0]-1 - lower
    if upper - temp[-1]>maxdiff:
        maxdiff = upper - temp[-1]
    #print("Res before for",maxdiff)

    for i in range(1,len(temp)):
        if maxdiff< (temp[i] - temp[i - 1])-1:
            maxdiff = (temp[i] - temp[i - 1])-1
        #print(maxdiff)

    #print(maxdiff)
    return  maxdiff

if __name__ == '__main__':
    print(goodSegment([37,7,22,15,49,60],3,48))
    print(goodSegment([5,4,2,15], 1, 10))
    print(goodSegment([8,6,20,12], 1, 30))
    print(goodSegment([2], 1, 3))
The file goodTuple.py contains:
#a = [1,1,1,2,1,3,4]
count =0
a = [1,1,2,1,2,1,1]
#a= []
if len(a)==0:
    print("Not a good tuple")
for i in range(len(a)-2):
    s = set()
    print(a[i],a[i+1],a[i+2])
    s.add(a[i])
    s.add(a[i+1])
    s.add(a[i+2])
    if len(s)==2:
        count+=1
        print("Good Tuple")
    else:
        print("Not a good tuple")
print("Count :- ",count)
The file Google_Minimum_Domino_Rotations_For_Equal_Row.py contains:
# Leetcode - 1007 - https://leetcode.com/problems/minimum-domino-rotations-for-equal-row/
# Google - https://leetcode.com/discuss/interview-question/352460/Google-Online-Assessment-Questions

import  collections
def minDominoRotations(A, B):
    """
    :type A: List[int]
    :type B: List[int]
    :rtype: int
    """
    n = len(A)
    d = collections.defaultdict(int)
    maxVal = float('-inf')
    num = 0  # num: highest frequency occurred
    # only count the num occurred most frequently
    for i in range(n):
        d[A[i]] += 1
        d[B[i]] += 1
        if d[A[i]] > maxVal:
            maxVal = d[A[i]]
            num = A[i]
        if d[B[i]] > maxVal:
            maxVal = d[B[i]]
            num = B[i]
    # if the frequency of the num < n, there's no reason it can be achieved the same number in whole row
    if maxVal < n:
        return -1

    cntRotate = 0  # count one of the sides to achieve all numbers are same in B
    skipRotate = 0  # when two sides are same as the num occurred most frequently
    for i in range(n):
        if A[i] != num and B[i] != num:  # non of sides are same as the num
            return -1
        if A[i] == num and B[i] == num:  # two sides are same as the num, so do not need to rotate
            skipRotate += 1
            continue
        if A[i] == num:  # if A's side is same as the num, rotate it the B side
            cntRotate += 1
    # count the minimum rotation:
    # min(all the numbers in B are same after rotation, all the numbers in A are same after rotation)
    return min(cntRotate, n - skipRotate - cntRotate)


print(minDominoRotations([1,2,3,6,3,2],[2,1,2,2,2,4]))
print(minDominoRotations([1,2,1,2],[2,6,1,2]))
The file Google_Watering_Flowers_2.0.py contains:
# Link Ref - https://leetcode.com/discuss/interview-question/394347/


class Worker:
    def __init__(self, capacity, ptr=0, water=0):
        self.capacity = capacity
        self.ptr = ptr
        self.water = water
        self.n_refill = 0

    def refill(self):
        self.water = self.capacity
        self.n_refill += 1

    def water_plant(self, plant):
        if plant > self.water:
            self.refill()
            self.water_plant(plant)
        else:
            self.water -= plant


def solution(plants, capacity1, capacity2):
    result = 0
    n_plants = len(plants)
    # current tank state of each worker
    worker_left, worker_right = Worker(capacity1, 0), Worker(capacity2, n_plants - 1)
    # watering process
    while worker_left.ptr <= worker_right.ptr:
        # concurrent watering
        if worker_left.ptr < worker_right.ptr:
            # logic for worker_left
            plant_left = plants[worker_left.ptr]
            worker_left.water_plant(plant_left)
            # logic for worker_right
            plant_right = plants[worker_right.ptr]
            worker_right.water_plant(plant_right)
            # move together
            worker_left.ptr += 1
            worker_right.ptr -= 1
        # joint watering
        else:
            plant = plants[worker_left.ptr]
            # not enough water
            if worker_left.water + worker_right.water < plant:
                result += 1
            break
    return worker_left.n_refill + worker_right.n_refill + result


if __name__ == '__main__':
    plants = [2, 4, 5, 1, 2]
    print(solution(plants, 5, 7))  # should return 3


The file gridOfLife.py contains:
def ans(grid,k,rules):
    corners = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[-1,-1],[1,-1],[-1,1]]
    lc = [[0]*len(grid[0])]*len(grid)
    for l in range(k):
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                count = 0
                for f in range(8):
                    r = i
                    c = j
                    r += corners[f][0]
                    c += corners[f][1]
                    if r >= 0 and r < len(grid) and c >= 0 and c<len(grid[0]) and grid[r][c] == 1:
                        count += 1
                lc[i][j] = count
        #print("lc---",lc)
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if rules[lc[i][j]] == 'alive':
                    #print(rules[lc[i][j]])
                    grid[i][j] = 1
                else:
                    grid[i][j] = 0
        print("Grid",k,grid)
    return grid


def calcualte_live_cell(grid,k,rules):
    X = [-1,-1,-1,0,0,1,1,1]
    Y = [-1,0,1,-1,1,-1,0,1]

    alive= []
    for i in range(len(grid)):
        temp =[]
        for j in range(len(grid[0])):
            num_alive = 0
            for k in range(8):
                x= i+X[k]
                y = j+Y[k]

                if x>=0 and x<len(grid) and y>=0 and y< len(grid[0]) and grid[x][y]:
                    num_alive+=1
            temp.append(num_alive)

        alive.append(temp)

    for i in range(len(alive)):
        for j in range(len(alive[0])):
            if rules[alive[i][j]]:
                grid[i][j]=1
            else:
                grid[i][j] = 0

    #print(alive)
    print(grid)



#grid = [[0,1,0,0],[0,0,0,0]]
#grid = [[0,1,0,0],[0,0,0,0]]
grid = [[0,1,0,0],[0,0,0,0]]
k = 1
rules = ['dead','alive','dead','dead','dead','dead','dead','dead','dead']
#rules = ['dead','alive','dead','dead','dead','alive','dead','dead','dead']
print(ans(grid,k,rules))

calcualte_live_cell(grid,k,rules)
The file hosts_access_log_00.txt contains:
unicomp6.unicomp.net -- [01/Jul/1995:00:00:06 -0400] "GET /shuttle/countdown/ HTTP/1.0" 200 3985
burger.letters.com - - [01/Jul/1995:00:00:11 -0400] "GET /shuttle/countdown/liftoff.html HTTP/1.0" 304 0 
burger.letters.com - - [01/Jul/1995:00:00:12 -0400] "GET /images/NASA-logosmall.gif HTTP/1.0" 304 O 
burger.letters.com - - [01/Jul/1995:00:00:12 -0400] "GET /shuttle/countdown/video/livevideo.GIF HTTP/1.0" 200 0 
d104.aa.net - - [01/Jul/1995:00:00:13 -0400] "GET /shuttle/countdown/ HTTP/1.0" 200 3985 
unicomp6.unicomp.net - - [01/Jul/1995:00:00:14 -0400] "GET /shuttle/countdown/count.gif HTTP/1.0" 200 40310 
unicomp6.unicomp.net - - [01/Jul/1995:00:00:14 -0400] "GET /images/NASA-logosmall.gif HTTP/1.0" 200 786 
unicomp6.unicomp.net - - [01/Jul/1995:00:00:14 -0400] "GET /images/KSC-logosmall.gif HTTP/1.0" 200 1204 
d104.aa.net - - [01/Jul/1995:00:00:15 -0400] "GET /shuttle/countdown/count.gif HTTP/1.0" 200 40310 
d104.aa.net - - [01/Jul/1995:00:00:15 -0400] "GET /images/NASA-logosmall.gif HTTP/1.0" 200 786
The file IMC.py contains:
'''
theDict = {chr(y): y - 64 for y in range(65, 91)}
print(theDict)
a = "1B 2C, 2D 4D"
x = a.split(',')
newlist = []
for i in (0, len(x) - 1):
    y = x[i].split()
    for i in range(0, len(y)):
        z = list(y[i])
        z[0] = int(z[0])
        z[1] = theDict[z[1]]
        z = ','.join(map(str, z))
        newlist.append(z)
for i in range(len(newlist)):
    newlist[i] = eval(newlist[i])

print(newlist)
for i in range(0, len(newlist), 2):
    temp = newlist[i] + newlist[i + 1]
    print(temp)
    maxnum = max(temp)
    minnum = min(temp)
    print(maxnum, minnum)
    '''


import string
import copy
def artifact(N, artifacts, search):
    # 4 , "1B 2C, 2D 4D" , "2B 2D 3D 4D 4A"

    mapOfArtifact = {}
    artifactsString = artifacts.split(",")

    for idx, artifact in enumerate(artifactsString):

        mapOfArtifact[idx] = findAllpositions(artifact)

    tempMap = copy.deepcopy(mapOfArtifact)
    searchPos = search.split()
    countOfPartial = 0
    countOfFull = 0

    for each in searchPos:
        for artifact in mapOfArtifact:
            if each in mapOfArtifact[artifact]:
                mapOfArtifact[artifact].remove(each)
    for idx,element in mapOfArtifact.items():
        if len(element) == 0:
            countOfFull += 1
        elif len(element) < len(tempMap[idx]):
            countOfPartial += 1

    print(countOfFull)
    print(countOfPartial)

def findAllpositions(s):
    a = dict()
    n = 4
    j = 65
    for i in range(n):
        a[chr(j)] = i + 1
        j += 1

    t = s.split()[0]
    b = s.split()[1]
    matrix = [[0] * n]*n
    bDict = dict()
    k = 65
    for i in range(n):
        bDict[i + 1] = chr(k)
        k += 1

    temp = []

    for i in range(int(t[0]), int(b[0]) + 1):
        for j in range(a[t[1]] -1, a[b[1]]):
            temp.append(str(i) + str(bDict[j+1]))

    return temp

findAllpositions("2D 4D")
#artifact(4, "1B 2C,2D 4D" , "2B 2D 3D 4D 4A")
artifact(4, "1A 1B,2C 2C" , "1B")
The file implementationOfRequest.py contains:
import requests
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.action_chains import ActionChains

r = requests.get('https://sjogleka.github.io/')
print(r.headers)
print(r.status_code)
if r.status_code==200:
    driver = webdriver.Chrome(executable_path="C:\Program Files (x86)\Google\Chrome\chromedriver.exe")
    driver.get("https://sjogleka.github.io/")
    driver.maximize_window()

    WebDriverWait(driver,15).until(EC.presence_of_element_located((By.XPATH,"//a[@href='portfolio-single.html']")))
    mlPage = driver.find_element_by_xpath("//a[@href='portfolio-single.html']")
    action = ActionChains(driver).move_to_element(mlPage)
    mlPage.click()
    #gitML = driver.find_element_by_xpath("//a[@href='https://github.com/sjogleka/Machine-Learning']")
    #driver.implicitly_wait(30)
    #gitML.click()
    driver.__exit__()
The file initial_public_offering.py contains:
def getUnallottedUsers(bids, totalShares):
    price_dict = dict()
    output = []
    for i in bids:
        if i[2] not in price_dict:
            price_dict[i[2]] = [[i[0], i[1], i[3]]]
        else:
            price_dict[i[2]].append([i[0], i[1], i[3]])
    for i in price_dict:
        price_dict[i] = sorted(price_dict[i], key=op.itemgetter(2))
    while totalShares > 0:
        max_price = max(price_dict.keys())
        if len(price_dict[max_price]) == 1:
            print(price_dict)
            print(price_dict[max_price])
            totalShares -= price_dict[max_price][0][1]
            price_dict.pop(max_price)
        else:
            if (totalShares // len(price_dict[max_price])) > 0:
                x = totalShares // len(price_dict[max_price])
                for i in price_dict[max_price]:
                    i[1] -= x
                    totalShares -= x
                y = totalShares % len(price_dict[max_price])
                i = 0
                while y > 0 and i < len(price_dict[max_price]):
                    if price_dict[max_price][i][1] == 0:
                        i += 1
                        continue
                    price_dict[max_price][i][1] -= 1
                    totalShares -= 1
                    i += 1
                    y -= 1
            else:
                y = totalShares % len(price_dict[max_price])
                i = 0
                while y > 0 and i < len(price_dict[max_price]):
                    price_dict[max_price][i][1] -= 1
                    totalShares -= 1
                    i += 1
                    y -= 1
                for j in range(i, len(price_dict[max_price]) - 1):
                    output.append(price_dict[max_price][i][0])

            price_dict.pop(max_price)

    for key in price_dict:
        for i in range(0, len(price_dict[key])):
            output.append(price_dict[key][i][0])

    return output
The file JSON_manipulation.py contains:
import json
import requests
'''
searchFor = input("Search For")
temp = requests.get("https://jsonmock.hackerrank.com/api/movies/search/?Title="+searchFor)
data = temp.json()
total_pages = data['total_pages']
res =[]
for i in range(total_pages):
    data2  = requests.get("https://jsonmock.hackerrank.com/api/movies/search/?Title=" + searchFor+"&page="+str(i)).json()['data']
    for ele in range(len(data2)):
        print(data2[i])
        res.append(data2[i]['Title'])
print(res)
print(sorted(res))
'''

data = json.load(open('read_json.json','r'))

print(data)
source = data['origin_addresses'][0]
destinations = data['destination_addresses']
entries = data['rows'][0]['elements']


#print(source)
#print(destinations,len(destinations))
#print(entries,len(entries))


res= []
for i in range(len(destinations)):
    res.append((destinations[i],entries[i]['distance']['text'],entries[i]['duration']['text']))
print("Source\t\t\t\t Destination\t\t\t\t Distance\t\t\t\t Duration")
for i in range(len(res)):
    temp  = res[i][0].split(',')
    temp = ','.join(temp[:-1])
    #print(temp)
    print(','.join(source.split(',')[:-1]),"\t",temp,"\t\t",res[i][1],"\t\t",res[i][2])


The file kClosestFromOrigin.py contains:
import  math, operator
def distance(x,y):
    return int(math.sqrt(x**2+y**2))

def kClosest(points,k):
    d = {}
    op = []
    for i in range(len(points)):
        x = points[i][0]
        y = points[i][1]

        d[i] = distance(x,y)

    res = sorted(d.items(),key=lambda x:(x[1],x[0]))[:k]
    for i in range(k):
        op.append(points[res[i][0]])

    return op








if __name__ == '__main__':
    #points = [[3, 3], [5, -1], [-2, 4]]
    points = [[1, 3], [-2, 2]]
    #K = 2
    K = 1
    print(kClosest(points,K))
The file kDifference_Twitter_Gaurav.py contains:
def kDifference(nums, k):
    if k < 0: return 0
    numsSet, pairsSet = set(), set()
    for num1 in nums:
        for num2 in [num1 + k, num1 - k]:
            if num2 in numsSet:
                pairsSet.add(tuple(sorted([num1, num2])))
        numsSet.add(num1)
    print(pairsSet)
    return len(pairsSet)

def kDiff(nums,k):
    d = {}
    s = set()
    for i in range(len(nums)):
        d[nums[i]] = [nums[i]+k,nums[i]-k]
    count = 0
    for i in range(len(nums)):
        if d[nums[i]][0] in d.keys():
            temp = tuple(sorted([d[nums[i]][0], nums[i]]))
            if temp not in s:
                s.add(temp)
                count+=1
        if d[nums[i]][1] in d.keys():
            temp = tuple(sorted([d[nums[i]][1], nums[i]]))
            if temp not in s:
                s.add(temp)
                count+=1

    print(count)
    print(d)


# Driver function to test above function
#nums = [1,5,3,4,2]
nums = [1,5,3,4,2]
#nums = [363374326,364147539,61825163,107306571,1281246024,139946991,428047635,491595254,879792181,106926279]
k= 2
print(kDifference(nums, k))
kDiff(nums,k)
The file KMaxSumInTwoArrays.py contains:
import heapq
def kMaxSumCombinations(arr1,arr2,k):
    d= {}
    for i in arr1:
        for j in arr2:
            d[i+j] = (i,j)

    items = sorted(d.keys(),reverse=True)
    #print(items)
    return items[:k]

def kMaxSumCombintion_1(arr1,arr2,k):
    arr1.sort()
    arr2.sort()
    #print(arr1,arr2)
    maxComb = []
    visited = set()
    heapq.heappush(maxComb,(-(arr1[len(arr1)-1]+arr2[len(arr2)-1]),len(arr1)-1,len(arr2)-1))
    #print(maxComb)
    res = []
    visited.add((len(arr1)-1,len(arr2)-1))
    for i in range(k):
        #print(maxComb)
        temp = heapq.heappop(maxComb)
        res.append(-temp[0])
        id1,id2 = temp[1],temp[2]
        if (id1-1,id2) not in visited:
            visited.add((id1-1,id2))
            tempsum1 = arr1[id1 - 1] + arr2[id2]
            heapq.heappush(maxComb, (-tempsum1, id1 - 1, id2))
        if (id1, id2-2) not in visited:
            visited.add((id1, id2-2))
            tempsum2 = arr1[id1] + arr2[id2 - 1]
            heapq.heappush(maxComb, (-tempsum2, id1, id2-1))
    print(res)




if __name__ == '__main__':
    #print(kMaxSumCombinations([3,2],[1,4],2))
    #print(kMaxSumCombinations([4, 2, 5, 1],[8, 0, 3, 5], 3))

    #print(kMaxSumCombintion_1([3, 2], [1, 4], 2))
    print(kMaxSumCombintion_1([4, 2, 5, 1],[8, 0, 3, 5], 3))

The file LeetCode_108_SortedArray_To_BST.py contains:
class TreeNode:
    def __init__(self,x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def sortArrayToBST(self,ar):
        if len(ar)==0:
            return None
        mid = len(ar)//2
        r = TreeNode(ar[mid])
        r.left=self.sortArrayToBST(ar[:mid])
        r.right = self.sortArrayToBST(ar[mid+1:])

        return r

    def inOrder(self,root):
        def helper(root,res):
            if root:
                helper(root.left,res)
                res.append(root.val)
                helper(root.right,res)
            else:
                res.append("null")
        res = []
        helper(root, res)
        return res

    def preOrder(self,root):
        print(root)
        def helper(root,res):
            if root:
                res.append(root.val)
                helper(root.left,res)
                helper(root.right,res)

        res = []
        helper(root, res)
        return res

if __name__ == '__main__':
    s = Solution()
    arr = [-10,-3,0,5,9]
    print(s.inOrder(s.sortArrayToBST(arr)))
    print(s.preOrder(s.sortArrayToBST(arr)))
'''    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.left.left = TreeNode(4)
    root.left.right = TreeNode(5)
    '''
    #print(s.inOrder(root))

The file LeetCode_1130_minimize_parent_cost.py contains:
def mctFromLeafValues(A):
    res, n = 0, len(A)
    stack = [float('inf')]
    for a in A:
        while stack[-1] <= a:
            mid = stack.pop()
            res += mid * min(stack[-1], a)
        stack.append(a)
    while len(stack) > 2:
        res += stack.pop() * stack[-1]
    return res


print(mctFromLeafValues([4,6,2]))
print(mctFromLeafValues([5,3,1]))
print(mctFromLeafValues([2,2,1]))
The file LeetCode_212_Word_Search.py contains:
import copy

def dfs(new_board,r,c,word,idx):
    if idx>= len(word):
        return  True

    if word[idx]!=new_board[r][c]:
        return False

    if r<0 or r>=len(new_board) or c<0 or c>=len(new_board[r]):
        return False
    new_board[r][c] = '-1'

    if dfs(new_board,r+1,c,word,idx+1) or dfs(new_board,r-1,c,word,idx+1) or dfs(new_board,r,c+1,word,idx+1) or dfs(new_board,r,c-1,word,idx+1):
        return True

    '''
    x = [1, -1, 0, 0]
    y = [0, 0, -1, 1]
    for m in range(4):
        new_r = r+x[m]
        new_c = c+y[m]
        if 0 <= new_r < len(new_board) and 0 <= new_c < len(new_board[0]):
            if dfs(new_board,new_r,new_c,word,idx+1) :
                return True
    '''

    new_board[r][c] = word[idx]

    return False

def findwords(board,words):
    res = []
    for i in range(len(words)):
        found = False
        new_board = copy.deepcopy(board)
        print(".......")
        print(words[i])
        print(".......")
        for j in range(len(board)):
            for k in range(len(board[0])):
                if dfs(new_board,j,k,words[i],0):
                    res.append(words[i])
                    found = True
            if found:
                break

    return res




if __name__ == '__main__':
    '''
    board1 = [
        ["o", "a", "a", "n"],
        ["e", "t", "a", "e"],
        ["i", "h", "k", "r"],
        ["i", "f", "l", "v"]
    ]
    words1 = ["oath", "pea", "eat", "rain"]
    
    board1 = [["a", "b"], ["c", "d"]]
    words1 = ["ab", "cb", "ad", "bd", "ac", "ca", "da", "bc", "db", "adcb", "dabc", "abb", "acb"]
    #expected = ["ab","ac","bd","ca","db"]

    board1 = [["a","b","c"],["a","e","d"],["a","f","g"]]
    words1 = ["abcdefg","gfedcbaaa","eaabcdgfa","befa","dgc","ade"]
    '''
    board1 = [["a"]]
    words1 = ["a"]

    print(findwords(board1,words1))


The file leetcode_26_remove_duplicates.py contains:
def removeDuplicates(nums):
    i = 0
    print(nums)
    while i<len(nums)-1:
        if nums[i]==nums[i+1]:
            del nums[i]
        else:
            i+=1
    return nums


print(removeDuplicates([0,0,1,1,1,2,2,3,3,3,4]))
#print(removeDuplicates([1,1,2]))
The file leetcode_27_remove_element.py contains:
from typing import List
def removeElement(nums: List[int], val: int) -> int:
    length = len(nums)
    count = 0
    for i in range(0,length):
        #print(nums[i],val,length)
        i -=count
        if nums[i]==val:
            print("in if", nums[i])
            #nums.pop(i)
            nums.remove(nums[i])
            count +=1
    return len(nums)



if __name__ == '__main__':
    print(removeElement([0,1,2,2,3,0,4,2],2))
The file leetcode_28_return_first_occurence.py contains:

def strStr(haystack: str, needle: str) -> int:
    print(haystack.find(needle))
    return haystack.find(needle)



if __name__ == '__main__':
    strStr("hello","ll")
    strStr("aaaaa", "bba")
    strStr("aaaaa", "")
    strStr("a","a")

The file level_order_traversal.py contains:
class Node:
    def __init__(self,root):
        self.val = root
        self.left = None
        self.right = None


class bfs:
    res = []
    def oddsum(self,root):
        queue = []
        level = 0
        if root:
            queue.append((root,level))
        while len(queue)>0:
            data = queue.pop(0)
            if data[0].val:
                self.res.append((data[0].val,data[1]))
                if data[0].left:
                    queue.append((data[0].left,level+1))
                if data[0].right:
                    queue.append((data[0].right,level+1))
                level+=1
        return self.res

class bfs2:
    def traverser2(self,r):
        res= []
        queue = []
        if r:
            queue.append(r)
        while queue:
            data = queue.pop(0)
            res.append(data.val)
            print(res)
            if data.left:
                queue.append(data.left)
            if data.right:
                queue.append(data.right)

        return res


if __name__ == '__main__':
    root = Node(3)
    root.left = Node(9)
    root.right = Node(20)
    root.left.left = Node(15)
    root.left.right = Node(7)
    root.left.left.left = Node(10)
    root.left.left.right = Node(10)
    traverse = bfs()
    t = traverse.oddsum(root)
    print(t)

    traverse2 = bfs2()
    t = traverse2.traverser2(root)
    #print(t)

'''
    res = [[]]
    for i in range(len(t)):
        if len(res)-1==t[i][1]:
            res[t[i][1]].append(t[i][0])
        else:
            res.append([])
            res[t[i][1]].append(t[i][0])
        print(res)
'''
The file LinkedList.py contains:
class ListNode:
    def __init__(self,x):
        self.val = x
        self.next  =None

class LinkedList:
    def __init__(self):
        self.head = None

    def push(self,x):
        print("---- Pusing at end -----",x)
        new_node = ListNode(x)
        if not self.head:
            new_node.next = None
            self.head = new_node

        last = self.head
        while last.next:
            last= last.next

        last.next = new_node
        new_node.next = None

    def printAll(self):
        last = self.head
        op = []
        while last:
            op.append(last.val)
            last = last.next
        return op

    def length(self):
        last = self.head
        length = 0
        while last:
            length+=1
            last = last.next

        return length

    def addAtfirst(self,x):
        print("---- Adding at start -----",x)
        new_node = ListNode(x)
        new_node.next = self.head
        self.head = new_node

    def deleteNode(self,x):
        print("---- Deleting the node -----",x)
        prev = self.head
        targetNode = self.head
        if self.head.val ==x:
            self.head = self.head.next

        while targetNode.val != x:
            #print("---target---",targetNode.val)
            #print("----prev--", prev.val)
            prev = targetNode
            targetNode = targetNode.next
        prev.next = targetNode.next

if __name__ == '__main__':
    l = LinkedList()
    l2 = LinkedList()
    l.push(2)
    l.push(3)
    l.push(4)
    l.push(1)
    l2.addAtfirst(2)
    l2.addAtfirst(3)
    l2.addAtfirst(4)
    l2.addAtfirst(1)
    print(l.printAll())
    print(l2.printAll())
    print(l.length())
    l.deleteNode(4)
    print(l.printAll())
    l.addAtfirst(7)
    l.push(7)
    print(l.printAll())
    l.deleteNode(7)
    print(l.printAll())
    l.deleteNode(7)
    print(l.printAll())

The file LL_in_python.py contains:
class Node:
    def __init__(self,data):
        self.data = data;
        self.next = None;


n1 = Node(21);
n2 = Node(22);

n1.next = n2;

print(n1.data,n2.data)

a = [1,2,4,6,8,9,1]
print(a)
a.sort()
print("Pop :- ",a.pop(3))
print(a)
a.reverse()
print("Reverse :-",a)

The file longestIncreasingPathInMatrix.py contains:
def longestIncreasingPath(matrix):
    tempq = 0
    def dfs(i,j,path,ret1):
        x= [1,-1,0,0]
        y = [0,0,1,-1]
        num = matrix[i][j]
        matrix[i][j] = -1

        for m in range(4):
            new_i = i + x[m]
            new_j = j + y[m]
            if 0<=new_i<r and 0<=new_j<c and matrix[new_i][new_j]>num:
                ret1.append(dfs(new_i,new_j,path+[matrix[new_i][new_j]],ret1))
                #print("After",ret1)


        matrix[i][j] = num
        print(path)

        return len(path)


    r = len(matrix)
    c =len(matrix[0])
    pathLength = 0
    ret = []
    for i in range(r):
        for j in range(c):
            print("......",nums[i][j],'......')
            path = [nums[i][j]]
            dfs(i,j,path,ret)
    print(max(ret))


if __name__ == '__main__':
    #nums = [[9,9,4],[6,6,8],[2,1,1]]
    nums = [[3,4,5],[3,2,6],[2,2,1]]
    longestIncreasingPath(nums)

The file longestKeyPress.py contains:
import collections
def longestKeyPress(keys_and_times):
    time_for_longest_keypress = -1
    temp_key = 0
    time_for_previous_keypress = 0

    for i in range(len(keys_and_times)):
        key_press_time = keys_and_times[i][1] - time_for_previous_keypress
        if key_press_time > time_for_longest_keypress:
            time_for_longest_keypress = key_press_time
            temp_key = keys_and_times[i][0]
        time_for_previous_keypress = keys_and_times[i][1]
    return chr(ord('a') + temp_key)



def segment(x,arr):
    maxElement = -float("inf")
    n = len(arr)
    Qi = collections.deque()
    for i in range(x):
        while Qi and arr[i] < arr[Qi[-1]]:
            Qi.pop()
        Qi.append(i)
    for i in range(x, n):
        if arr[Qi[0]] > maxElement:
            maxElement = arr[Qi[0]]
        while Qi and Qi[0] <= i - x:
            Qi.popleft()

        while Qi and arr[i] < arr[Qi[-1]]:
            Qi.pop()
        Qi.append(i)
    if arr[Qi[0]] > maxElement:
        maxElement = arr[Qi[0]]

    return maxElement

if __name__ == '__main__':
    print(longestKeyPress([[0,2],[1,3],[0,7]]))
    print(longestKeyPress([[0, 1], [0, 3], [4, 5],[5,6],[4,10]]))
    print(longestKeyPress([[0, 3], [20, 5], [2, 6],[15,7],[9,8],[19,9],[24,10],[4,12],[3,13]]))

    print(segment(1,[1000000000]))
The file longest_sub_grid.py contains:
def matrxi1(a,maxSum):
    n = len(a)
    for i in range(n-1,-1,-1):
        for j in range(0,n-i):
            for k in range(0,n-i):
                sum = 0
                for l in range(j,j+i):
                    for m in range(k,k+i):
                        print(l,m)
                        sum+= a[l][m]
                if (sum <= maxSum):
                    return (i)
    return 0


def matrxi(a, maxSum):
    n = len(a)
    for i in range(n, 0, -1):
        flag = 0
        for j in range(0, n - i + 1):
            if (j == 0 or flag == 1):
                flagk = 0
                for k in range(0, n - i + 1):
                    if (k == 0 or flagk == 1):
                        sum = 0
                        for l in range(j, j + i):
                            for m in range(k, k + i):
                                sum += a[l][m]
                        if (sum <= maxSum):
                            flagk = 1
                            flag = 1
                        else:
                            flag = 0
                            flagk = 0
            else:
                break
        if j == n - i and flag == 1:
            return i

    return 0


#print(matrxi([[1,1,1],[1,1,1],[1,1,1]],4))
#print(matrxi([[1,1,1],[1,1,1],[1,1,1]],4))

print(prblm_11())
The file Manager_Employee.py contains:
def iterate(emp1,temp,designation_emp):
    #print(designation_emp.get(emp1))
    if(designation_emp.get(emp1)!="Boss"):
        temp.append(designation_emp.get(emp1))
        iterate(designation_emp.get(emp1),temp,designation_emp)
    return temp




if __name__ == '__main__':
    temp = []
    temp2=[]
    set_emp = set(["Gaurav","Sakshat","Pratik","Sumedh","Anup","Pawan","Srishti"])
    designation_emp = {"Gaurav":"Sumedh","Sakshat":"Sumedh","Pratik":"Sumedh","Sumedh":"Anup","Anup":"Srishti","Pawan":"Srishti","Srishti":"Boss"}
    #print(designation_emp.get("Srishti"))
    a = iterate("Gaurav",temp,designation_emp)
    b = iterate("Sumedh",temp2,designation_emp)
    s = set()
    a.reverse()
    b.reverse()
    print("a = ", a)
    print("b = ", b)
    LCM = "none"
    if len(a)<len(b):
        for i in range(len(a)):
            if a[i]!=b[i]:
                LCM = a[i-1]
        if LCM == "none":
            LCM = b[len(a)-1]
    else:
        for i in range(len(b)):
            if b[i]!=a[i]:
                LCM = b[i-1]
        if LCM == "none":
            LCM = a[len(b)-1]

    print(LCM)


    '''
    if len(a)>len(b):
        for i in range(len(a)):
            s.add(a[i])
    else:
        for i in range(len(b)):
            s.add(b[i])
    print("s - ",s)
    if len(a)>len(b):
        print("In if",len(a))
        for i in range(len(a)-1,-1,-1):
            #print(i)
            if a[i] not in s:
                print(a[i])
                LCM = a[i+1]
                print(LCM)
                break
            else:
                print("In else")
        print("Out of for")
    else:
        for i in range(len(b)-1,-1,-1):
            if b[i] not in s:
                LCM = b[i + 1]
                break
    #print(LCM)
    
    '''
The file mapping_number_Goldman.py contains:
def strangeSort(mapping, nums):
    m = {}
    out = {}
    return_list = []
    for k, v in enumerate(mapping):
        m[v] = k
    for num in nums:
        number = 0
        for c in num:
            n = int(c)
            number = number * 10 + m[n]
        if number not in out:
            out[number] = []
        out[number].append(num)
    for each in sorted(out.keys()):
        for num in out[each]:
            return_list.append(num)
    print(return_list)

if __name__ == '__main__':
    mapping = [2, 1, 4, 8, 6, 3, 0, 9, 7, 5]
    nums = ['8', '12', '02', '4', '023', '65', '83', '224', '50']
    strangeSort(mapping,nums)
The file matchNomatch.py contains:
from collections import deque
class mathNomatch:
    def __init__(self,pattern):
        self.pattern = deque()
        self.pattern = pattern
        self.q = []
        self.patternLen = len(self.pattern)

    def match(self,ip):
        if len(self.q)<len(self.pattern):
            self.q.append(ip)
        else:
            self.q.pop(0)
            self.q.append(ip)

        #print(self.pattern,self.q,type(self.q))
        if self.q == self.pattern:
            return  "Match Found"
        else:
            return "No Match"

if __name__ == '__main__':
    s1 = mathNomatch([True,True,False,True])
    s2 = mathNomatch([True,False, True, True])
    while True:
        ip1 = input()
        if ip1.lower() == "true":
            print("... Calling s1 ....")
            print(s1.match(True))
            print("... Calling s2 ....")
            print(s2.match(True))
        else:
            print("... Calling s1 ....")
            print(s1.match(False))
            print("... Calling s2 ....")
            print(s2.match(False))







The file matchPrefix.py contains:
def prefixMatching(arr, str1, k):
    if k > len(str1):
        return "Error"
    prefix = str1[:k]
    #print(prefix)
    count =0
    for i in range(len(arr)):
        if len(arr[i])>k and arr[i][:k] == prefix:
            count +=1
    return count

if __name__ == '__main__':
    str1 = ["abba", "abbb", "abbc", "abbd", "abaa", "abca"]
    str2= ["geeks","geeksforgeeks","forgeeks"]
    print(prefixMatching(str1,"abbg",3))
    print(prefixMatching(str1, "abg", 2))
    print(prefixMatching(str1, "xyz", 2))
    print(prefixMatching(str2, "geeks", 2))
The file matrixQueries.py contains:
import math
def createMatrix(n,m):
    Matrix = [[x*y for x in range(1,n+1)] for y in range(1,m+1)]
    return Matrix

def matrixquery(n,m,queries):
    result=[]
    min_row=1
    row=[]
    min_column=1
    col=[]
    for query in queries:
        if query[0] == 0:
            result.append((min_row)*(min_column))
        elif query[0] == 1:
            row.append(query[1])
            for i in range(1,n+1):
                if i not in row:
                    min_row=i
                    break
        else:
            col.append(query[1])
            for i in range(1,m+1):
                if i not in col:
                    min_column=i
                    break
        print(min_row,min_column)
    return result


def matrixquery(n,m,queries):
    matrix=[]
    result=[]
    for i in range(0,n):
        matrix.append([])
        for j in range(0,m):
            matrix[i].append((i+1)*(j+1))
    for query in queries:
        if query[0] == 0:
            mini = min(min(matrix))
            result.append(mini)
        elif query[0] == 1:
            for i in range(0,m):
                matrix[query[1]-1][i] = math.inf
        else:
            for i in range(0,n):
                matrix[i][query[1]-1] = math.inf
    print(matrix)
    return result



matrix = createMatrix(3,3)
print(matrix)
print(min(min(matrix)))
res = []
#n = 10
#m = 2
#n = 100000
#m = 100000
n = 3
m = 4
queries  = [[0],[1,2],[0],[2,1],[0],[1,1],[0]]
#queries  = [[1,1],[2,2],[0]]
#queries = [[0]]
#print(matrixquery(n,m,queries))



def matrixLogic(n, m, queries):
    row = []
    col = []
    mini = []

    for i in range(1,n+1):
        row.append(i)

    for j in range(1,m+1):
        col.append(j)

    print(row, col)

    for query in queries:
        if query[0] == 0:
            mini.append(row[0]*col[0])
        elif query[0] == 1:
            row.remove(query[1])
        elif query[0] == 2:
            col.remove(query[1])

    return mini

print(matrixLogic(n,m,queries))


The file maxArithmaticLength.py contains:
import sys

def sortArray(a,b):
    c = set()
    i,j = 0,0
    while i < len(a) and j < len(b):
        if a[i] < b[j]:
            c.add(a[i])
            i+=1
        else:
            c.add(b[j])
            j+=1
    while i < len(a):
        c.add(a[i])
        i+=1
    while j < len(b):
        c.add(b[j])
        j+=1
    return list(c)

def maxArithmeticLength(a,b):
    c = sortArray(a,b)
    minDiff = sys.maxsize
    maxDiff = -sys.maxsize
    for i in range(len(c)-1):
        if minDiff > c[i+1] - c[i]:
            minDiff = c[i+1] - c[i]
        if maxDiff < c[i+1] - c[i]:
            maxDiff = c[i+1] - c[i]
    result = -1
    setA = set(a)
    while minDiff <= maxDiff:
        temp = set()
        count = 1
        j = 0
        i = c[j]
        temp.add(i)
        while j < len(c):
            i += minDiff
            if i in c:
                count += 1
                temp.add(i)
            else:
                break
            j+=1
        minDiff += 1
        if setA.issubset(temp):
            if result < count:
                result = count
    return result

print(maxArithmeticLength([0,4,8,16],[0,2,6,12,14,20]))
print(maxArithmeticLength([4,8,16],[0,2,6,10,12,14,20]))
The file maximumLevelSum.py contains:


class Node:

    def __init__(self,root):
        self.val = root
        self.left = None
        self.right = None



def findSum(root):
    def helper(r,level):
        if r:
            print(level_sum)
            helper(r.left,level+1)
            if level in level_sum:
                level_sum[level]+=r.val
            else:
                level_sum[level]=r.val
            helper(r.right,level+1)

    level_sum = {}
    helper(root,1)
    print(level_sum)

    return max(level_sum)



if __name__ == '__main__':
    root = Node(1)
    root.left = Node(2)
    root.right = Node(3)
    root.left.left = Node(4)
    root.left.right = Node(5)
    root.right.left = Node(6)
    root.right.right = Node(7)
    root.right.left.left = Node(8)

    print(findSum(root))

The file maxThreadActive.py contains:
def maxActiveThread(intervals):
    d = {}

    for start,end in intervals:
        if start not in d:
            d[start] = 0
        if end not in d:
            d[end] = 0

        d[start]+=1
        d[end]-=1

    print(d)
    total_thread,max_thread =0,0
    for i in sorted(d.keys()):
        total_thread += d[i]
        max_thread = max(max_thread,total_thread)

    print(max_thread)

if __name__ == '__main__':
    maxActiveThread([[2,4],[3,5],[1,4],[5,7]])




The file maxWithoutIfElse.py contains:
def maxWithoutif(a,b):
    return (a>b)*a + (b>a)*b

def minWithoutif(a,b):
    return (a>b)*b + (b>a)*a

print(maxWithoutif(6,5))
print(minWithoutif(6,5))

The file memoryAllocator.py contains:
def allocate(arr,index):
    for i in range(len(arr)):
        if len(arr[i:i+index])!=index:
            return -1,arr
        if sum(arr[i:i+index]) ==0:
            arr[i:i+index] = [1]*(i+index-i)
            return i,arr
    return -1,arr

def memoryAllocator(a,queries):
    print("----------------------------------")
    res = []
    counter = 0
    atomic_counter = []
    atomic_index= []
    for i in  range(len(queries)):
        if queries[i][0] == 0:
            #print("---- Adding ----")
            op,a = allocate(a,queries[i][1])
            #print(op)
            if op!=-1:
                counter+=1
                atomic_counter.append(counter)
                atomic_index.append(queries[i][1])
            res.append(op)
            #print(res,atomic_counter)
        else:
            #print("----- Erasing -----")
            #print(atomic_counter)
            if queries[i][1] in atomic_counter:
                id = atomic_counter.index(queries[i][1])
                #print(atomic_index[id])
                a[res[id]:res[id]+queries[id][1]] =[0]* (id+queries[id][1]-id)
                res.append(atomic_index[id])
            else:
                res.append(-1)
    print("Final o/p: - ",res)

            #print(res[id],queries[id][1])



if __name__ == '__main__':
    memoryAllocator([0,1,0,0,0,1,1,0,0,0,1,0,0],[[0,2],[0,1],[0,1],[1,2],[1,4],[0,4]])
    memoryAllocator([0,0,0,0],[[0,4],[0,1],[1,1],[0,2],[0,2]])
    memoryAllocator([1],[[0,1],[1,1]])

The file mergetwoalternate.py contains:
a = "abc"
b = "def"
i =0
result =""
while i<len(a) or i<len(b):
    if i<len(a):
        result=result+a[i]
    if i<len(b):
        result = result + b[i]
    i+=1
print(result)

The file Microsoft_1.py contains:
#s = "aaBabcDaA"
#s = "Codility"
#s = "cCaAvVzXZ"
s = "cCeEzZ"
res = ""
res1=-1
t =set()
#print(ord("a"),ord("A"))
for i in range(len(s)):
    t.add(ord(s[i]))

for i in range(len(s)):
    if ord(s[i])+32 in t and res1<ord(s[i]):
        res = s[i]
        res1 = ord(s[i])
if res:
    print(res)
else:
    print("NO")
The file minContiguousLengthOfSubArray.py contains:
'''
def twoIntegers(A,s):
    op = []
    for i in range(len(A)):
        sum =A[i]
        for j in range(i+1,len(A)):
            #print("i",A[i],"j",A[j])
            sum+=A[j]
            if sum>=s:
                if len(op)==0 or j-i<len(op):
                    op =A[i:j+1]
                    break
    print(op)
    return len(op)
'''
import math
def twoIntegers(A,s):
    window_sum,window_start = 0,0
    min_length = math.inf
    for end in range(len(A)):
        window_sum+=A[end]
        while window_sum>=s:
            prev = min_length
            min_length = min(min_length,end-window_start+1)
            if min_length<prev:
                op = A[window_start:end + 1]
            window_sum-=A[window_start]
            window_start+=1

    print(op)
    return min_length



if __name__ == '__main__':
    s = 7
    #s = 6
    #s =20
    #s = 1
    A = [2,3,1,2,4,3]
    #A = [1,1,2,2,2,1,1]
    #A = [2,3,1,2,4,3]
    #A = []
    #Output =2

    print(twoIntegers(A,s))

The file mineSweeper.py contains:
def dfs(field,x,y,visited):
    count  =0
    print("-------- dfs ----------")
    if 0 <= x + 1 < len(field) and field[x+1][y] and [x+1,y] not in visited:
        print(x+1,y)
        count +=1
    if 0 <= x - 1 < len(field) and field[x-1][y] and [x-1,y] not in visited:
        print(x - 1, y)
        count += 1
    if 0 <= y + 1 < len(field[0]) and field[x][y+1] and [x,y+1] not in visited:
        print(x, y+1)
        count += 1
    if 0 <= y - 1 < len(field[0]) and field[x][y-1] and [x,y-1] not in visited:
        print(x , y-1)
        count += 1

    if 0<=x-1<len(field) and 0<=y-1<len(field) and field[x-1][y-1] and [x-1,y-1] not in visited:
        print(x - 1, y-1)
        count+=1
    if 0<=x+1<len(field) and 0<=y-1<len(field) and field[x+1][y-1] and [x+1,y-1] not in visited:
        print(x + 1, y-1)
        count+=1
    if 0<=x-1<len(field) and 0<=y+1<len(field) and field[x-1][y+1] and [x-1,y+1] not in visited:
        print(x - 1, y+1)
        count+=1
    if 0<=x+1<len(field) and 0<=y+1<len(field) and field[x+1][y+1] and [x+1,y+1] not in visited:
        print(x + 1, y+1)
        count+=1

    print(count)
    return count

def dfs1(field,x,y,visited):
    count  =0
    row = [1, -1, 0, 0, -1, 1, -1, 1]
    col = [0, 0, 1, -1, -1, -1, 1, 1]
    for i in range(8):
        #print("-------- dfs ----------")
        if 0<=x+row[i]<len(field) and 0<=y+col[i]<len(field[0])and field[x+row[i]][y+col[i]] and [x+row[i],y+col[i]] not in visited:
            count+=1
    #print(count)
    return count


def minsweeper(field, x,y):
    q = []
    visited = []
    row = [1,-1,0,0,-1,1,-1,1]
    col = [0,0,1,-1,-1,-1,1,1]
    if field[x][y]:
        #print("in if")
        return [[-1]*len(field[0])]*len(field)
    else:
        #print("in else")
        q.append([x,y])
        while q:
            data = q.pop(0)
            cnt = dfs1(field,data[0],data[1],visited)
            visited.append(data)
            field[data[0]][data[1]] =cnt
            if cnt == 0:
                for i in range(8):
                    if 0 <= data[0] + row[i]<len(field) and 0<=data[1]+col[i]<len(field[0])and [data[0] + row[i], data[1]+col[i]] not in visited and [data[0] + row[i], data[1]+col[i]] not in q:
                        q.append([data[0]+row[i],data[1]+col[i]])
    #print(field)

    for i in range(len(field)):
        for j in range(len(field[0])):
            if type(field[i][j]) == bool:
                field[i][j] = -1

    return field




if __name__ == '__main__':
    #field = [[False,True,True],[True,False,True],[False,False,True]]
    field = [[True, False, True,True,False], [True, False, False, False, False], [False, False, False, False, False],[True,False,False,False,False]]
    #field = [[True, False, False, False, False,True],[True, False, False, False, False,False],[True, True, False, False, False,False],[False, False, True, False, False,False],[False, False, True, True, True, True]]
    #x = 1
    #y =1
    x= 3
    y = 2
    #x =0
    #y = 5
    print(minsweeper(field,x,y))

The file minimumUniqueArraySum.py contains:
'''
import collections
def minIncrementForUnique(A):
    count = collections.Counter(A)
    taken = []
    ans = 0
    res = []
    for x in range(100000):
        if count[x] >= 2:
            taken.extend([x] * (count[x] - 1))
            res.append(x)
        elif taken and count[x] == 0:
            res.append(x)
            ans += x - taken.pop()
    print(res)
    print(sum(res))
    return ans


def minIncrementForUnique(A):
    A.sort()
    ret = 0
    cur = -1
    res = []
    for num in A:
        cur = max(cur, num)
        res.append(cur)
        ret += cur - num
    return res





# Driver code
#A = [3, 2, 1, 2, 1, 7]
#A = [1,2,2]
A = [4,2,2,4,5]
print(minIncrementForUnique(A))

'''

MAX = 50


def solve(dp, a, low, high, turn):
    # If only one element left.
    if (low == high):
        return a[low] * turn

        # If already calculated,
    # return the value.
    if (dp[low][high] != 0):
        return dp[low][high]

        # Computing Maximum value when element
    # at index i and index j is to be chosed.
    dp[low][high] = max(a[low] * turn + solve(dp, a,
                                              low + 1, high, turn + 1),
                        a[high] * turn + solve(dp, a,
                                               low, high - 1, turn + 1))
    print(dp)

    return dp[low][high]


# Driver Code
if __name__ == "__main__":
    arr = [1, 3, 1, 5, 2]
    n = len(arr)

    dp = [[0 for x in range(MAX)]
          for y in range(MAX)]

    print(solve(dp, arr, 0, n - 1, 1))
The file minMoves_Chess.py contains:
# Python3 code to find minimum steps to reach
# to specific cell in minimum moves by Knight
class cell:
    def __init__(self, x=0, y=0, dist=0):
        self.x = x
        self.y = y
        self.dist = dist

def isInside(x, y, N):
    if x >= 1 and x <= N and y >= 1 and y <= N:
        return True
    return False

def minMoves(n, startRow, startCol, endRow, endCol):
    startRow +=  1
    startCol += 1
    endRow += 1
    endCol += 1
    dx = [2, 2, -2, -2, 1, 1, -1, -1]
    dy = [1, -1, 1, -1, 2, -2, 2, -2]
    queue = []
    queue.append(cell(startRow, endRow, 0))
    visited = [[False for i in range(N + 1)]for j in range(N + 1)]
    visited[startRow][endRow] = True
    while len(queue) > 0:
        t = queue[0]
        queue.pop(0)
        if (t.x == startCol and
                    t.y == endCol):
            return t.dist
        for i in range(8):
            x = t.x + dx[i]
            y = t.y + dy[i]
            if isInside(x, y, N) and not visited[x][y]:
                visited[x][y] = True
                queue.append(cell(x, y, t.dist + 1))

if __name__ == '__main__':
    N = 9
    #knightpos = [6, 2]
    #targetpos = [1, 6]
    startRow = 4
    startCol = 4
    endRow = 4
    endCol = 8
    print(minMoves(N,startRow,startCol,endRow,endCol))


The file most_common_words.py contains:
import re

def retrieveMostFrequentlyUseWords(literatureText, wordsToExclude):
    for i in range(len(wordsToExclude)):
        wordsToExclude[i] = wordsToExclude[i]

    print(wordsToExclude)
    wordsToExclude = set(wordsToExclude)
    words = {}
    for i in range(len(literatureText)):
      if literatureText[i] != " " and not literatureText[i].isalpha():
          literatureText[i] = " "
    inputStr = "".join(literatureText).lower()
    inputList = inputStr.split(" ")
    for word in inputList:
      if not word:
        continue
      if word not in wordsToExclude:
        if word not in words:
          words[word] = 1
        else:
          words[word] += 1
    sorted_words = sorted(words.items(), key = lambda x: x[1], reverse=True)
    results = []
    max_count = float('-inf')
    for word, freq in sorted_words:
      if max_count <= freq:
        results.append(word)
        max_count = freq
      else:
        break
    return  results

def solution(sentence, stop_words):
    stop_words = [x.lower() for x in stop_words]
    res = re.findall(r'\w+', sentence)
    res = [x.lower() for x in res]

    worddict = {}

    for word in res:
        if word not in worddict:
            worddict[word] = 1
        else:
            worddict[word] += 1

    print(worddict)

    fwords = []
    for value in worddict:
        if (worddict[value] > 1) and (value not in stop_words):
            fwords.append(value)

    print(fwords)


if __name__ == '__main__':
    inputStr = "Jack and Jill went to the market to buy bread and cheese. Cheese is Jack's and Jill's favorite food."
    # inputStr = "Rose is a flower red rose are flower"
    stop_words = ["and", "he", "the", "to", "is", "Jack", "Jill"]
    # stop_words = set(['is', "are", "a"])
    inputStr = list(inputStr)
    #print(retrieveMostFrequentlyUseWords(inputStr,stop_words))
    solution(inputStr,stop_words)
#print(mostCommonWord("Jack and Jill went to the market to buy bread and cheese. Cheese is Jack's and Jill's favorite food",["and", "he", "the", "to", "is", "Jack", "Jill"]))
The file movesToSolve.py contains:
import heapq as heapq
import itertools
import collections


def movesToSolve(board):
    s = ''.join(str(d) for row in board for d in row)
    dq, seen = collections.deque(), {s}
    dq.append((s, s.index('0')))
    steps, height, width = 0, len(board), len(board[0])
    temp = ""
    for i in range(0,len(board[0])*len(board[1])):
        temp = temp+str(i)
    #print(t)
    while dq:
        for _ in range(len(dq)):
            t, i = dq.popleft()
            if t == temp:
                return steps
            x, y = i // width, i % width
            for r, c in (x, y + 1), (x, y - 1), (x + 1, y), (x - 1, y):
                if height > r >= 0 <= c < width:
                    ch = [d for d in t]
                    ch[i], ch[r * width + c] = ch[r * width + c], '0'  # swap '0' and its neighbor.
                    s = ''.join(ch)
                    if s not in seen:
                        seen.add(s)
                        dq.append((s, r * width + c))
        steps += 1
    return -1

#print(movesToSolve([[1,6,3],[8,7,2],[4,0,5]]))
print(movesToSolve([[1,4,2],[3,0,5],[6,7,8]]))
print(movesToSolve([[1,0,2],[3,4,5],[6,7,8]]))
print(movesToSolve([[2,7,1],[6,3,5],[0,4,8]]))
print(movesToSolve([[0,4,2],[3,1,5],[6,7,8]]))
The file mutate_matrix.py contains:
def rotate90Clockwise(A):
    N = len(A)
    for i in range(N // 2):
        for j in range(i, N - i - 1):
            temp = A[i][j]
            A[i][j] = A[N - 1 - j][i]
            A[N - 1 - j][i] = A[N - 1 - i][N - 1 - j]
            A[N - 1 - i][N - 1 - j] = A[j][N - 1 - i]
            A[j][N - 1 - i] = temp
    return  A

def mainDiagonal(mat):
    for i in range(len(mat)):
        for j in range(i + 1):
            temp = mat[i][j]
            mat[i][j] = mat[j][i]
            mat[j][i] = temp
    return mat


def reverseDiagonal(mat):
    for i in range(len(mat)):
        for j in range(len(mat) - i):
            tmp = mat[i][j]
            mat[i][j] = mat[(len(mat) - 1) - j][(len(mat) - 1) - i]
            mat[(len(mat) - 1) - j][(len(mat) - 1) - i] = tmp
    return mat

def rotateMatrix(mat, N):
    for x in range(0, int(N / 2)):

        for y in range(x, N - x - 1):
            temp = mat[y][x]

            mat[y][x] = mat[N - 1 - x][y]

            mat[N - 1 - x][y] = mat[N - 1 - y][N - 1 - x]

            mat[N - 1 - y][N - 1 - x] = mat[x][N - 1 - y]

            mat[x][N - 1 - y] = temp
    return mat


def flipimage(mat):
    for i in range(len(mat)):
        for j in range(i + 1):
            temp = mat[i][j]
            mat[i][j] = mat[j][i]
            mat[j][i] = temp
    return mat


def flipimage2(mat):
    for i in range(len(mat)):
        for j in range(len(mat) - i):
            tmp = mat[i][j];
            mat[i][j] = mat[(len(mat) - 1) - j][(len(mat) - 1) - i];
            mat[(len(mat) - 1) - j][(len(mat) - 1) - i] = tmp
    return mat


def query_matrix(mat, q):
    for i in range(len(q)):
        if q[i] == 0:
            mat = rotateMatrix(mat, len(mat))
        elif q[i] == 1:
            mat = flipimage(mat)
        else:
            mat = flipimage2(mat)
    return mat



#mat = [[1,2,3],[4,5,6],[7,8,9]]
#mat = [[11,2,9,1],[17,4,0,32],[1,7,10,6],[80,3,5,14]]
mat = [[5,5],[1,2]]

'''
mat = rotate90Clockwise(mat).copy()
print(mat)
#print(x)
mat = mainDiagonal(mat).copy()
print(mat)
#print(y)


print(reverseDiagonal(mat))


'''

#print(mainDiagonal(mat))
q = [2,0,2,0,1]
#q = [0,1,2,0]
for i in range(len(q)):
    if q[i] == 0:
        mat = rotate90Clockwise(mat)
    elif q[i] == 1:
        mat = mainDiagonal(mat)
    else:
        mat = reverseDiagonal(mat)
    print(q[i],mat)
print("-----------------------------")
The file my-directory-list.txt contains:
The file Akuna_Binary_wal.py contains:
import codecs
import re
from datetime import datetime
'''
class WAL(object):
    def __init__(self,binary_wal):
        self.binary_wal = binary_wal.hex()
        self.res = []


    def get_events(self):
        a = []
        a.append(str(int(self.binary_wal[:16], 16)))
        if int(self.binary_wal[16:18], 16) == 0:
            a.append("INSERT")
        elif int(self.binary_wal[16:18], 16) == 1:
            a.append("UPSERT")
        if int(self.binary_wal[16:18], 16) == 2:
            a.append("DELETE")
        key_length = int(self.binary_wal[18:22], 16)
        key_length = (key_length * 2)
        key_value = codecs.decode(self.binary_wal[22:22 + key_length], "hex")
        key_value = str(key_value)
        key_value = key_value.replace("b'", '')
        key_value = key_value.replace("'", "")
        a.append(key_value)
        if int(self.binary_wal[16:18],16)!=2:
            value_length = int(self.binary_wal[22 + key_length:22+ key_length+4],16)
            value_length = 22 + key_length + 4
            value_value = str(codecs.decode(self.binary_wal[value_length:], "hex"))
            value_value = value_value.replace("b'", '')
            value_value = value_value.replace("'", "")
            a.append(value_value)

        x = '|'.join(a)
        self.res.append(x)
        return sorted(self.res,key=lambda a :a[0])
'''

def bytes_to_int(bytes):
    result = 0
    for b in bytes:
        result = result * 256 + int(b)
    return result

def wal(a):
    n = 0
    while n < len(a):
        if len(a)==0:
            print("..........")
        epoch = bytes_to_int(a[:8])
        #print(a[:8])
        res.append(str(epoch))
        #########################################
        msg_id = bytes_to_int(a[8:9])
        if msg_id == 0:
            res.append("INSERT")
        elif msg_id == 1:
            res.append("UPSERT")
        elif msg_id == 2:
            res.append("DELETE")
        # res.append(str(msg_id))
        #########################################
        key_length = bytes_to_int(a[9:11])
        # res.append(key_length)
        key_value = a[11:11 + key_length].decode('utf-8')
        buf = 11 + key_length
        res.append(key_value)
        #########################################
        if msg_id != 2:
            value_length = bytes_to_int(a[buf:buf+2])
            if value_length<=0:
                return res
            # res.append(value_length)
            buf2 = buf + 2
            value_string = a[buf2:buf2+value_length].decode('utf-8')
            res.append(value_string)
        #########################################
        #print(res)
        else:
            buf2 = buf
            value_length = 0
        x = '|'.join(res)
        print(x)
        n +=len(a[:buf2+value_length])
        #print(n)
        if n!=len(a):
            a =a[n:]

if __name__ == '__main__':

    #print(WAL(b'\x00\x00\x01l\x05-\xcfA\x00\x00\x0etest_key_09812\x00\x10test_value_12876').get_events())
    #temp = '0000016c052dcf4100000e746573745f6b65795f30393831320010746573745f76616c75655f3132383736'
    temp1 = '0000016c052dcf4101000d746573745f6b65795f313233340012746573745f76616c75655f31323339393038'
    temp2 = '0000016c052dcf4102000f746573745f6b65795f313233383937'
    #print(bytes.fromhex('0000016c052dcf42'))
    temp = bytes.fromhex('0000016c052dcf4100000e')
    x = '0000016c052dcf4100000e746573745f6b65795f30393831320010746573745f76616c75655f31323837360000016c052dcf4101000d746573745f6b65795f313233340012746573745f76616c75655f31323339393038'
    all = bytes.fromhex(x)
    upsert = bytes.fromhex(temp1)
    delete = bytes.fromhex(temp2)
    #insert = b'\x00\x00\x01l\x05-\xcfB\x00\x00\x0etest_key_09812\x00\x10test_value_12876'
    insert = b''
    new = [all]
    res = []
    #st = '\x00\x00\x01l\x05-\xcfA\x00\x00\x0etest_key_09812\x00\x10test_value 12876'
    for i in range(len(new)):
        wal(new[i])




The file Akuna_Medha_Python.py contains:
def process(num):
    if len(num) != 8:
        return "INVALID"
    try:
        s = int(num[2:],16)
    except:
        return  "INVALID"
    sum =0
    while s!=0:
        sum+=int(s%10)
        s = s//10
    if hex(sum)[2:] == num[:2].lower():
        return "INVALID"
    else:
        "INVALID"

def process_2(line):
    if len(line) != 8:
        return "INVALID"
    try:
        a = int(line, 16)
    except:
        return "INVALID"
    try:
        s = int(line[2:], 16)
        x = int(line[:2], 16)
    except:
        return "INVALID A"
    sum = 0
    while(s > 0):
        sum = sum + s%10
        s = s//10
    if x == sum:
        return "VALID"
    return "INVALID"


print(process())
The file Akuna_Python_dev.py contains:
class PathCalculator:
    distance = {}  # dictionary that maintains distance between cities
    def process(self, line: str) -> str:
        if line == None:
            return "NONE"
        possible_route = {}
        city1, city2, dis = list(line.split(':'))
        if not city1 in self.distance:
            self.distance[city1] = {}
        self.distance[city1][city2] = int(dis)
        if not city2 in self.distance:
            self.distance[city2] = {}
        self.distance[city2][city1] = int(dis)
        for start_city in self.distance:
            d = self.distance[start_city]
            # print(d.keys())
            for inter_city in d:
                d1 = self.distance[inter_city]
                final_city = max(d1.keys(), key=(lambda k: d1[k]))
                if start_city != final_city and (inter_city in self.distance[start_city]):
                    total_dis = self.distance[start_city][inter_city] + self.distance[inter_city][final_city]
                    if start_city > final_city:
                        start_city, final_city = final_city, start_city
                    if total_dis in possible_route:
                        start_city_old = possible_route[total_dis][0]
                        if start_city_old > start_city:
                            possible_route[total_dis] = (start_city, inter_city, final_city)
                    else:
                        possible_route[total_dis] = (start_city, inter_city, final_city)

        if possible_route == {}:
            return "NONE"
        else:
            max_dis = max(possible_route)
            c1, c2, c3 = possible_route[max_dis]
            return ':'.join([str(max_dis), c1, c2, c3])

ob=PathCalculator()
l1='SEA:NYC:200'
l2='CHI:AUS:200'
l3='NYC:AUS:1000'
l4='NYC:HAWAII:4393'
l5='CHI:AUS:719'
l6='AUS:LA:2414'
print(ob.process(l1))
# print(ob.process(l2))
# print(ob.process(l3))
# # print(ob.process(l4))
# # print(ob.process(l5))
# # print(ob.process(l6))

ob=PathCalculator()
l1='CHI:NYC:200'
l2='SEATTLE:LA:200'
l3='NYC:SEATTLE:1000'
ob.process(l1)
ob.process(l2)
ob.process(l3)
The file Akuna_Sumedh_publicOfeereing.py contains:
import operator as op
def getUnallottedUsers(bids, totalShares):
    price_dict = dict()
    output =[]
    for i in bids:
        if i[2] not in price_dict:
            price_dict[i[2]] = [[i[0],i[1],i[3]]]
        else:
            price_dict[i[2]].append([i[0],i[1],i[3]])
    for i in price_dict:
        price_dict[i] = sorted(price_dict[i],key= op.itemgetter(2))
    while totalShares > 0:
        max_price = max(price_dict.keys())
        if len(price_dict[max_price]) == 1:
            totalShares -= price_dict[max_price][1]
            price_dict.pop(max_price)
        else:
            if (totalShares // len(price_dict[max_price])) > 0:
                x = totalShares // len(price_dict[max_price])
                for i in price_dict[max_price]:
                    i[1] -= x
                    totalShares -= x
                y = totalShares % len(price_dict[max_price])
                i = 0
                while y > 0 and i<len(price_dict[max_price]):
                    if price_dict[max_price][i][1] == 0:
                        i+=1
                        continue
                    price_dict[max_price][i][1] -= 1
                    totalShares -= 1
                    i+=1
                    y-=1
            else:
                y = totalShares % len(price_dict[max_price])
                i = 0
                while y > 0 and i < len(price_dict[max_price]):

                    price_dict[max_price][i][1] -= 1
                    totalShares -= 1
                    i += 1
                    y -= 1
                for j in range(i,len(price_dict[max_price])-1):
                    output.append(price_dict[max_price][i][0])

            price_dict.pop(max_price)

    for key,value in price_dict:
        for i in range(0,len(value)-1):
            output.append(value[i][0])



    return output



 print(getUnallottedUsers([
     [1,5,5,0],
     [2,7,8,1],
     [3,7,5,1],
     [4,10,3,3]
 ], 18))

The file Akuna_watermark.py contains:
from datetime import datetime
class HashTable:
    def __init__(self, rawEvents):
        self.hwm = None
        self.hashtable = {}
        for i in rawEvents:
            query = i.split('|')
            self.operate_HT(query)

    def operate_HT(self,query):
        if query[1] == 'INSERT':
            self.insert(query[2],query[3])
        elif query[1] == 'UPSERT':
            self.upsert(query[2], query[3])
        elif query[1] == 'DELETE':
            self.delete(query[2])
        x = int(query[0])/1000
        self.hwm = datetime.utcfromtimestamp(x)

    def insert(self,key,value):
        if key not in self.hashtable:
            self.hashtable[key] = value
    def upsert(self,key, value):
        self.hashtable[key] = value

    def delete(self,key):
        if key in self.hashtable:
            self.hashtable.pop(key)
    def table(self):
        print(self.hashtable)
        return self.hashtable

    def high_watermark(self):
        return self.hwm

h = HashTable(['1563454984001|INSERT|test|123','1563454984002|UPSERT|test|123','1563454984003|DELETE|test'])

s = h.table
The file allFactorsConsidered.py contains:
def print_factors(x):
    factors = []
    #print("The factors of",x,"are:")
    for i in range(1, x):
        if x % i == 0:
            factors.append(i)
            #print(i)
    return factors

temp = [3,6,7,21,100]
q = []
for i in range(len(temp)):
    f  = print_factors(temp[i])
    if len(f)==3:
        res = 1
        for i in range(len(f)):
            res = res * f[i]
        q.append(res)


print("Final Output",sum(q))




The file allLevelOfFriends.py contains:
import copy
def allLevelFriends(dict,name):
    res = []
    initial= namesofConnections(dict,name)
    #res = res.append(copy.deepcopy(initial))
    #res = copy.deepcopy(initial)
    res.append(initial[:])
    s= set()
    #print(initial)
    flag = True
    print("Start of while")
    while flag:
        print("--")
        if len(initial)==0:
            break
        #print(initial)
        temp = namesofConnections(dict,initial[0])
        #print("Set: -",s)
        if initial[0] not in s:
            s.add(initial[0])
            if temp==None:
                break
            if name in temp:
                temp.remove(name)
            if len(temp)!=0:
                res.append(temp[:])
                #print("Res after insertion", res)
                initial.extend(temp)
            #print(temp)
            initial.remove(initial[0])
            #print("Intial after removing",initial)
        else:
            initial.remove(initial[0])
            if temp[0] in s:
                temp.remove(temp[0])


    print(res)

def namesofConnections(dict,name):
    if name not in dict:
        return None
    else:
        return dict[name]



if __name__ == '__main__':
    dict={"Bob":["Alice","Sandra","Eric"],
          "Sandra":["Bob","Don"],
          "Alice":["Bob"],
          "Eric":["Bob"],
          "Don":["Sandra","Tim"],
          "Tim":["Don"]
          }
    allLevelFriends(dict,"Bob")
The file all_akuna.py contains:
#------------Heta Akuna-------------------

#----------------Changed Sort----------------

def returnlarge(s,a):
    s = sorted(s)
    i=0
    try:
        while a >= s[i]:
            i+=1
    except:
        return None
    return s[i]
def returnsmall(s,a):
    s = sorted(s,reverse= True)
    i=0
    try:
        while a <= s[i]:
            i+=1
    except:
        return None
    return s[i]
def changedSort(s):
    s = list(s)
    res = []
    res.append(s.pop(s.index(min(s))))
    i = 0
    #print(s,res)
    while i < len(s):
        # print(i,len(s))
        x = returnlarge(s,res[-1])
        if x:
            res.append(s.pop(s.index(x)))
            i+=1
        else:
            break
    x = returnlarge(s, res[-1])
    if x:
        res.append(s.pop(s.index(x)))
    i=0
    while i < len(s):
        x = returnsmall(s[i:],res[-1])
        if x:
            res.append(s.pop(s.index(x)))
            i+=1
        else:
            break
    x = returnsmall(s, res[-1])
    if x:
        res.append(s.pop(s.index(x)))
    if s:
        res += s
    return ''.join(res)

# print(changedSort('aaazzz'))

#-------------Roman Names-----------------

import operator as op


def romanToInt(s):
    num = 0
    my_funcs = {
        'I': (lambda num: -1 if num >= 5 else 1),
        'V': (lambda num: 5),
        'X': (lambda num: -10 if num >= 50 else 10),
        'L': (lambda num: 50),
        'C': (lambda num: -100 if num >= 500 else 100),
        'D': (lambda num: 500),
        'M': (lambda num: 1000)
    }
    for el in reversed(list(s)):
        # print(el)
        num += my_funcs[el](num)

    return num
def sortRoman(names):
    res = []
    for i in names:
        res.append(i.split(' '))
    for i in range(len(res)):
        x = romanToInt(res[i][1])
        res[i].append(x)
    res = sorted(res, key= op.itemgetter(0,2))
    for i in range(len(res)):
        res[i].pop(-1)
        res[i] = ' '.join(res[i])
    return res



#print(sortRoman(['Philippe I','Philip II','Bill L','Bill IX','Bill V','Bill X']))


#----------------------Minimum Operations------------------------

def searchInsert(nums, target):
    i = 0
    if nums == []:
        return i
    if nums[-1] < target:
        return len(nums)
    while (nums[i] < target):
        i += 1
    return i

def minimumOperations(a):
    res = []
    i = 0
    count = 0
    while i < len(a):
        j = searchInsert(res,a[i])
        count += min(j-0, len(res) - j)*2 + 1
        # print(min(j-0, len(res) - j)*2 + 1)
        res.insert(j,a[i])
        i+=1
    print(res,count)
a = [2,5,6,10]
# minimumOperations(a)

class Queue1:
    def _init_(self):
        self.s1 = []
        self.s2 = []
    def put(self,n):
        while self.s1:
            self.s2.append(self.s1.pop())

        self.s1.append(n)

        while self.s2:
            self.s1.append(self.s2.pop())
    def get(self):
        if self.s1:
            return self.s1.pop()
        return None

import queue as q
class Fifo:
    def _init_(self,size):
        self.fifo = q.Queue(size)
        self.cache = dict()

    def put(self,key, value):
        if self.fifo.full():
            self.cache.pop(self.fifo.get())

        self.fifo.put(key)
        self.cache[key] = value

    def get(self, key):
        try:
            return self.cache[key]
        except:
            return None

# fifo = Fifo(3)
# fifo.put(1,5)
# fifo.put(2,6)
# fifo.put(3,7)
# print(fifo.get(2))
# fifo.put(4,7)
# fifo.put(5,1)
# print(fifo.get(4))
# print(fifo.get(2))
# print(list(fifo.fifo.queue))
# print(fifo.cache)
# x = ['10','1','2','11']
# import heapq as hq
# print(hq.nsmallest(2,x))

# def listMax(n,operations):
#     x = [0]*n
#     for i in operations:
#         for j in range(i[0]-1,i[1]):
#             x[j] += i[2]
#     print(max(x))


def create(n):
    size = 1
    while n >= size:
        size *= 2
    return [0] * size


def range_add(fwam, fwaa, low, high, val):
    _update(fwam, fwaa, low, val, -val * (low - 1))
    _update(fwam, fwaa, high, -val, val * high)


def _update(fwam, fwaa, at, m, a):
    s = len(fwam)
    while at < s:
        fwam[at] += m
        fwaa[at] += a
        at += at & (-at)


def range_query(fwam, fwaa, at):
    m, a, st = 0, 0, at
    while at > 0:
        m += fwam[at]
        a += fwaa[at]
        at -= at & (-at)

    return m * st + a


def listMax(n, operations):
    fwam, fwaa = create(n), create(n)
    for a, b, k in operations:
        range_add(fwam, fwaa, a, b, k)

    best, prev = 0, 0
    for i in range(1, n + 1):
        curr = range_query(fwam, fwaa, i)
        best = max(best, curr - prev)
        prev = curr
    print(best)
    return best

# listMax(4,[
#         [2,3,603],
#         [1,1,286],
#         [4,4,882]
#         ])

# a = 'abpqrspqrs'
# minLen, maxLen = 2,4
# x = []
# for i in range(len(a)):
#     if i+maxLen > len(a):
#         break
#     j = i+minLen
#     while j < len(a) and j < i+maxLen+1:
#         x.append(a[i:j])
#         j+=1
#
# print(x)

#--------------Akuna 2-----------------
def wall():
    wallposition = [1,2,4,7]
    wallheight = [4,5,7,11]
    total_wallheight = [0]*max(wallposition)
    j=0
    for i in wallposition:
        total_wallheight[i-1] = wallheight[j]
        j+=1
    x = total_wallheight.copy()
    max_mud_length = -1
    for i in range(1,len(total_wallheight)-1):
        if total_wallheight[i] == 0:
            if total_wallheight[i+1] == 0:
                total_wallheight[i] = total_wallheight[i-1] + 1
                #max_mud_length = max(max_mud_length,total_wallheight[i])
            else:
                total_wallheight[i] = min(total_wallheight[i-1],total_wallheight[i+1])+1
                #max_mud_length = max(max_mud_length, total_wallheight[i])
    print(total_wallheight)
    total_wallheight1 = total_wallheight.copy()
    total_wallheight = x.copy()
    i = len(total_wallheight) - 1
    while i > 0:
        if total_wallheight[i] == 0:
            if total_wallheight[i-1] == 0:
                total_wallheight[i] = total_wallheight[i+1] + 1
                #max_mud_length = max(max_mud_length,total_wallheight[i])
            else:
                total_wallheight[i] = min(total_wallheight[i-1],total_wallheight[i+1])+1
                #max_mud_length = max(max_mud_length, total_wallheight[i])
        i-=1
    for i in range(len(total_wallheight)):
        total_wallheight[i] = min(total_wallheight[i],total_wallheight1[i])
        if x[i] == 0:
            max_mud_length = max(max_mud_length,total_wallheight[i])
    print(total_wallheight)
    print(x)
    print(max_mud_length)

import operator as op
def rearrange(elements):
    bin_array = []
    for i in elements:
        x = (i,bin(i).replace('0b','').count('1'))
        bin_array.append(x)
    bin_array.sort(key=op.itemgetter(1,0))
    a=[]
    for i in bin_array:
        a.append(i[0])
    return a
rearrange([5,3,7,10,14])

def getUnallottedUsers1(bids, totalShares):
    price_dict = dict()
    for i in bids:
        if i[2] not in price_dict:
            price_dict[i[2]] = [[i[0],i[1],i[3]]]
        else:
            price_dict[i[2]].append([i[0],i[1],i[3]])
    for i in price_dict:
        price_dict[i] = sorted(price_dict[i],key= op.itemgetter(2))
    while totalShares > 0:
        max_price = max(price_dict.keys())
        if len(price_dict[max_price]) == 1:
            totalShares -= price_dict[max_price][1]
            price_dict.pop(max_price)
        else:
            if (totalShares // len(price_dict[max_price])) > 0:
                x = totalShares // len(price_dict[max_price])
                for i in price_dict[max_price]:
                    i[1] -= x
                    totalShares -= x
                y = totalShares % len(price_dict[max_price])
                i = 0
                while y > 0 and i<len(price_dict[max_price]):
                    if price_dict[max_price][i][1] == 0:
                        i+=1
                        continue
                    price_dict[max_price][i][1] -= 1
                    totalShares -= 1
                    i+=1
                    y-=1
            else:
                y = totalShares % len(price_dict[max_price])
                i = 0
                while y > 0 and i < len(price_dict[max_price]):
                    if price_dict[max_price][i][1] == 0:
                        i += 1
                        continue
                    price_dict[max_price][i][1] -= 1
                    totalShares -= 1
                    i += 1
                    y -= 1
    return price_dict



# print(getUnallottedUsers([
#     [1,5,5,0],
#     [2,7,8,1],
#     [3,7,5,1],
#     [4,10,3,3]
# ], 18))

import math


def findCombination(n, min, max):
    result = 0
    m = {}

    for i in range(min, max):
        for j in range(min, max):
            if math.gcd(i, j) == 1:
                if m.get(i):
                    m[i] += 1
                else:
                    m[i] = 1

    for i in m:
        result += i ** (n - 1)

    return result

#print(findCombination(2,1,3))

def getUnallottedUsers(bids, totalShares):
    price_dict = dict()
    output = []
    for i in bids:
        if i[2] not in price_dict:
            price_dict[i[2]] = [[i[0], i[1], i[3]]]
        else:
            price_dict[i[2]].append([i[0], i[1], i[3]])
    for i in price_dict:
        price_dict[i] = sorted(price_dict[i], key=op.itemgetter(2))
    while totalShares > 0:
        max_price = max(price_dict.keys())
        if len(price_dict[max_price]) == 1:
            print(price_dict)
            print(price_dict[max_price])
            totalShares -= price_dict[max_price][0][1]
            price_dict.pop(max_price)
        else:
            if (totalShares // len(price_dict[max_price])) > 0:
                x = totalShares // len(price_dict[max_price])
                for i in price_dict[max_price]:
                    i[1] -= x
                    totalShares -= x
                y = totalShares % len(price_dict[max_price])
                i = 0
                while y > 0 and i < len(price_dict[max_price]):
                    if price_dict[max_price][i][1] == 0:
                        i += 1
                        continue
                    price_dict[max_price][i][1] -= 1
                    totalShares -= 1
                    i += 1
                    y -= 1
            else:
                y = totalShares % len(price_dict[max_price])
                i = 0
                while y > 0 and i < len(price_dict[max_price]):
                    price_dict[max_price][i][1] -= 1
                    totalShares -= 1
                    i += 1
                    y -= 1
                for j in range(i, len(price_dict[max_price]) - 1):
                    output.append(price_dict[max_price][i][0])

            price_dict.pop(max_price)

    for key in price_dict:
        for i in range(0, len(price_dict[key])):
            output.append(price_dict[key][i][0])

    return output


# print(getUnallottedUsers([
#     [1, 5, 5, 0],
#     [2, 7, 8, 1],
#     [3, 7, 5, 1],
#     [4, 10, 3, 3]
# ], 18))

from datetime import datetime
class HashTable:
    def _init_(self, rawEvents):
        self.hwm = datetime.utcfromtimestamp(0)
        self.hashtable = dict()
        for i in rawEvents:
            query = i.split('|')
            self.operate_HT(query)

    def operate_HT(self,query):
        if query[1] == 'INSERT':
            self.insert(query[2],query[3])
        elif query[1] == 'UPSERT':
            self.upsert(query[2], query[3])
        elif query[1] == 'DELETE':
            self.delete(query[2])
        x = int(query[0])/1000
        self.hwm = datetime.utcfromtimestamp(x)

    def insert(self,key,value):
        if key not in self.hashtable:
            self.hashtable[key] = value
    def upsert(self,key, value):
        self.hashtable[key] = value

    def delete(self,key):
        if key in self.hashtable:
            self.hashtable.pop(key)
    def table(self):
        return self.hashtable

    def high_watermark(self):
        return self.hwm

# h = HashTable([
#     '1563454984001|INSERT|test|123',
#     '1563454984002|UPSERT|test|123',
#     '1563454984003|DELETE|test'])
# print(h.table())
# print(h.high_watermark())
import codecs
def Akuna_12(s):
    a = []
    a.append(str(int(s[:16],16)))
    if int(s[16:18],16) == 0:
        a.append("INSERT")
    elif int(s[16:18],16) == 1:
        a.append("UPSERT")
    if int(s[16:18],16) == 2:
        a.append("DELETE")
    key_length = int(s[18:22],16)
    key_length = (key_length*2)
    key_value = codecs.decode(s[22:22+key_length],"hex")
    key_value = str(key_value)
    key_value = key_value.replace("b'",'')
    key_value = key_value.replace("'","")
    a.append(key_value)
    # value_length = int(s[22 + key_length:22+ key_length+4],16)
    value_length = 22+ key_length+4
    value_value = str(codecs.decode(s[value_length:],"hex"))
    value_value = value_value.replace("b'",'')
    value_value = value_value.replace("'","")
    a.append(value_value)
    return a
s = '0000016c052dcf4101000d746573745f6b65795f313233340012746573745f76616c75655f31323339393038'

def bytes_to_int(bytes):
    result = 0
    for b in bytes:
        result = result * 256 + int(b)
    return result
def someFunc():
    a = b'\x00\x00\x01l\x05-\xcfA\x00\x00\x0etest_key_09812\x00\x10test_value 12876'
    res = []
    #st = '\x00\x00\x01l\x05-\xcfA\x00\x00\x0etest_key_09812\x00\x10test_value 12876'
    epoch = bytes_to_int(a[:8])
    res.append(str(epoch))
    msg_id = bytes_to_int(a[8:9])
    msg_id = bytes_to_int(a[8:9])
    if msg_id == 0:
        res.append("INSERT")
    elif msg_id == 1:
        res.append("UPSERT")
    if msg_id == 2:
        res.append("DELETE")
    key_length = bytes_to_int(a[9:11])
    #res.append(key_length)
    key_value = a[11:11+key_length].decode('utf-8')
    res.append(key_value)
    value_length = bytes_to_int(a[25:27])
    #res.append(value_length)
    value_string = a[27:43].decode('utf-8')
    res.append(value_string)
    print(res)
    x= '|'.join(res)
    print(x)

#-----------------------Medha Akuna--------------------------

class PathCalculator:
    distance = {}  # dictionary that maintains distance between cities

    def process(self, line: str) -> str:

        possible_route = {}  # dictianery that maintains distance if there is possibility of two ticket route

        city1, city2, dis = list(line.split(':'))
        if not city1 in self.distance:  # Updating distance with respect to city1
            self.distance[city1] = {}
        self.distance[city1][city2] = int(dis)

        if not city2 in self.distance:  # Upadting distance with respect to city2
            self.distance[city2] = {}
        self.distance[city2][city1] = int(dis)

        for start_city in self.distance:  # Checking two ticket distance for each city
            d = self.distance[start_city]
            inter_city = max(d.keys(), key=(lambda k: d[k]))
            d = self.distance[inter_city]
            final_city = max(d.keys(), key=(lambda k: d[k]))
            if start_city != final_city:
                total_dis = self.distance[start_city][inter_city] + self.distance[inter_city][final_city]
                if start_city > final_city:
                    start_city, final_city = final_city, start_city
                if possible_route.get(total_dis):
                    if possible_route[total_dis] > (start_city, inter_city, final_city):
                        possible_route[total_dis] = (start_city, inter_city, final_city)
                else:
                    possible_route[total_dis] = (start_city, inter_city, final_city)
        print(self.distance)
        print(possible_route)
        if possible_route == {}:
            return "NONE"
        else:
            max_dis = max(possible_route)
            c1, c2, c3 = possible_route[max_dis]
            return ':'.join([str(max_dis),c1,c2,c3])
# ob=PathCalculator()
# l1='AAA:NYC:200'
# l2='CHI:AUS:200'
# l3='NYC:AUS:1000'
# l4='NYC:HAWAII:4393'
# l5='CHI:AUS:719'
# l6='AUS:LA:2414'
# print(ob.process(l1))
# print(ob.process(l2))
# print(ob.process(l3))
# print(ob.process(l4))
# print(ob.process(l5))
# print(ob.process(l6))

# ob=PathCalculator()
# l1='CHI:NYC:719'
# l2='NYC:LA:2414'
# l3='NYC:SEATTLE:2448'
# l4='NYC:HAWAII:4924'
# ob.process(l1)
# ob.process(l2)
# ob.process(l3)
# ob.process(l4)

# def prefixString(a,b):
#     pString = [a[0]]
#     for i in range(1,len(a)):
The file all_akuna_2.py contains:

def getEventsOrder(team1, team2, events1, events2):
    # Write your code here
    football = list()
    football.append({"team": team1, "event": events1})
    football.append({"team": team2, "event": events2})

    game_details_list = list()
    original_event = list()
    event_priority = ['G', 'Y', 'R', 'S']

    for f in football:
        for event in f["event"]:
            original_event.append(f["team"] + " " + event)

            # split events string to get details
            pattern = re.compile("([a-zA-Z\s])(\d+)[+]?(\d).([G,Y,R,S])([a-zA-Z\s]*)")
            split_event = pattern.search(event)

            # create a list of format ["team name", "player name", "time", "extra time", "event", "second player name"]
            record = list()
            record.append(f["team"])  # team name
            if split_event:
                record.append(split_event.group(1).strip())  # player name
                record.append(int(split_event.group(2).strip()))  # time
                record.append(
                    int(split_event.group(3).strip()) if len(split_event.group(3).strip()) > 0 else 0)  # extra time
                record.append(event_priority.index(split_event.group(4).strip()))  # event
                record.append(split_event.group(5).strip())  # second player
            game_details_list.append(record)

    # sorting the list to return index position of the sorted list
    new_num_index_sorted = (sorted(range(len(game_details_list)),
                                   key=lambda k: (
                                       game_details_list[k][2],  # time
                                       game_details_list[k][3],  # extra time
                                       game_details_list[k][4],  # event
                                       game_details_list[k][0],  # team name
                                       game_details_list[k][1],  # player name
                                       game_details_list[k][5])))

    # based on the index position, fetching result from original event list and appending in answer
    answer = list()
    for i in new_num_index_sorted:
        answer.append(original_event[i])
    return answer
# team1 = 'ABC'
# team2 = 'CBA'
# events1 = ['Mo Sa 45+2 Y','A 13 G']
# events2 = ['D 23 S F', 'Z 46 G']
# print(getEventsOrder(team1,team2,events1,events2))
# print(getEventsOrder("nolh","nzrdrrc",["inmuucz jzbkica 70 Y","ton wfnt 10 S inmuucz jzbkica","ecya kqvqy 20 S fkfk fuiyb senmofw"],["mysior pqfcz bxlnpn 49 G","mysior pqfcz bxlnpn 18 G","enc otagavd oevfg 86 Y"]))
# def minNum(A,n):
#     previous_letter_status, no_of_unread_letters, no_of_unread_segments = 0, 0, 0
#     for i in range(0,n):
#         if A[i] == 1:
#             no_of_unread_letters += 1
#         if previous_letter_status == 0 and A[i] == 1:
#             no_of_unread_segments += 1
#
#         previous_letter_status = A[i]
#
#     no_of_operations = no_of_unread_letters + max(no_of_unread_segments-1,0)
#     print(no_of_operations)
# minNum([0,0],2)

# int findCombination(int n, int min, int max)
# {
# 	long result = 0;
# 	unordered_map<int, int> m;
# 	for (int i = min; i <= max; i++)
# 	{
# 		for (int j = min; j <= max; j++)
# 		{
# 			if (std::gcd(i, j) == 1)
# 				m[i]++;
# 		}
# 	}
# 	auto iter = m.begin();
# 	while (iter != m.end())
# 	{
# 		result += pow(iter->second, n - 1);
# 		iter++;
# 	}
# 	return result;
# }
# import math
# def findCombination(rotorCount,minRotorValue,maxRotorValue):
#     result = 0
#     map = dict()
#     for i in range(minRotorValue,maxRotorValue+1):
#         if i % 2 == 0:
#             flag = True
#         else:
#             flag = False
#         for j in range(minRotorValue,maxRotorValue+1):
#             if j % 2 == 0 and flag:
#                 continue
#             if math.gcd(i,j) == 1:
#                 if i in map:
#                     map[i] += 1
#                 else:
#                     map[i] = 1
#     print(map)
#     for i in map:
#         result += map[i] ** (rotorCount-1)
#     return result

# print(findCombination(3,2,6))
import networkx
from networkx import (
    draw,
    DiGraph,
    Graph,
)
# def minOperations(n,fro,to):
#     undirected = Graph()
#     undirected.add_edges_from(list(zip(fro, to)))
#     for i in range(1,n+1):
#         if i not in undirected.nodes():
#             undirected.add_node(i)
#     # print(undirected.nodes())
#     # draw(undirected, with_labels=True)
#     nCC = networkx.number_connected_components(undirected)
#     s = networkx.connected_components(undirected)
#     s = (list(s))
#     H = 0
#     for i in range(len(s)):
#         h = undirected.subgraph(list(s[i]))
#         H += (len(h.edges()) - len(s[i]) + 1)
#     if H >= nCC - 1:
#         print(nCC-1)
#     else:
#         print(-1)
# n = 4
# fro = [1,3]
# to = [2,4]

# # minOperations(n,fro,to)
# import operator as op
# def reduce_values(d):
#     for i in d:
#         d[i] -= 10
#     return d
# def minimum(s):
#     res = 0.0
#     gumDict = dict()
#     for i in s:
#         if i in gumDict:
#             gumDict[i] = 1000
#         else:
#             if len(gumDict) > 2:
#                 s = min(gumDict.items(), key=op.itemgetter(1))
#                 gumDict.pop(s[0])
#                 res += s[1]/100
#             gumDict[i] = 1000
#         gumDict = reduce_values(gumDict)
#     return float(round(res,1))
#
# minimum(['red','red'])








class PathCalculator:
    # You may enter code here.

    distance = {}  # dictionary that maintains distance between cities

    def process(self, line: str) -> str:
        if line == None:
            return "NONE"
        possible_route = {}
        flag1, flag2 = False, False
        city1, city2, dis = list(line.split(':'))
        if city1 not in self.distance:
            self.distance[city1] = {}
            flag1 = True
        self.distance[city1][city2] = int(dis)

        if city2 not in self.distance:
            self.distance[city2] = {}
            flag2 = True
        self.distance[city2][city1] = int(dis)
        if flag1 and flag2:
            return "NONE"
        for start_city in self.distance:
            d = self.distance[start_city]
            # print(d.keys())
            for inter_city in d:
                d1 = self.distance[inter_city]

                final_city = max(d1.keys(), key=(lambda k: d1[k]))
                if start_city != final_city and (inter_city in self.distance[start_city]):

                    total_dis = self.distance[start_city][inter_city] + self.distance[inter_city][final_city]
                    if start_city > final_city:
                        start_city, final_city = final_city, start_city
                    if total_dis in possible_route:
                        start_city_old = possible_route[total_dis][0]
                        if start_city_old > start_city:
                            possible_route[total_dis] = (start_city, inter_city, final_city)
                    else:
                        possible_route[total_dis] = (start_city, inter_city, final_city)
        print(self.distance)
        if possible_route == {}:
            return "NONE"
        else:
            max_dis = max(possible_route)
            c1, c2, c3 = possible_route[max_dis]
            return ':'.join([str(max_dis), c1, c2, c3])

# ob=PathCalculator()
# l1='AUS:CHI:200'
# l2='AUS:SEATTLE:100'
# l3='NYC:CLT:100'
# l4='NYC:AUS:4393'
# l5='CHI:AUS:719'
# l6='AUS:LA:2414'
# print(ob.process(l1))
# print(ob.process(l2))
# print(ob.process(l3))
#print(ob.process(l4))
# class PathCalculator:
#     city = dict()
#     def process(self,path):
#         path = path.split(':')
#         if path[0] in self.city:
#             self.city[path[0]][path[1]] = path[2]
#         else:
#             self.city[path[0]] = {path[1]:path[2]}
#
#         if path[1] in self.city:
#             self.city[path[1]][path[0]] = path[2]
#         else:
#             self.city[path[1]] = {path[0]:path[2]}
#
#         if path[0]
#

# ob=PathCalculator()
# l1='AUS:CHI:200'
# l2='AUS:SEATTLE:100'
# l3='NYC:CLT:100'
# l4='NYC:AUS:4393'
# ob.process(l1)
# ob.process(l2)
# # ob.process(l3)
# # ob.process(l4)
# print(ob.city)




# public static int balancedSum(List<Integer> sales) {
#     // Write your code here
# 		int sum =0;
#         for(int i=0;i<list.size();i++){
#             sum += list.get(i);
#         }
#         int curr =list.get(0);
#         for(int i=1;i<list.size();i++){
#             if(curr == sum - curr - list.get(i)){
#                 return i;
#             }
#             curr += list.get(i);
#         }
#         return -1;
#     }
# def balancedSum(s):
#     sum = 0
#     for i in s:
#         sum += i
#     x = s[0]
#     for i in range(1,len(s)):
#         if x == (sum - x - s[i]):
#             return i
#         x += s[i]
#     return -1
# print(balancedSum([1,2,3,4,6]))
from collections import Counter as c
# Print subarray between
# current starting
# and ending points

# a = [25,35,872,228,53,278,872]
# for i in range(len(a)):
#     a[i] = "".join(sorted(str(a[i])))
# pair ={}
# count=0
# for i in range(len(a)):
#     if a[i] in pair:
#         pair[a[i]] +=1
#     else:
#         pair[a[i]] =1
# for keys in pair.keys():
#     count+= pair[keys]*(pair[keys]-1) //2
# print(count)


# import collections
# def anagram(a,b):
#     count = 0
#     if len(a) != len(b):
#         return -1
#
#     dic = collections.Counter(a)
#
#     for i in b:
#         if i in dic:
#             if dic[i]:
#                 dic[i] -= 1
#             else:
#                 count += 1
#         else:
#             count += 1
#     return count

# def getMinimumDifference(a,b):
#     res = []
#     for i,j in zip(a,b):
#         res.append(anagram(i,j))
#     return res

# def traverse(a,s,i,j):
#     if a[i][j] != s:
#         return False
#     if i < len(a)-1 and j < len(a[i])-1 and i>-1 and j>-1:
#         traverse(a,s,i+1,j)
#         traverse(a,s,i,j+1)
#         traverse(a,s,i-1,j)
#         traverse(a,s,i,j-1)
# def prime_count():
#     s = "CABa"
#     Hset = {67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113}
#     s = list(s)
#     asc = []
#     for i in s:
#         asc.append(ord(i))
#     print(asc)
#     for i in range(len(asc)):
#         j = 1
#         while True:
#             if asc[i] in Hset:
#                 asc[i] = chr(asc[i])
#                 break
#             if asc[i]-j in Hset:
#                 asc[i] = chr(asc[i]-j)
#                 break
#             elif asc[i]+j in Hset:
#                 asc[i] = chr(asc[i]+j)
#                 break
#             j+=1
#     print(asc)
#
#
# def solve(a, n, m):
#     # s = set()
#     # for i in range(len(a)):
#     #     for j in a[i]:
#     #         if j not in s:
#     #             s.add(j)
#     for i in range(n):
#         for j in range(m):
#             print(traverse(a,a[i][j],i,j))
#     # print(s)
#
#
# c = [
#     ['B','B','B','B','B','B','B'],
#     ['B','G','G','G','G','B','B'],
#     ['B','G','B','B','G','B','B'],
#     ['B','G','B','B','G','B','B'],
#     ['B','G','G','G','G','B','B'],
#     ['B','B','B','B','B','B','B']
# ]
# def color_loop(n,m,mat):
#     for i in range(0,n):
#         for j in range(0,m):
#             c = mat[i][j]
#             for k in range(j+1,m):
#                 if mat[i][k] != c:
#                     break
#             k-=1
#             if k>j:
#                 for l in range(i+1,n):
#                     if mat[l][k] != c:
#                         break
#                 l-=1
#                 if l>i:
#                     p=k
#                     while p >= j:
#                         if mat[l][p] != c:
#                             break
#                         p -= 1
#                     p+=1
#                     if p == j:
#                         q=l
#                         while q >= i:
#                             if mat[q][p] != c:
#                                 break
#                             q-=1
#                         q+=1
#                         if q==i:
#                             return True
#     return False
# print(color_loop(len(c),len(c[0]),c))

# s = "ab12c"
# t = "1zz456"
# def removeOneDigit(s,t):
#     sList = list(s)
#     tList = list(t)
#     count = 0
#     for i in range(len(tList)):
#         tl = tList.copy()
#         if tList[i].isdigit():
#             tl.pop(i)
#             if s < ''.join(tl):
#                 count+=1
#
#     for i in range(len(sList)):
#         sl = sList.copy()
#         if sList[i].isdigit():
#             sl.pop(i)
#             if ''.join(sl) < t:
#                 count+=1
#     return count

s = "123456 ab-cd+ef"
a = s.split(' ')[0]
b = s.split(' ')[1]
result = 0
sign = '+'
word_before_operator = ""
j=0

for i in range(len(b)):
    if b[i] == '+':
        if sign == '+':
            result += int(word_before_operator)
        elif sign == '-':
            result -= int(word_before_operator)
        sign = '+'
        word_before_operator = ""
    elif b[i] == '-':
        if sign == '+':
            result += int(word_before_operator)
        elif sign == '-':
            result -= int(word_before_operator)
        sign = '-'
        word_before_operator = ""
    else:
        word_before_operator += a[j]
        j+=1
if sign == '+':
    result += int(word_before_operator)
elif sign == '-':
    result -= int(word_before_operator)
print(result)
The file amazonMock.py contains:
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def mergeKLists(self, lists):
        def mergeTwo(l1,l2):
            dummyNode = head = ListNode(0)
            while l1 and l2:
                if l1.val>l2.val:
                    dummyNode.next = l2
                    l2 =l2.next
                else:
                    dummyNode.next = l1
                    l1 = l1.next
                dummyNode = dummyNode.next

            if l1:
                dummyNode.next = l1
            elif l2:
                dummyNode.next = l2
            return head.next
        if len(lists)==0:
            return 0
        while len(lists)>1:
            l1 = lists.pop(0)
            l2 = lists.pop(0)
            lists.append(mergeTwo(l1,l2))

        return lists[0]












        '''
        temp = []
        for i in range(len(lists)):
            l1 = lists[i]
            while l1:
                temp.append(l1.val)
                l1 = l1.next

        temp.sort()

        dummyNode = head = ListNode(0)

        for i in range(len(temp)):
            dummyNode.next = ListNode(temp[i])
            dummyNode = dummyNode.next

        return head.next
        '''




The file Anagram_Difference.py contains:

import collections
def anagram(a,b):
    count = 0
    if len(a) != len(b):
        return -1

    dic = collections.Counter(a)

    for i in b:
        if i in dic:
            if dic[i]:
                dic[i] -= 1
            else:
                count += 1
        else:
            count += 1
    return count
a = 'abc'
b = 'def'
x = ['a','jk','abb','mn','abc']
y = ['bb','kj','bbc','op','def']
print(anagram(a,b))
for i in range(len(x)):
    print(anagram(x[i],y[i]))
#print(anagram(x,y))
The file appendZeroAtEnd.py contains:
def appendZeroAtEnd(arr):
    #temp = [1,0,2,3,0,4,5]
    ptr  = 0
    for i in range(len(arr)):
        if arr[i]!=0:
            arr[ptr]=arr[i]
            ptr+=1
    for i in range(ptr,len(arr)):
        arr[i] = 0
    print(arr)


if __name__ == '__main__':
    arr = [1,0,2,3,0,4,5]
    arr1 = [0, 2, 3, 0, 4, 5]
    arr2 = []
    arr3 = [0, 0, 0, 0]
    appendZeroAtEnd(arr)
    appendZeroAtEnd(arr1)
    appendZeroAtEnd(arr2)
    appendZeroAtEnd(arr3)


The file Array_Journey.py contains:
def journey(arr, k):
    sum = 0
    length = len(arr)
    end = length
    i = 0
    max = 0
    flag = 0
    ind = -1
    while (i < length):
        if (arr[i] >= 0):
            sum += arr[i]
        else:
            temp = i + k
            max = -9999
            ind = -1
            for j in range(i, temp):
                if (j < length):
                    if (arr[j] >= 0):
                        i = j
                        sum += arr[j]
                        flag = 1
                        break;
                    else:
                        if (arr[j] > max):
                            max = arr[j]
                        ind = j
                else:
                    break
            if (flag == 0):
                sum += max
                i = ind
        i += 1
    return sum


def journey1(path, k):
    d = {}

    def helper(path, k, i):
        if i >= len(path):
            return 0
        allPresent = True
        t = [x for x in range(i + 1, i + k + 1)]
        for x in t:
            if x not in d:
                allPresent = False
        if allPresent:
            maxi = 0
            for x in t:
                if d[x] > maxi:
                    maxi = d[x]
            return maxi
        else:
            maxi = 0
            for x in t:
                temp = path[i] + helper(path, k, x)
                if temp > maxi:
                    maxi = temp
            d[i] = maxi
            return maxi

    return helper(path, k, 0)

#arr = [10,2,-10,5,20]
#arr = [10,-20,-5]
arr = [3,-4,-3,-5,0]
k = 2
print("The array is:",arr)
print("The value of the k is:",k)
print("Maximu score achievable is:",journey(arr,2))
The file Ascending_Binary_Sorting.py contains:
count_1 ={}
answer = []
a = [5,3,10,7,14]
for i in range(len(a)):
    m = bin(a[i])[2:].count('1')
    if m not in count_1:
        count_1[m] = []
    count_1[m].append(a[i])
for k in sorted(count_1.keys()):
    count_1[k].sort()
    for inp in count_1[k]:
        answer.append(inp)

print(answer)


The file balancedSalesArray.py contains:
def getBalancedIndex(sales):
    sumAsc = [0] * len(sales)
    sumDesc = [0] * len(sales)
    for i in range(len(sales)):
        if i ==0:
            sumAsc[i] = sales[i]
        else:
            sumAsc[i] = sumAsc[i-1]+ sales[i]

    for i in range(len(sales)-1, -1, -1):
        if i == len(sales) -1:
            sumDesc[i] = sales[i]
        else:
            sumDesc[i] = sumDesc[i+1] + sales[i]

    for i in range(len(sales)):
        if sumAsc[i] == sumDesc[i]:
            return i
    return -1

print(getBalancedIndex([1,2,3,3]))
print(getBalancedIndex([3,1,2,1]))


The file balanceParanthesis.py contains:
def validParanthesis(s):
    d  ={"(":")","[":"]","{":"}"}
    stack =[]

    for i in range(len(s)):
        if stack:
            if stack[-1] in d and d[stack[-1]]==s[i]:
                stack.pop(-1)
            else:
                stack.append(s[i])
        else:
            stack.append(s[i])

    if stack:
        return False
    return True


if __name__ == '__main__':
    print(validParanthesis("("))
The file balancingElements.py contains:
def balancingElements(arr):
    print("-----------------------------")
    print(arr)
    n = len(arr)
    odd = 0
    even =0
    leftOdd= [0]*len(arr)
    leftEven = [0] * len(arr)
    rightOdd = [0]*len(arr)
    rightEven = [0]*len(arr)
    for i in range(n):
        print(i,arr[i])
        leftOdd[i] = odd
        leftEven[i] = even
        if i%2==0:
            even+=arr[i]
        else:
            odd+=arr[i]
        #print("Left Odd", leftOdd, "Left Even", leftEven)
    odd = 0
    even= 0
    for i in range(n-1,-1,-1):
        rightOdd[i] = odd
        rightEven[i] = even

        if i%2==0:
            even+=arr[i]
        else:
            odd+=arr[i]

    count = 0
    print("Left Odd",leftOdd,"Left Even",leftEven)
    print("Right Even", rightEven, "Right Odd", rightOdd)
    for i in range(n):
        if leftOdd[i]+rightEven[i] == leftEven[i]+rightOdd[i]:
            #print("Remove index:- ",i)

            #print("Remove character:- ", arr[i])
            count+=1

    print(count)



if __name__ == '__main__':
    num1 = [5,5,2,5,8]
    num2 = [2,2,2]
    num3 = [2, 1,6,4]
    balancingElements(num1)
    balancingElements(num2)
    balancingElements(num3)


The file basics.py contains:
import copy
a = [1,2,3,4,5,6,7]
#print(id(a),a)
############# Pass by Reference ############
print("................Pass by Reference..............")
def updateList(list1):
    list2 = list1
    list2 += [10]
n = [5, 6]
print(id(n))                  # 140312184155336
updateList(n)
print(n)                      # [5, 6, 10]
print(id(n))                  # 140312184155336

############# Pass by Value ############
print("................Pass by Value..............")
def updateNumber(n):
    n += 10
b = 5
print(id(b))                   # 10055680
updateNumber(b)                # 10055680
print(b)

########### Tuple ##########
##### Tuples are IMUTABLE #####
##### The “value” of an immutable object can’t change, but it’s constituent objects can #####
print("................ Tuple ..............")
a = [1,2,3]
x = "Sumedh"
t = (x,a)
print(t)
a.append(4)
print(t)















####### References ########
#https://medium.com/@meghamohan/mutable-and-immutable-side-of-python-c2145cf72747
The file bestSquare_find_sum_of_all_squares_of_size_kxk.py contains:
from collections import defaultdict
def printSumSimple(mat, k):
    n = len(mat)
    m = len(mat[1])
    if (k > n):
        return
    dic = defaultdict(list)
    for i in range(n - k + 1):
        for j in range(m - k + 1):
            l = []
            sum1 = 0
            for p in range(i, k + i):
                for q in range(j, k + j):
                    sum1 += mat[p][q]
                    l.append(mat[p][q])
            dic[sum1].extend(l)
    res = dic[max(dic.keys())]
    unique = set(res)
    print(sum(unique))







# Driver Code
if __name__ == "__main__":

    mat = [[1, 0, 1, 5, 6],
           [3, 3, 0, 3, 3],
           [2, 9, 2, 1, 2],
           [0, 2, 4, 2, 0]
           ]

    '''    mat = [[1, 1, 1, 1, 1],
               [2, 2, 2, 2, 2],
               [3, 3, 3, 3, 3],
               [4, 4, 4, 4, 4],
               [5, 5, 5, 5, 5]]
    '''

    k = 2
    printSumSimple(mat, k)
The file binaryAutocomplete.py contains:
from collections import defaultdict
from operator import  itemgetter

def binaryAutocomplete(command):
    res= []
    res.append(0)
    for i in range(1,len(command)):
        #print("_________________________________")
        temp = command[i]
        latest = -1
        initialK = 0
        for j in range(i-1,-1,-1):
            flag = True
            k = 0
            l =0
            #print("Comparing: - ",i,j,command[i],command[j])
            while flag:
                #print(k,initialK)
                if k<len(command[j]) and l<len(command[i]) and command[j][k]==command[i][l]:
                    #print("------")
                    #print("Checking: - ",command[j][k], command[i][l])
                    k+=1
                    l+=1
                else:
                    flag = False
            #print(k,initialK)
            if k>initialK:
                initialK = k
                latest = j
                #print("k,InitiaK",k,initialK,"Index: - ", latest + 1)
        if latest==-1:
            res.append(i)
        else:
            res.append(latest+1)
    print(res)


class Trie:
    def __init__(self):
        self.d ={}
        self.index= []

class sol:
    def indexing(self,arr):
        print("----"*40)
        root = Trie()
        res=defaultdict(list)
        final = []

        for id,elem in enumerate(arr):
            trie = root
            level = 0
            for char in elem:
                level+=1
                if char not in trie.d:
                    trie.d[char] = Trie()
                #print(trie.d.items())
                #print(trie.index)
                trie = trie.d[char]
                trie.index.append((id,level))
                #trie.index.append((id,elem))

        originalRoot = root

        for elem in arr:
            root = originalRoot
            for j in elem:
                if root:
                    root = root.d.get(j)
                    if root:
                        res[elem].extend(root.index)


        for k,v in res.items():
            res[k] = sorted(list(set(v)),key=lambda x: (x[1],x[0]),reverse=True)

        for i in range(len(arr)):
            temp = res[arr[i]]
            flag = False
            for j in range(len(temp)):
                if temp[j][0]<i:
                    #print("Candidates: -",temp[j])
                    final.append(temp[j][0]+1)
                    flag = True
                    break
            if not flag:
                final.append(i)
        print(res)
        print("Final Output: -",final)




if __name__ == '__main__':
    #binaryAutocomplete(["000","1110","01","001","110","11"])
    #binaryAutocomplete(["100110","1001","1001111"])
    #binaryAutocomplete(["1","10","11010"])


    s = sol()
    s.indexing(["000","1110","01","001","110","11"])
    s.indexing(["100110","1001","1001111"])
    s.indexing(["1","10","11010"])


The file binaryPatterMatching.py contains:
#s = "amazing"
#pattern = "010"
s = "codesignal"
pattern  = "100"
s = list(s)
vowel = ['a','e','i','o','u','y']
def occurrences(string, sub):
    count = start = 0
    while True:
        start = string.find(sub, start) + 1
        if start > 0:
            count+=1
        else:
            return count
for i in range(len(s)):
    if s[i] in vowel:
        s[i] = "0"
    else:
        s[i]="1"
s =''.join(map(str, s))
print(s,pattern)
print(occurrences(s,pattern))


The file borderSort.py contains:
def matrix(x):
    n = len(x)
    temp = []
    for i in range(n):
        for j in range(n):
            if i==0 or j==0 or i==n-1 or j==n-1:
                temp.append(x[i][j])



if __name__ == '__main__':
    x = [[9,7,4,5],[1,6,2,-6],[12,20,2,0],[-5,-6,7,-2]]
    print(len(x))
    matrix(x)



The file breadth_first_search.py contains:
class Node:
    def __init__(self,root):
        self.val = root
        self.left = None
        self.right = None

class bfs:
    res = []
    def traverse(self,r):
        queue = []
        if r:
            queue.append(r)
        while len(queue)>0:
            data = queue.pop(0)
            self.res.append(data.val)
            if data.left:
                queue.append(data.left)
            if data.right:
                queue.append(data.right)

        return self.res

if __name__ == '__main__':
    root = Node(1)
    root.left = Node(2)
    root.right = Node(3)
    root.left.left = Node(4)
    root.left.right = Node(5)
    traverse = bfs()
    print(traverse.traverse(root))

The file bst_sum_of_nodes.py contains:

class Node:
    def __init__(self,root):
        self.left = None
        self.val = root
        self.right = None

class traverse:
    def sumOfNodes(self,r):
        res = 0
        if r:
            res+=self.sumOfNodes(r.left)+r.val+self.sumOfNodes(r.right)

        print("--------", res)
        return res

    def recursive(self,r):
        def helper(r,res):
            if r:
                helper(r.left, res)
                res.append(r.val)
                helper(r.right,res)
        res =[]
        helper(r,res)
        return res

    def iterative(self,r):
        queue = []
        res =[]
        if r:
            queue.append(r)
        while queue:
            data = queue.pop(0)
            res.append(data.val)
            if data.left:
                queue.append(data.left)
            if data.right:
                queue.append(data.right)

        return res

if __name__ == '__main__':
    op =[]
    root = Node(1)
    root.left = Node(2)
    root.right = Node(3)
    root.left.left = Node(4)
    root.left.right = Node(5)
    root.right.left = Node(6)
    root.right.right = Node(7)
    root.right.left.left = Node(8)
    tr = traverse()
    #op = tr.sumOfNodes(root.right)
    #print(op)

    #print(tr.recursive(root))
    print(tr.iterative(root))
The file calculateCoffeeStats.py contains:
import collections
def calculate_coffee_stats(office_stats_list):
    d = collections.defaultdict(dict)
    op = []
    for i in range(len(office_stats_list)):
        office_stats_list[i] = office_stats_list[i].replace("\r","")
        temp = office_stats_list[i].split(',')
        j = 0
        if temp[j] in d:
            d[temp[j]] [temp[j + 1]] = temp[j + 2]
        else:
            d[temp[j]] = {temp[j+1]:temp[j+2]}

    #print(d)
    for k,v in d.items():
        t = ""
        t+=k
        avg  =0
        for j,l in v.items():
            avg  = avg + int(l)
        t+=","+(str(avg))
        t+=","+(str(avg//len(v)))
        op.append(t)
    return op


if __name__ == '__main__':
    #l = ['Auc,Aug,9160','Auc,Jan,9160','Auc,Feb,9160']
    '''
    l = ['Auckland,Jan,9160','Auckland,Feb,5640', 'Auckland, Mar, 2323',
         'Auckland, Apr, 3214',
         'Auckland,May, 5645',
         'Auckland, Jun, 5678',
         'Auckland,Jul, 4175',
         'Auckland,Aug, 2020',
         'Auckland,Oct, 9823',
         'Auckland,Nov, 6540',
         'Auckland,Dec, 2563']
    '''

    l = ['Auckland, Jan, 9160',
         'Auckland, Feb, 5640',
         'Auckland, Mar, 2323',
         'Auckland, Apr, 3214',
         'Auckland, May, 5645',
         'Auckland, Jun, 5678',
         'Auckland, Jul, 4175',
         'Auckland, Aug, 2020',
         'Auckland, Oct, 9823',
         'Auckland, Nov, 6540',
         'Auckland, Dec, 2563',
         'Wellington, Jan, 5678',
         'Wellington, Feb, 4175',
         'Wellington, Mar, 2020',
         'Wellington, Apr, 9823',
         'Wellington, May, 6540',
         'Wellington, Jun, 2563',
         'Wellington, Jul, 9160',
         'Wellington, Aug, 5640',
         'Wellington, Oct, 2323',
         'Wellington, Nov, 3214',
         'Wellington, Dec, 5645']


print(calculate_coffee_stats(l))

The file canMakeTriangle.py contains:
def canMakeTriangle(arr):
    res = []
    for  i in range(len(arr)-2):
        if arr[i]+arr[i+1]>arr[i+2] and arr[i]+arr[i+2]>arr[i+1] and arr[i+1]+arr[i+2]>arr[i]:
            res.append(1)
        else:
            res.append(0)
    return res

if __name__ == '__main__':
    print(canMakeTriangle([1,2,2,4]))
    print(canMakeTriangle([2,10,2,10,2]))
    #print(canMakeTriangle([1000000000,])
The file can_make_palindrome.py contains:
import  collections
def canMakePaliQueries(s, l,r,k):
    queries=[]
    for i in range(len(l)):
        queries.append([l[i],r[i],k[i]])

    print(queries)
    N = 26
    S = len(s) + 1
    ints = list(map(lambda c: ord(c) - ord('a'), s))

    dp = [0] * S
    for i in range(1, S):
        dp[i] = dp[i-1] ^ (1 << ints[i-1])

    ones = lambda x: bin(x).count('1')
    return str(''.join(map(str,[
        int(ones(dp[r+1] ^ dp[l]) >> 1 <= k)
        for l, r, k in queries
    ])))


def canMakePaliQueries_2(s,queries):
    odds = [[False] * 26]
    for i, c in enumerate(s):
        odds.append(odds[i][:])
        odds[i + 1][ord(c) - ord('a')] ^= True
    return [sum(odds[hi + 1][i] ^ odds[lo][i] for i in range(26)) // 2 <= k for lo, hi, k in queries]


#print(canMakePaliQueries("bcba",1,2,1))
#print(canMakePaliQueries("bcba",[1,2,1],[3,3,1],[2,0,0]))
print(canMakePaliQueries("bcbab",[1,1,2],[4,3,3],[3,3,0]))
#print(canMakePaliQueries_2("bcba",[[1,3,2],[2,3,0],[1,1,0]]))
The file cerealSegment.py contains:
def cerealSegment(x,arr):
    b = []
    for i in range(len(arr)-x+1):
        v = []
        for j in range(i,i+x):
            v.append(arr[j])
        v = sorted(v)
        b.append(v[0])
    b = sorted(b,reverse=True)
    print(b[0])

if __name__ == '__main__':
    arr = [8, 2, 4]
    cerealSegment(2,arr)



The file check_balanced.py contains:
def balancedOrNot(expressions, maxReplacements):
    return_array = []
    for i in range(0, len(maxReplacements)):
        return_array.append(0)

    for count, each_data in enumerate(expressions):
        check_str = expressions[count]
        replacement_count = 0

        continue_loop = True
        while len(check_str) >= 1 and continue_loop:
            opening_count = check_str.count('<')
            closing_count = check_str.count('>')

            if opening_count > closing_count:
                replacement_count = maxReplacements[count] + 1
                continue_loop = False
            elif check_str[0] == '>':
                replacement_count += 1
                check_str = check_str[1:]
            else:
                check_str = check_str.replace('<>', '')

        if replacement_count <= maxReplacements[count]:
            return_array[count] = 1

    return return_array


print(balancedOrNot(expressions=["<>", "<<><>>"], maxReplacements=[0, 0]))  # [1,0]
print(balancedOrNot(expressions=["<>>>", "<>>>>"], maxReplacements=[2, 2]))  # [1,0]
print(balancedOrNot(expressions=["<>", "<>><"], maxReplacements=[2, 2]))  # [1, 0]
print(balancedOrNot(expressions=["<<<>", "<<><><"], maxReplacements=[2, 2]))  # [0,0]

print(balancedOrNot(expressions=["<<<>>>", "<>"], maxReplacements=[2, 2]))  # [0,1]
print(balancedOrNot(expressions=["<<><>>", "<><>"], maxReplacements=[2, 2]))  # [0,1]

print(balancedOrNot(expressions=["<<><>><", "><><><"], maxReplacements=[2, 2]))  # [0,0]
The file circularArray.py contains:
import operator
from collections import Counter

def prints(a, n, ind,end):
    visited = []
    b = [None] * 2 * n
    i = 0
    while i < n:
        b[i] = b[n + i] = a[i]
        i = i + 1
    i = ind
    visited.append(ind)
    while i < n + ind:
        visited.append(b[i])
        i = i + 1
        if b[i] == end:
            #print(end)
            visited.append(end)
            return visited

def prints1(a,n,start ,end):
    st= start
    visited = []
    #print(start,end)
    for i in range(0,(end-start)+1):
        if st%n ==0:
            visited.append(n)
        else:
            visited.append(st%n)
        st += 1
    return visited

def prints2(a,n,start ,end):
    st= start
    en = end
    visited = []
    print("Start",st,"End",en)
    while en < n + i :
        print(a[(i % n)], end = " ")
        i = i + 1
    return visited

def circularArray(n,endNode):
    i =0
    visitedDict = {}
    a = [item for item in range(1, n + 1)]
    #print(a)

    while i < len(endNode)-1:
        #print(a)
        visited = prints(a,n,endNode[i],endNode[i+1])
        #visitedDict.extend(visited)

        for each in visited:
            if each in visitedDict:
                visitedDict[each] += 1
            else:
                visitedDict[each] = 1
        i += 1
    #print(visitedDict)
    new  = sorted(visitedDict, key=lambda k: (-visitedDict[k], k))
    print(new)
    #occurence_count = Counter(visitedDict)
    #return max(visitedDict.items(), key=operator.itemgetter(1))[0]
    #print(occurence_count.most_common())
    return new[0]
    #return  occurence_count.most_common(1)[0][0]

#print(circularArray(5,[1,5]))
#print(circularArray(10,[1,5,10,5]))
print(circularArray(10,[1,5,10,5]))
#print(circularArray(3,[1,3,2,3]))

#start = 5
# Driver Code
'''a = [1,2,3,4,5,6,7,8,9,10]
n = 10
end = 1
print(prints(a, n, start,end))'''
The file circularPrime.py contains:
def findPrime(start,end):
    res =[]
    for val in range(start,end+1):
        temp = str(val)
        if int(temp[0])%2==0 or int(temp[-1])%2==0:
            continue
        if val>1:
            for n in range(2,val):
                if val%n==0:
                    break
            else:
                res.append(val)
    return res

def ifCircular(op,re):
    reverNum=0
    temp = re
    while re > 0:
        a = re % 10
        reverNum = reverNum * 10 + a
        re = re // 10
    print(reverNum,temp)
    if reverNum==temp:
        return False
    elif reverNum in op:
        return True

if __name__ == '__main__':
    op = findPrime(1,100)
    res =[]
    for i in range(len(op)):
        if ifCircular(op,op[i]):
            res.append(op[i])

    print(res)
    print(len(res))
The file Circular_Array_Loop.py contains:
class Solution:
    def circularArrayLoop(self,nums):
        s, l = [], len(nums)
        for i, n in enumerate(nums):
            if i in s: continue  # check repeated i
            d = []
            while n * nums[i] > 0:  # forward or backward movements only
                if i in d:
                    if d[-1] != i:
                        return True  # the cycle's length must be greater than 1
                    else:
                        break
                d.append(i)  # store i for a cycle
                s.append(i)  # store i without checking the repetition in the following
                i = (i + nums[i]) % l
        return False


if __name__ == '__main__':
    s = Solution()
    print(s.circularArrayLoop([1, 1, 1, 1,1, 0, 0, 1,1, 1, 1, 1]))

    #[[1, 1, 1, 1], [1, 0, 0, 1], [1, 1, 0, 1]]
The file citrix_climb_hill.py contains:
a = [9,8,7,2,2,3]
b = a.copy()
cost = 0
cost1 = 0
print(max(a))
print(a.index(9))

for i in range(len(a)):
    if i != a.index(max(a)):
        cost = cost -a[i]

cost = cost + max(a)
for i in range(len(a)-1):
    if a[i+1]>a[i]:
        min(a[i],a[i+2])
        cost1 = cost1 + (min(a[i],a[i+2])+a[i])
print(cost1)
The file citrix_photo_album.py contains:

'''
for i in range(len(a)):
    c.insert(a[i],b[i])
print(c)
'''
class Node:
    def __init__(self, val):
        self.val = val
        self.next = None

def photoAlbum(index, identity):
    head = Node(identity.pop(0))
    index.pop(0)
    while identity:
        i = index.pop(0) - 1
        if i == -1:
            temp = Node(identity.pop(0))
            temp.next = head
            head = temp
            continue
        temp = head
        while i > 0:
            temp = temp.next
            i -= 1;
        new_node = Node(identity.pop(0))
        new_node.next = temp.next
        temp.next = new_node
    out = []
    while head:
        out.append(head.val)
        head = head.next
    return out

if __name__ == '__main__':
    n = 2
    a = [0, 1, 0]
    b = [0, 1, 2]
    print(photoAlbum(a,b))
The file City_Attrations.py contains:
import math
import os
import random
import re
import sys

#path = []


def findBestPath(n, m, max_t, beauty, u, v, t):
    path = [[] for i in range(m)]
    for i in range(m-1):
        path[u[i]].append([v[i], t[i]])
        #print(i,n,m,u,v,t)
        path[v[i]].append([u[i], t[i]])

    return [0, 1]


if __name__ == '__main__':

    n = int(input().strip())

    m = int(input().strip())

    max_t = int(input().strip())

    beauty_count = int(input().strip())

    beauty = []

    for _ in range(beauty_count):
        beauty_item = int(input().strip())
        beauty.append(beauty_item)

    u_count = int(input().strip())

    u = []

    for _ in range(u_count):
        u_item = int(input().strip())
        u.append(u_item)

    v_count = int(input().strip())

    v = []

    for _ in range(v_count):
        v_item = int(input().strip())
        v.append(v_item)

    t_count = int(input().strip())

    t = []

    for _ in range(t_count):
        t_item = int(input().strip())
        t.append(t_item)

    result = findBestPath(n, m, max_t, beauty, u, v, t)

    print(str(result) + '\n')
The file Colored_Loop.py contains:
def color_loop(n,m,mat):
    for i in range(n-1):
        for j in range(m):
            #print(i,j)
            c = mat[i][j]
            for k in range(j+1,m):
                if mat[i][k] != c:
                    break
            k-=1
            if k>j:
                for l in range(i+1,n-1):
                    #print(l,k)
                    if mat[l][k] != c:
                        break
                l-=1
                print(l,i)
                if l>i:
                    p=k
                    while p-j >= 0:
                        if mat[l][p] != c:
                            break
                        p -= 1
                    p+=1
                    if p == j:
                        q=l
                        while q >= i:
                            if mat[q][p] != c:
                                break
                            q-=1
                        q+=1
                        if q==i:
                            return True
    return False
x = [
    ['B','B','B','B','B','B','B'],
    ['B','R','G','G','G','B','B'],
    ['B','G','B','B','G','B','B'],
    ['B','G','G','G','G','B','B'],
    ['B','B','B','B','B','B','B'],
    ['B','B','B','B','B','B','B']
]
print(color_loop(7,6,x))
The file combination_permutation.py contains:
#import os
import gc
from itertools import permutations
import itertools

def arraysCount(n,m,totalcost):
    idx = 0
    result = []
    while idx < len(n):
        print('answers index: ',idx)
        temp_result = []

        if n[idx] <= m[idx]:
            all_arrays = perm(n[idx],m[idx])
            print('all_arrays:',all_arrays)
        else:
            all_arrays = perm_rep(n[idx],m[idx])
            print('im here')
            print('all_arrays:', all_arrays)

        for each in all_arrays:
            if fun_totalCost(each) == totalcost[idx]:
                temp_result.append(each)
        result.append(len(temp_result))
        del(temp_result)
        gc.collect()
        idx += 1
    return result
    #print(result)


def fun_totalCost(element):
    curr_max = element[0]
    total_cost = 0

    for i in range(1,len(element)):
        if element[i] > curr_max:
            curr_max = element[i]
            total_cost += 1

    return total_cost

def perm(n,m):

    arr= []
    for i in range(1,m+1):
        arr.append(i)
    main_list = []
    for subset in permutations(arr, n):
        main_list.append(list(subset))
    return main_list

def perm_rep(n,m):
    arr = []
    for i in range(1, m + 1):
        arr.append(i)
    main_list = [list(p) for p in itertools.product(arr, repeat=n)]
    return main_list

if __name__ == '__main__':
    #fptr = open(os.environ['OUTPUT_PATH'], 'w')
    '''
    n_count = int(input().strip())

    n =[]

    for i in range(n_count):
        n_item = int(input().strip())
        n.append(n_item)


    m_count = int(input().strip())

    m =[]

    for i in range(m_count):
        m_item = int(input().strip())
        m.append(m_item)

    totalCost_count = int(input().strip())

    totalCost =[]

    for i in range(n_count):
        totalCost_item = int(input().strip())
        totalCost.append(totalCost_item)

    '''

    res = arraysCount([2,3,4],[3,3,3],[1,2,3])
    #res = arraysCount(n,m,totalCost)
    print(res)
    #fptr.write('\n'.join(map(str,res)))
    #fptr.write('\n')

    #fptr.close()
#print("Result - ",res)

#print(perm_rep(4,3))
#[2,3,4],[3,3,3],[1,2,2]



The file connectNropesWithMinCost.py contains:
import heapq
def connectNropes(arr1):
    res =[]
    for i in range(len(arr1)):
        heapq.heappush(res,arr1[i])
    count =0
    while len(res)!=1:

        data1 = heapq.heappop(res)
        data2 = heapq.heappop(res)
        #print(data1, data2)
        count+=data1+data2
        heapq.heappush(res,data1+data2)

    print(count)

if __name__ == '__main__':
    connectNropes([4,3,2,6])
The file constructorNames_Quora.py contains:
def constructorNames(a, b):
    if len(a) != len(b):
        return False
    myA = {}
    myB = {}
    for i in range(len(a)):
        if a[i] not in b or b[i] not in a:
            return False
        if a[i] not in myA:
            myA[a[i]] = 1
        else:
            myA[a[i]] += 1
        if b[i] not in myB:
            myB[b[i]] = 1
        else:
            myB[b[i]] += 1
    for ka, va in myA.items():
        for kb, vb in list(myB.items()):
            if va == vb:
                myB.pop(kb)
    if len(myB) == 0:
        return True
    return False

print(constructorNames("babczzz","abbzccc"))
print(constructorNames("aabbzqqq","aabbzzzq"))
print(constructorNames("x","y"))
The file coolFeature.py contains:
def pairwithSum(x,y,n):
    count = 0
    for k in range(len(x)):
        for j in range(len(y)):
            if x[k] + y[j] == n:
                count += 1
    #print(count)
    return count

def pairwithSum1(x,y,q):
    m ={}
    result = []
    for i in range(len(x)):
        if x[i] not in m:
            m[x[i]] =1
        else:
            m[x[i]] +=1
    for i in range(0,len(q)):
        if len(q[i]) == 3:
            index = q[i][1]

            y[index] = q[i][2]
        if len(q[i])==2:
            sum = q[i][1]
            count = 0
            for j in range(0,len(y)):
                if sum - y[j] in m:
                    count+=m[sum -y[j]]
            result.append(count)

    return  result

x = [1,2,3]
#x = [1,2,2]
y = [3,4]
#y = [2,3]
q = [[1,5],[0,0,1],[1,5]]
#q = [[1,4],[0,0,3],[1,5]]

print(pairwithSum1(x,y,q))

def coolFeature(a,b,query):
    m=[]
    if len(a) or len(b) == 0:
        return []
    for i in range(len(query)):
        count=0
        if query[i][0] == 0:
            if query[i][1]<len(query[i][1]):
                b[query[i][1]] = query[i][2]
        else:
            for k in range(len(a)):
                for j in range(len(b)):
                    if a[k] + b[j] == query[i][1]:
                        count+=1
            m.append(count)
    return m

'''
res = []
for i in range(len(q)):
    if len(q[i])==2:
        #print(pairwithSum(x,y,q[i][1]))
        res.append(pairwithSum(x,y,q[i][1]))
    elif len(q[i])==3:
        temp = q[i]
        y.pop(temp[1])
        y.insert(temp[1],temp[2])
print(res)
'''
#print(coolFeature(x,y,q))
#print(coolFeature(x,y,q))

The file countdistictpairs.py contains:
def binarySearch(arr, low, high, x):
    if (high >= low):

        mid = low + (high - low) // 2
        if x == arr[mid]:
            return (mid)
        elif (x > arr[mid]):
            return binarySearch(arr, (mid + 1), high, x)
        else:
            return binarySearch(arr, low, (mid - 1), x)

    return -1


# Returns count of pairs with
# difference k in arr[] of size n.
def countPairsWithDiffK(arr, n, k):
    count = 0
    arr.sort()  # Sort array elements
    s = set()
    for i in range(0, n - 2):
        mid = binarySearch(arr, i + 1, n - 1,abs(arr[i] - k))
        if (mid != -1):
            count += 1
            s.add((arr[i],arr[mid]))

    print(s)
    return len(s)


# Driver Code
# arr = [1, 5, 3, 4, 2]
# arr = [6,6,3,9,3,5,1]
arr = [1,3,46,1,3,9]
n = len(arr)
k = 47
print("Count of distinct pairs with given sum is ",
      countPairsWithDiffK(arr, n, k))
The file Countingbit.py contains:
def  countSetBits(n):
    res = []
    x = (bin(n).replace("0b",""))
    print(x)
    res.append(x.count('1'))
    for i in range(0,len(x)):
        if x[i] == '1':
            res.append(i+1)
    return res


def decimalToBinary(n):
   count = 0
   s = bin(n)
   res = [s.count('1')]
   for i in range(len(s)):
      if s[i] == '1':
         res.append(i-1)
   return res

print(countSetBits(37))
print(decimalToBinary(37))
The file countOfCharacterInString.py contains:
s = "SumedhJoglekar"

d  ={}
for i in s:
    if i not in d:
        d[i] = 1
    else:
        d[i]+=1

print(d)
The file criticalRouters.py contains:
import collections
'''
def FindCriticalNodes(numEdges, numNodes, edges):
    # Get all the node
    nodes = []
    for i in range(numEdges):
        # Get nodes
        if edges[i][0] not in nodes:
            nodes.append(edges[i][0])

        if edges[i][1] not in nodes:
            nodes.append(edges[i][1])

    # Get all the neighbours
    neighbours = {node: [] for node in nodes}
    for i in range(numEdges):
        # Get neighbours
        neighbours[edges[i][0]].append(edges[i][1])
        neighbours[edges[i][1]].append(edges[i][0])

    def dfs(parent, seen):
        nonlocal neighbours
        # print("Visiting node {}".format(parent))

        # Mark the parent as explored
        seen[parent] = 1

        # Get all the neighbours from parent
        neig = neighbours[parent]

        # Iterate all the neighbours
        for i in range(len(neig)):
            # return if this node was exlored
            if seen[neig[i]] == 1:
                continue

            # DFS
            dfs(neig[i], seen)

    # Loop over all the nodes
    output = []
    for i in range(numNodes):
        explored = {node: 0 for node in nodes}

        # Mark the cutting point as explored as we
        # don't wanna explore this point
        explored[nodes[i]] = 1

        # DFS
        # Traverse from 0 every time
        total_visited = 1
        dfs(nodes[0], explored)

        print("Node {}: Explores {} nodes.".format(nodes[i], sum(explored.values())))
        # If all nodes are explored, it means it's not articulate point
        if (sum(explored.values()) < numNodes):
            output.append(nodes[i])

    print(neighbours, nodes)
    print(output)


if __name__ == "__main__":
    numNodes, numEdges = 7, 7
    #edges = [[0, 1], [0, 2], [1, 3], [2, 3], [2, 5], [5, 6], [3, 4]]
    edges = [[1, 2], [1, 3], [2, 4], [3, 4], [3, 6], [6, 7], [4, 5]]
    FindCriticalNodes(numNodes, numEdges, edges)

'''

# Input:
# numNodes = 7,
# numEdges = 7,
# edges = [[0, 1], [0, 2], [1, 3], [2, 3], [2, 5], [5, 6], [3, 4]]
# Output:
# [2, 3, 5]

def findcriticalnodes(n, edges):
    g = collections.defaultdict(list)
    for conn in edges:
        g[conn[0]].append(conn[1])
        g[conn[1]].append(conn[0])
    visited = [0] * n
    isarticulationpoints = [0] * n
    order = [0] * n
    low = [0] * n
    seq = 0

    def dfs(u, p):
        nonlocal seq
        visited[u] = 1
        order[u] = low[u] = seq
        seq = seq + 1
        children = 0
        for to in g[u]:
            if to == p:
                continue
            if visited[to]:
                low[u] = min(low[u], low[to])
            else:
                dfs(to, u)
                low[u] = min(low[u], low[to])
                if order[u] <= low[to] and p != -1:
                    isarticulationpoints[u] = 1
                children += 1

        if p == -1 and children > 1:
            isarticulationpoints[u] = 1

    dfs(0, -1)
    ans = []
    for i in range(len(isarticulationpoints)):
        if isarticulationpoints[i]:
            ans.append(i)
    return ans


if __name__ == "__main__":
    a = [[1, 2], [1, 3], [2, 4], [3, 4], [3, 6], [6, 7], [4, 5]]
    print(findcriticalnodes(7, a))
The file critical_connections.py contains:
from collections import defaultdict

class Solution:
    def criticalConnections(self, n, connections):
        currentRank = 0  ## please note this rank is NOT the num (name) of the vertex itself, it is the order of your DFS level

        lowestRank = [i for i in
                      range(n)]  ## here lowestRank[i] represents the lowest order of vertex that can reach this vertex i

        visited = [False for _ in range(n)]  ## common DFS/BFS method to mark whether this node is seen before
        graph = defaultdict(list)
        for v in connections:
            graph[v[0]].append(v[1])
            graph[v[1]].append(v[0])
        print(graph)

        res = []
        prevVertex = -1  ## This -1 a dummy. Does not really matter in the beginning.
        ## It will be used in the following DFS because we need to know where the current DFS level comes from.
        ## You do not need to setup this parameter, I setup here ONLY because it is more clear to see what are passed on in the DFS method.

        currentVertex = 0  ## we start the DFS from vertex num 0 (its rank is also 0 of course)
        self._dfs(res, graph, lowestRank, visited, currentRank, prevVertex, currentVertex)
        return res


    def _dfs(self, res, graph, lowestRank, visited, currentRank, prevVertex, currentVertex):
        visited[currentVertex] = True  # it is possible
        lowestRank[currentVertex] = currentRank

        for nextVertex in graph[currentVertex]:
            if nextVertex == prevVertex:
                continue  ## do not include the the incoming path to this vertex since this is the possible ONLY bridge (critical connection) that every vertex needs.

            if not visited[nextVertex]:
                self._dfs(res, graph, lowestRank, visited, currentRank + 1, currentVertex, nextVertex)
            # We avoid visiting visited nodes here instead of doing it at the beginning of DFS -
            # the reason is, even that nextVertex may be visited before, we still need to update my lowestRank using the visited vertex's information.

            lowestRank[currentVertex] = min(lowestRank[currentVertex], lowestRank[nextVertex])
            # take the min of the current vertex's and next vertex's ranking
            if lowestRank[
                nextVertex] >= currentRank + 1:  ####### if all the neighbors lowest rank is higher than mine + 1, then it means I am one connecting critical connection ###
                res.append([currentVertex, nextVertex])

class Solution1:
    def criticalConnections(self, n, connections):
        graph = defaultdict(list)
        for v in connections:
            graph[v[0]].append(v[1])
            graph[v[1]].append(v[0])
        print(graph)
        pre = [-1 for i in range(1,n+1)]
        low = [-1 for i in range(1,n+1)]
        order = 1
        ans = []
        def dfs(par, cur, order):  # pass in parent node, current node and order
            order += 1
            pre[cur+1] = order
            low[cur+1] = pre[cur+1]
            for w in graph[cur]:
                if (pre[w+1] == -1):
                    dfs(cur, w, order)
                    low[cur+1] = min(low[cur+1], low[w+1])
                    if (low[w+1] == pre[w+1]):
                        ans.append((cur, w))

                elif (w != par):
                    low[cur+1] = min(low[cur+1], pre[w+1])

                dfs(1, 1, 0)  # only need to start from one node, since from one node you can reach any other nodes in an undirected graph, dfs(1, 1, 0) will also work
        print(ans)
        return ans

if __name__ == '__main__':
    n = 7
    #edges = [[1, 2], [1, 3], [3, 4], [1, 4], [4, 5]]
    #edges = [[1, 2], [1, 3], [3, 4], [1, 4], [4, 5]]
    #edges = [[1,2],[1,3],[2,3],[3,4],[4,5],[4,6],[5,6],[5,7],[6,7],[7,8],[8,9],[9,10]]
    #edges = [[1,2],[2,3],[3,4],[4,5],[6,3]]
    edges = [[1, 2], [1, 3], [2, 4], [3, 4], [3, 6], [6, 7], [4, 5]]
    solution = Solution()
    print(solution.criticalConnections(n, edges))

The file critical_router.py contains:
from collections import defaultdict

class Graph:
    def __init__(self, vertices):
        self.V = vertices + 1
        self.adj_list = defaultdict(list)
        self.parent = [-1] * self.V
        self.low = [float('inf')] * self.V
        self.disc = [float('inf')] * self.V
        self.visited = [False] * self.V
        self.time = 0
        self.bridges = []

    def add_edge(self, v, u):
        self.adj_list[u].append(v)
        self.adj_list[v].append(u)

    def find_bridges(self, u):
        self.visited[u] = True
        self.low[u] = self.time
        self.disc[u] = self.time
        self.time += 1
        for v in self.adj_list[u]:
            if not self.visited[v]:
                self.low[u] = min(self.low[u], self.low[v])
                if self.low[v] > self.disc[u]:
                    self.bridges.append([u, v])

            elif v != self.parent[u]:
                self.low[u] = min(self.low[u], self.disc[v])


def criticalConnection(numOfWarehouses, numOfRoads, roads):
    ans = []
    adj_list = defaultdict(list)
    for s, d in roads:
        adj_list[s].append(d)
        adj_list[d].append(s)
    for s, d in roads:
        adj_list[s].remove(d)
        adj_list[d].remove(s)
        if len(dfs(s, adj_list, set())) != numOfWarehouses:
            ans.append((s, d))
        adj_list[s].append(d)
        adj_list[d].append(s)
    return ans

def dfs(s, adj_list, visited):
    visited.add(s)
    for d in adj_list[s]:
        if d not in visited:
            dfs(d, adj_list, visited)
    return visited

if __name__ == '__main__':
    g = Graph(7)
    edges = [[1, 2], [1, 3], [2, 4], [3, 4], [3, 6], [6, 7], [4, 5]]
    #edges = [[1, 2], [1, 3], [2, 3], [3, 4], [3, 6], [4, 5], [6, 7], [6, 9], [7, 8], [8, 9]]
    #edges = [[1, 2], [1, 3], [2, 3], [3, 4], [4, 5], [4, 6], [5, 6], [5, 7], [6, 7], [7, 8],[8,9],[8,10],[9,10]]
    #edges = [[1, 2], [2, 3], [3, 4], [4, 5], [6, 3]]
    #edges = [[1, 2], [1, 3], [3, 4], [1, 4], [4, 5]]
    #edges = [[1, 2], [2, 3], [3, 4], [4, 5], [6, 3]]

    for i in edges:
        g.add_edge(i[0], i[1])

    for j in range(1, g.V):
        if not g.visited[j]:
            g.find_bridges(j)

    print(g.adj_list)
    print(sorted(g.bridges))


    print(criticalConnection(5,6,edges))
The file CTCI_1.1.py contains:
# Is Unique

def is_unique(s):
    bitVector = []
    for i in range(256):
        bitVector.append(False)
    for char in s:
        print(ord(char))
        if bitVector[ord(char)] == True:
            return "Not Unique"
        else:
            bitVector[ord(char)] = True
    return "Unique String"

def is_unique_using_set(s):
    unique_char = set()
    for char in s:
        if char in unique_char:
            return "Not Unique"
        else:
            unique_char.add(char)
    print("Set :- ", unique_char)
    return "Unique String"

def using_sort(s):
    s = sorted(s)
    print("sorted string: - ",s)
    for char in range(len(s)-1):
        if s[char]==s[char+1]:
            return "Not Unique String"
    return "Unique String"



if __name__ == '__main__':
    s = "SumedhS"
    print(is_unique(s))
    print(is_unique_using_set(s))
    print(using_sort(s))


The file CTCI_1.2.py contains:
# Check Permutation
from collections import Counter as c
def chkPermutation(str1,str2):
    if len(str1)!=len(str2):
        return False
    s = {}
    #s2 = c(str1)
    #print(s2)
    for char in str1:
        if char in s:
            s[char] +=1
        else:
            s[char]=1
    print("Before :-",s)
    for char in str2:
        if char not in s:
            print("After Removal: -", s)
            return False
        elif s[char]<=0:
            print("After Removal: -", s)
            return False
        else:
            s[char]-=1
    print("After Removal: -",s)
    return True

if __name__ == '__main__':
    str1 = "sumedha"
    str2 = "dhumess"

    print(chkPermutation(str1,str2))

The file CTCI_1.3.py contains:
# URLify
def urlift(str1,length):
    str1 = str1[:length].replace(' ','%20')
    print(str1)


if __name__ == '__main__':
    str1 = "Mr John Smith    "
    length = 13
    urlift(str1,length)
The file dam_design.py contains:

def wall(wallPositions,wallHeight):
    n = len(wallPositions)
    m = len(wallHeight)
    max_mud_len = -1
    for i in range(n - 1):
        if wallPositions[i] < wallPositions[i + 1] - 1:
            heightDiff = abs(wallHeight[i + 1] - wallHeight[i])
            gapLen = wallPositions[i + 1] - wallPositions[i] - 1
            if gapLen > heightDiff:
                low = max(wallHeight[i + 1], wallHeight[i]) + 1
                remainingGap = gapLen - heightDiff - 1
                localMax = low + remainingGap // 2
            else:
                localMax = min(wallHeight[i + 1], wallHeight[i]) + gapLen

            max_mud_len = max(max_mud_len, localMax)
    return max_mud_len

The file detectCycle.py contains:
d = {
    0:[1,2],
    1:[2],
    2:[0,3],
    3:[3]

}

# Python program to detect cycle
# in a graph

from collections import defaultdict

class Graph():
	def __init__(self,vertices):
		self.graph = defaultdict(list)
		self.V = vertices

	def addEdge(self,u,v):
		self.graph[u].append(v)

	def isCyclicUtil(self, v, visited, recStack):

		# Mark current node as visited and
		# adds to recursion stack
		visited[v] = True
		recStack[v] = True

		# Recur for all neighbours
		# if any neighbour is visited and in
		# recStack then graph is cyclic
		for neighbour in self.graph[v]:
			if visited[neighbour] == False:
				if self.isCyclicUtil(neighbour, visited, recStack) == True:
					return True
			elif recStack[neighbour] == True:
				return True

		# The node needs to be poped from
		# recursion stack before function ends
		recStack[v] = False
		return False

	# Returns true if graph is cyclic else false
	def isCyclic(self):
		visited = [False] * self.V
		recStack = [False] * self.V
		for node in range(self.V):
			if visited[node] == False:
				if self.isCyclicUtil(node,visited,recStack) == True:
					return True
		return False

g = Graph(4)
g.addEdge(0, 1)
g.addEdge(0, 2)
g.addEdge(1, 2)
g.addEdge(2, 0)
g.addEdge(2, 3)
g.addEdge(3, 3)
if g.isCyclic() == 1:
	print("Graph has a cycle")
else:
	print("Graph has no cycle")

# Thanks to Divyanshu Mehta for contributing this code

The file DiagonalsRearranging.py contains:
import itertools
def get_rows(grid):
    return [[c for c in r] for r in grid]

def get_cols(grid):
    return zip(*grid)

def get_backward_diagonals(grid):
    b = [None] * (len(grid) - 1)
    grid = [b[i:] + r + b[:i] for i, r in enumerate(get_rows(grid))]
    return [[c for c in r if c is not None] for r in get_cols(grid)]

#a = [["b", "b"],["c","a"]]
a= [["a","c","a","b","b"],["c","b","a","c","b"],["a","a","e","c","b"],["b","b","d","a","g"],["a","b","e","b","a"]]
arr = (get_backward_diagonals(a))
N = len(a)
res= {}
for j in range(len(arr)):
    shape_list = arr[j]
    g = itertools.cycle(shape_list)
    temp = []
    for i in range(N):
        shape = next(g)
        temp.append(shape)
    temp = "".join(temp)

    res[j+1] = temp

import operator

sorted_x = sorted(res.items(), key=operator.itemgetter(1))
print([x[0] for x in sorted_x])
print([x[0] for x in sorted_x])
The file digitManipulation.py contains:
def digitManipulations(n):
    n = str(n)
    product = 1
    sum1 =0
    for i in range(len(n)):
        product = product *int(n[i])
        sum1 = sum1 +int(n[i])


    print(product-sum1)


if __name__ == '__main__':
    digitManipulations(123456)
    digitManipulations(1010)

The file digitSum.py contains:

def digitSum(n1,n2):
    d = {}
    count = 0
    print(n2+1-n1)
    n2 =n2+1
    i =n1
    while i < n2:
        if i>9:
            if i%10 !=0:
                temp = int(i%10)
            else:
                n2 = n2+1
                i+=1
                continue
        else:
            temp = i
        if temp in d:
            d[temp] +=1
        else:
            d[temp] = 1
        i+=1
    key = max(d.values())
    print("Key",key)
    for i in d.values():
        if i == key:
            count+=1
    print(d)
    return (count,get_key(d,key))


def get_key(d,val):
    for key, value in d.items():
         if val == value:
             return key

print(digitSum(3,12))
print(digitSum(1,10))
print(digitSum(1,5))


The file evenOddOperations.py contains:
def getMaximumscore(integerArray,start,end, operation, sum1,score):
    if sum1 ==0:
        return score
    if operation%2 ==0:
        score -=sum1
    else:
        score +=sum1
    score1 = getMaximumscore(integerArray,start+1,end,operation+1,sum1-integerArray[start],score)
    score2 = getMaximumscore(integerArray,start,end-1,operation+1,sum1-integerArray[end],score)
    return max(score1,score2)

if __name__ == '__main__':
    #n = 6
    #n =3
    n = 1
    #integerArray = [1, 2, 3, 4, 2, 6]
    #integerArray = [1,2,3 ]
    integerArray = [10]
    initialScore = 0
    print(getMaximumscore(integerArray,0,len(integerArray)-1,1,sum(integerArray),0))

The file exampleOfMemoryView.py contains:
import time
for n in (100000, 200000, 300000, 400000):
    data = 'x'*n
    start = time.time()
    b = data
    while b:
        b = b[1:]
    print('bytes', n, time.time()-start)

for n in (100000, 200000, 300000, 400000):
    data = b'x'*n
    start = time.time()
    b = memoryview(data)
    while b:
        b = b[1:]
    print('memoryview', n, time.time()-start)



The file fastDelivery.py contains:
n = 3
boxes = [1,2,3]
#boxes =[7,4,7]#39
#boxes = [3,2,1]#15
#boxes = [4,7,2]
total_time = 0

'''
for i in range(0,len(boxes)):
    if boxes[i]>0:
        travel_time = (n-i) * boxes[i]
        count = boxes[i]
        print("Travel Time: ",travel_time)
        for j in range(i+1,len(boxes)):
            if boxes[j] != 0:
                if boxes[j]<boxes[i]:
                    count+=boxes[j]
                    boxes[j] = 0
                elif boxes[j]>=boxes[i]:
                    count+=boxes[i]
                    boxes[j] = boxes[j]-boxes[i]
        total_time += travel_time+count
        print(total_time)
        boxes[i] = 0
        count = 0
'''

def test(boxes):
    sumOfboxes = sum(boxes)
    maxNum = boxes[0]
    if boxes[0]!=0:
        travel_time= boxes[0]*(len(boxes))
    else:
        travel_time = 0
    for i in range(1,len(boxes)):
        if boxes[i]!=0:
            if boxes[i]>maxNum:
                travel_time+=(boxes[i]-maxNum)*(n-i)
        if boxes[i]>maxNum:
            maxNum = boxes[i]

    print("Travel Time",travel_time,"sum of boxes",sumOfboxes)
    return sumOfboxes+travel_time


#print(total_time)

print(test(boxes))




The file fibonacci.py contains:
def fibo_recursive(n):
    if n ==1:
        return 0
    if n ==2:
        return 1
    else:
        return fibo_recursive(n-1)+fibo_recursive(n-2)

def fibo_iterative(n):
    res =[0,1]
    for i in range(2,n,1):
        #print(res)
        res.append(res[i-1] + res[i-2])
    return res[-1]


print(fibo_recursive(9))
print(fibo_iterative(9))


The file findFile.py contains:
s = "d1/d2/a"
s1 = "a"
s2 = "d1/d2/b"
paths = [s,s1,s2]
ip_set = []
target = "d2"
op = []
'''
for i in range(len(paths)):
    # Making set of all directories in a paths by spliting on '/'
    ip_set.append(set(paths[i].split('/')))


for i in range(len(ip_set)):
    if target in ip_set[i]:
        op.append(paths[i])

print(op)
'''



import os
import sys

walk_dir = '.'

print('walk_dir = ' + walk_dir)

# If your current working directory may change during script execution, it's recommended to
# immediately convert program arguments to an absolute path. Then the variable root below will
# be an absolute path as well. Example:
# walk_dir = os.path.abspath(walk_dir)
print('walk_dir (absolute) = ' + os.path.abspath(walk_dir))

for root, subdirs, files in os.walk(walk_dir):
    print('--\nroot = ' + root)
    list_file_path = os.path.join(root, 'my-directory-list.txt')
    print('list_file_path = ' + list_file_path)

    with open(list_file_path, 'wb') as list_file:
        for subdir in subdirs:
            print('\t- subdirectory ' + subdir)

        for filename in files:
            file_path = os.path.join(root, filename)

            print('\t- file %s (full path: %s)' % (filename, file_path))

            with open(file_path, 'rb') as f:
                f_content = f.read()
                list_file.write(('The file %s contains:\n' % filename).encode('utf-8'))
                list_file.write(f_content)
                list_file.write(b'\n')
The file findIfPermutationDivisibleBy8.py contains:
def permute(nums):
    def backtrack(first=0):
        if first == n:
            if int(''.join(map(str, nums)))%8==0:
                print("Found")
                return True
        for i in range(first, n):
            nums[first], nums[i] = nums[i], nums[first]
            op1 = backtrack(first + 1)
            if op1:
                return  True
            nums[i], nums[first] = nums[first], nums[i]

        return False

    n = len(nums)
    temp = backtrack()
    if temp == True:
        return "YES"
    else:
        return "NO"

def checkDivisibility(arr):
    op = []
    for i in range(len(arr)):
        arr[i]  = list(map(int, str(arr[i])))
        op.append(permute(arr[i]))

    return op


def solve(num):
    number = str(num)
    l = len(number)
    if l == 1:
        if int(number) % 8 == 0:
            return "YES"
        else:
            return "NO"
    elif l == 2:
        if int(number) % 8 == 0 or int(number[::-1]) % 8 == 0:
            return "YES"
        else:
            return "NO"

    # when there are 3 or more digits
    hm = [0 for _ in range(10)]
    for char in number:
        hm[int(char)] += 1

    for i in range(0, 1000, 8):
        copy = list(hm)
        s = "00" + str(i)
        j = -1
        while j >= -3:  # check 3 digits
            d = int(s[j])
            if copy[d] <= 0: break
            copy[d] -= 1
            j -= 1
        if j == -4:
            return "YES"
    return "NO"




if __name__ == '__main__':
    print(checkDivisibility([61,75,0]))

    print()
The file findIndexofFirst1.py contains:
def binarySearch(array,target):
    def helper(start,end):
        mid = (start+end)//2
        if start<=end:
            if array[mid]==target and (array[mid-1]!=target):
                return mid
            elif array[mid]>=target:
                return helper(start,mid-1)
            elif array[mid]<target:
                return helper(mid+1,end)
        else:
            return -1

    return helper(0,len(array)-1)

print(binarySearch([1,1,1,1,2,2,2,4,4,4],4))
The file findLoop.py contains:
def findLoop(n,m,arr):
    for i in range(n):
        x = arr[i]
        for j in range(m):
            if arr[i+j] != x:
                break


The file findTrip.py contains:
'''
GIVEN A LIST OF FLIGHTS (IN ANY ORDER), CONSTRUCT THE TRIP
THAT THIS LIST REPRESENTS. FOR EXAMPLE, IF WE HAVE A FLIGHT
FROM SAN FRANCISCO TO DALLAS AND A FLIGHT FROM LOS ANGELES
TO SAN FRANCISCO, THE TRIP IS "LAX TO SFO TO DFW".

ASSUMPTIONS:
EACH CITY WILL BE VISITED ONLY ONCE.
THE LIST WILL ONLY REPRESENT ONE SINGLE TRIP.

FLIGHTS = [('SFO', 'DFW'), ('LAX', 'SFO'), ('DFW', 'CLT')]
TRIP: ['LAX', 'SFO', 'DFW', 'CLT']

IF THE ABOVE WORKS, TRY YOUR PROGRAM WITH THE FOLLOWING INPUT:
FLIGHTS = [('DFW','CLT'), ('SFO','DFW'), ('WAS','NYK'), ('LAX','SFO'), ('CLT','WAS')]
TRIP: ['LAX', 'SFO', 'DFW', 'CLT', 'WAS', 'NYK']
'''

#flight = [('SFO','DFW'),('LAX','SFO'),('DFW','CLT')]
#flight = {'SFO':'DFW','LAX':'SFO','DFW':'CLT'}
flight = {'DWF':'CLT','SFO':'DWF','WAS':'NYK','LAX':'SFO','CLT':'WAS'}
tmp = []
op  =[]
for k,v in flight.items():
    res = []
    tmp.append(v)
    res.append(k)
    res.append(v)
    while tmp:
        data = tmp.pop(0)
        if data in flight.keys():
            tmp.append(flight[data])
            res.append(flight[data])
    if len(res)>len(op):
        op = res

print(op)







The file fizzbuzz.py contains:
def fizzbuzz(start,end):
    for i in range(start,end+1):
        if i%3==0 and i%5==0:
            print("FizzBuzz")
        elif i%3==0:
            print("Fizz")
        elif i%5==0:
            print("Buzz")
        else:
            print(i)


if __name__ == '__main__':
    fizzbuzz(1,20)
The file frameGenerator.py contains:
def frameGenerator(n):
    res = []
    for i in range(1, n + 1):
        s = []
        for j in range(1, n + 1):
            if (i == 1 or i == n or j == 1 or j == n):
                #print("*",end="")
                s.append("*")
            else:
                #print(" ", end="")
                s.append(" ")

 #      print("".join(s))
        res.append("".join(s))
    return res

print(frameGenerator(8))
The file frequencyofMaximumValue.py contains:
from collections import Counter
#a = [1,3,2,2,3]
#a = [5,4,5,3,2]
#a = [2,2,2]
a = [2,1,2]

#q = [1,2,3,4,5]
#q = [1,2,3]
q = [1,2,3]
res = []
print(len(a))
#occurrencesInSubarraysSumedh(a,m)
for i in range(len(q)):
    most_common, num_most_common = Counter(a[q[i]-1:]).most_common(1)[0]
    res.append(num_most_common)

print(res)




The file Frog_Hopping.py contains:
#Link - https://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/

def minJumps(arr, n):
    jumps = [0 for i in range(n)]
    for i in range(n - 2, -1, -1):
        if (arr[i] == 0):
            jumps[i] = float('inf')
        elif (arr[i] >= n - i - 1):
            jumps[i] = 1
        else:
            min = float('inf')
            for j in range(i + 1, n):
                if (j <= arr[i] + i):
                    if (min > jumps[j]):
                        min = jumps[j]
            if (min != float('inf')):
                jumps[i] = min + 1
            else:
                jumps[i] = min
    return jumps[0]

if __name__ == '__main__':
    print(minJumps([2,1,4,3,2,5,1,6],8))
    print(minJumps([4,3,2,6,8,3,1,9,6,2],10))
The file GameEvents.py contains:
import re


def getEventsOrder(team1, team2, events1, events2):
    # Write your code here
    football = list()
    football.append({"team": team1, "event": events1})
    football.append({"team": team2, "event": events2})

    game_details_list = list()
    original_event = list()
    event_priority = ['G', 'Y', 'R', 'S']

    for f in football:
        for event in f["event"]:
            original_event.append(f["team"] + " " + event)

            # split events string to get details
            pattern = re.compile("([a-zA-Z\s]*)(\d+)[+]?(\d*).([G,Y,R,S])([a-zA-Z\s]*)")
            split_event = pattern.search(event)

            # create a list of format ["team name", "player name", "time", "extra time", "event", "second player name"]
            record = list()
            record.append(f["team"])  # team name
            if split_event:
                record.append(split_event.group(1).strip())  # player name
                record.append(int(split_event.group(2).strip()))  # time
                record.append(
                    int(split_event.group(3).strip()) if len(split_event.group(3).strip()) > 0 else 0)  # extra time
                record.append(event_priority.index(split_event.group(4).strip()))  # event
                record.append(split_event.group(5).strip())  # second player
            game_details_list.append(record)

    # sorting the list to return index position of the sorted list
    new_num_index_sorted = (sorted(range(len(game_details_list)),
                                   key=lambda k: (
                                       game_details_list[k][2],  # time
                                       game_details_list[k][3],  # extra time
                                       game_details_list[k][4],  # event
                                       game_details_list[k][0],  # team name
                                       game_details_list[k][1],  # player name
                                       game_details_list[k][5])))

    # based on the index position, fetching result from original event list and appending in answer
    answer = list()
    for i in new_num_index_sorted:
        answer.append(original_event[i])
    return answer


print(getEventsOrder("ABC","CBA",["Mo Sa 45+2 Y","A 13 G"],["D 23 S F","Z 46 G"]))
print(getEventsOrder("nolh","nzrdrrc",["inmuucz jzbkica 70 Y","ton wfnt 10 S inmuucz jzbkica","ecya kqvqy 20 S fkfk fuiyb senmofw"],["mysior pqfcz bxlnpn 49 G","mysior pqfcz bxlnpn 18 G","enc otagavd oevfg 68 Y"]))

The file Gateway_Throttling.py contains:

def droppedRequest(RequestTime):
    D = {}
    drop_count = 0
    for i in RequestTime:
        if i in D:
            D[i] += 1
        else:
            D[i] = 1
        drop_count = 0
        time = [i for i in D]
        time = sorted(time)
        for i in time:
            drop_count += max(D[i]-3,0)
            drop_count += max(sum([D[i] for i in range(max(min(time),i-9),i+1) if i in D])-20,0)
            drop_count += max(sum([D[i] for i in range(max(min(time),i-59),i+1) if i in D])-60,0)
    return drop_count

def droppedRequests(requestTime):
    freq = dict()
    for r in requestTime:
        if r in freq.keys():
            freq[r] = freq[r] + 1
        else:
            freq[r] = 1
    of = sorted(freq.items(), key=lambda x: x[0])
    print(of)
    dropped = 0
    of2 = dict()
    for k, v in of:
        if v > 3:
            dropped = dropped + v - 3
            of2[k] = 3
        else:
            of2[k] = v
    #print("-single second -")
    x1 = dropped
    #print(dropped)
    #rint(of2)

    dropped = 0  ######################

    # run 10 seconds and make of3
    of3 = dict()
    for k in of2.keys():
        start = k
        ten_end = k + 9
        ten_second = 0
        for k2 in of2.keys():
            if start <= k2 <= ten_end:
                ten_second = ten_second + of2[k2]
                if ten_second > 20:
                    x = of2[k2] - (ten_second - 20)
                    if x > 0:
                        of3[k2] = x
                    else:
                        of3[k2] = 0
                else:
                    of3[k2] = of2[k2]
            if k2 > ten_second:
                break
        if ten_second > 20:
            dropped = dropped + ten_second - 20
    y1 = dropped
    #print(of3)

    dropped = 0  ######################

    for k in of3.keys():
        start = k
        minute_end = k + 59
        one_minute = 0
        for k3 in of3.keys():
            if start <= k3 <= minute_end:
                one_minute = one_minute + of3[k3]
            if k3 > minute_end:
                break
        if one_minute > 60:
            dropped = dropped + one_minute - 60
    z1 = dropped
    #print(x1)
    #print(y1)
    #print(z1)
    #print(x1 + y1)
    ans = 0


    if x1 > 0:
        ans += x1
    if y1 > 0:
        ans += x1 + y1
    if z1 > 0:
        ans += z1 + y1+ x1

    print(ans)

    return ans

class Graph:

    # init function to declare class variables
    def __init__(self, V):
        self.V = V
        self.adj = [[] for i in range(V)]

    def DFSUtil(self, temp, v, visited):
        # Mark the current vertex as visited
        visited[v] = True

        #print(v)

        # Store the vertex to list
        temp.append(v)

        # Repeat for all vertices adjacent
        # to this vertex v
        for i in self.adj[v]:
            if visited[i] == False:
                # Update the list
                temp = self.DFSUtil(temp, i, visited)

        return temp

    # method to add an undirected edge
    def addEdge(self, v, w):
        self.adj[v].append(w)
        self.adj[w].append(v)

    # Method to retrieve connected components
    # in an undirected graph
    def connectedComponents(self):
        visited = []
        cc = []
        for i in range(self.V):
            visited.append(False)
        for v in range(self.V):
            if visited[v] == False:
                temp = []
                cc.append(self.DFSUtil(temp, v, visited))
        return cc

    # Driver Code

#def totalNoEdges(arr, comp_from, comp_to):

def totalEdges(cc , comp_from, comp_to):
    if len(cc) < 2:
        return 0
    j = 0
    edges = 0
    while j < len(comp_from):
        if comp_from[j] in cc and comp_to[j] in cc:
            edges += 1
        j += 1

    return edges

#print(totalEdges([0,1,2],[0,0,2],[1,2,1]))


    # Create a graph given in the above diagram
    # 5 vertices numbered from 0 to 4
def minOperations(comp_nodes, comp_from, comp_to):
    g = Graph(comp_nodes);
    i =0
    comp_from = [x - 1 for x in comp_from]
    comp_to = [x - 1 for x in comp_to]
    while i < len(comp_from):
        g.addEdge(comp_from[i], comp_to[i])
        i +=1

    #g.addEdge(0, 1)
    #g.addEdge(0, 2)
    #g.addEdge(2, 1)
    cc = g.connectedComponents()
    #print("Following are connected components")
    #print(cc)
    r = []
    i = 1
    for eachCC in cc:
        r.append(totalEdges(eachCC,comp_from,comp_to)- (i-1))
        i += 1
    if sum(r) > len(cc) -1:
        return len(cc) -1
    else:
        return -1

print(minOperations(4, [1, 1, 3], [2, 3, 2]))
#RequestTime = [1,1,1,1,2,2,2,3,3,3,4,4,4,11,11,11,6,6,6,5,5,5]
RequestTime = [1,1,1,1,2]
drop_count = droppedRequest(RequestTime)
#print(drop_count)


droppedRequests(RequestTime)


The file gau_Trend.py contains:
import itertools


def solution(A, B, C, D):
    result = {}
    perms = itertools.permutations([A, B, C, D])
    for p in perms:
        if ((p[0] == 2 and p[1] <= 3) or p[0] <= 1) and p[2] <= 5:
            temp = str(p[0]) + str(p[1]) + str(p[2]) + str(p[3])
            result[int(temp)] = temp

    if result == {}:
        return "NOT POSSIBLE"

    m = result[max(result)]

    return m[:2] + ":" + m[2:]


if __name__ == '__main__':
    print(solution(2,4,0,0))
    print(solution(3, 0, 7, 0))
The file General.py contains:
def findFirst1(arr,tatget):
    def helper(start,end,target):
        mid = (start+end)//2
        if end>=start:
            if arr[mid]==target and arr[mid-1]!=target:
                return mid
            elif arr[mid]>=target:
                return helper(start,mid-1,tatget)
            elif arr[mid]<tatget:
                return helper(mid+1,end,tatget)
        else:
            return -1
    print(helper(0,len(arr),tatget))


def findFisrtANdLast(arr,target):
    def helper(lo,hi,left):
        found = -1
        while lo <= hi:
            mid = lo + (hi - lo) // 2
            if target > arr[mid]:
                lo = mid + 1
            elif target < arr[mid]:
                hi = mid - 1
            else:
                if left:
                    found = mid
                    hi = mid - 1
                else:
                    found=mid
                    lo = mid+1

        return found

    l = helper(0,len(arr)-1,True)
    r = helper(0,len(arr)-1,False)

    print(l,r)

class Node:
    def __init__(self,x):
        self.val = x
        self.next = None

class Node1:
    def __init__(self,root):
        self.left = None
        self.val = root
        self.right = None

def inetraverse(root):
    def helper(r, res):
        if r:
            helper(r.left,res)
            res.append(r.val)
            helper(r.right,res)


    res =[]
    helper(root,res)
    print(res)

def bfs(root):
    q= []
    q.append(root)
    res =[]
    while q:
        data = q.pop(0)
        res.append(data.val)
        if data.left:
            q.append(data.left)
        if data.right:
            q.append(data.right)

    print(res)

def over1(a,b,c):
    return a+b+c

def over1(a,b,c,d):
    return a+b+c+d

class LinkedList:
    def __init__(self):
        self.head = None

    def push(self,x):
        new_node = Node(x)
        if not self.head:
            self.head = new_node

        last = self.head
        while last.next:
            last= last.next

        last.next = new_node
        new_node.next = None

    def start(self,x):
        new_node = Node(x)
        new_node.next = self.head
        self.head = new_node

    def printAll(self):
        temp = self.head
        print("Printing ..... ")
        while temp:
            print(temp.val)
            temp = temp.next

    def delete(self,x):
        prev = None
        curr = self.head

        while curr.val!=x:
            nxt = curr.next
            prev = curr
            curr = nxt

        prev.next = curr.next

    def reverseLL(self):
        prev = None
        curr = self.head

        while curr:
            nxt = curr.next
            curr.next = prev
            prev = curr
            curr = nxt

        self.head = prev


    def middle(self):
        slow = self.head
        fast = self.head

        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next

        print("Middle Element: -",slow.val)


def Sum35():
    t = int(input().strip())
    for a0 in range(t):
        n = int(input().strip())
        i = 1
        sum = 0
        while (i < n):
            mof3 = 3 * i
            mof5 = 5 * i
            if mof3 < n:
                sum = sum + mof3
            if mof5 < n and mof5 % 3 != 0:
                sum = sum + mof5
            i = i + 1
        print(sum)

if __name__ == '__main__':
    #findFirst1([0, 0, 0, 0, 0, 0, 1, 1, 1, 1],1)
    #findFisrtANdLast([5,7,7,8,8,10],8)
    #findFisrtANdLast([5, 7, 7, 8, 8, 10,10,10,10,10,11,13,15], 10)
    #findFisrtANdLast([5, 7, 7, 8, 8, 10, 10, 10, 10, 11, 13, 15], 16)
    #findFisrtANdLast([5,7,7,8,8,10], 6)
    '''
    root = Node1(1)
    root.left = Node1(2)
    root.right = Node1(3)
    root.left.left = Node1(4)
    root.left.right = Node1(5)
    root.right.left = Node1(6)
    root.right.right = Node1(7)
    root.right.left.left = Node1(8)
    inetraverse(root)
    #bfs(root)'''
    '''
    l = LinkedList()
    l.push(2)
    l.push(3)
    l.push(4)
    l.push(1)
    l.start(5)
    l.start(6)
    l.delete(2)
    l.printAll()
    l.reverseLL()
    l.printAll()
    l.middle()
    
    print(over1(1,3,3))
    print(over1(1, 3, 3,4))
    '''

    Sum35()


The file getIdealNumber.py contains:
'''
3^x5^y is ideal number
'''
l =1
r  =10
def idealCount(l,r):
    count = 0
    if l ==1:
        l+=1
        count+=1
    for i in range(l,r+1):
        num = i

        while num%3==0:
            num//=3

        while num % 5 == 0:
            num //= 5

        if num ==1:
            count+=1
    return count
print(idealCount(1,10))
The file gettingTicketsToFan.py contains:
'''
Sample Input 1
5
2
1 1 1 40 60
2 1 4 50
3
3 3
3 2
4 3

Sample Input 2
5
2
1 1 1 40
2 1 4 50
1
3 3

Sample Input 3
6
3
1 1 2 100 100 400
2 2 4 100 200 500
3 3 1 100 200 500
3
3 3
3 3
3 3

Sample Input 4
3
2
1 2 2 100 200 400
2 1 4 40 100 200
1
2 2

Sample Input 5
4
2
1 1 2 100 200 400
2 2 4 100 200 400
2
3 3
3 3

Sample Input 6
2
1
1 2 2 60 15 90
1
2 2

Sample Input 7
2
1
1 2 2 60 15 90
1
2 2

Sample Input 8
3
2
2 2 2 400 100 200
1 4 4 40 100 200
1
2 2


Sample Input 9
7
3
2 4 4 100
1 2 2 100
3 1 3 100
4
3 3
3 3
3 3
3 3

'''
import math
def manhattan_distance(x1, y1, x2, y2):
    return abs(x1 - x2) + abs(y1 - y2)

sizeOfWorld = int(input())
numberOfEvents = int(input())
events = {}
buyer = []
ticket = {}
op = []
dist = {}
eventId = 0

for i in range(0, numberOfEvents):
    eventLine = input()
    eventLine = list(map(int, eventLine.split()))
    events[eventLine[0]] = [eventLine[1], eventLine[2]]
    ticket[eventLine[0]] = sorted(eventLine[3:])

numberOfBuyers = int(input())
for i in range(0, numberOfBuyers):
    buyerLine = input()
    buyerLine = list(map(int, buyerLine.split()))
    buyer.append(buyerLine)
print("Events:-",events,"Tickets: -",ticket,"Buyer: -",buyer)
#print("-----------------------------------------------------")
for i in range(int(numberOfBuyers)):
    minDist = math.inf
    coOrdinate = buyer[i]
    for k, v in events.items():
        preevent = eventId
        betwDist = manhattan_distance(coOrdinate[0], coOrdinate[1], v[0], v[1])
        #print("Dist",betwDist,v,coOrdinate,minDist)
        if betwDist < minDist and len(ticket[k]) != 0:
            minDist = betwDist
            eventId = k
        elif betwDist == minDist and len(ticket[k]) != 0:
            #print("--------",k,eventId)
            if ticket[k][0]<ticket[eventId][0]:
                eventId = k
            elif ticket[k][0]==ticket[eventId][0] and k<eventId:
                eventId = k

            #print(k, eventId,"--------")

    #print("-------------------------------")
    #print(ticket,eventId)
    if eventId in ticket and ticket[eventId]:
        tickets = ticket[eventId].pop(0)
    else:
        eventId = -1
        tickets = 0
    print(eventId, tickets)

'''
# The following method get the manhatten distance betwen two points (x1,y1) and (x2,y2)
import math
def manhattan_distance(x1, y1, x2, y2):
    return abs(x1 - x2) + abs(y1 - y2)


# Enter your code here. Read input from STDIN. Print output to STDOUT
sizeOfWorld = int(input())
numberOfEvents = int(input())
events = {}
buyer = []
ticket ={}
op = []
dist ={}
eventId = 0

for i in range(0,numberOfEvents) :
    eventLine = input()    
    eventLine = list(map(int,eventLine.split()))
    events[i] = [eventLine[0],eventLine[1]]
    ticket[i] = sorted(eventLine[3:])

    
numberOfBuyers = int(input())
for i in range(0,numberOfBuyers) :
    buyerLine = input()
    buyerLine = list(map(int,buyerLine.split()))
    buyer.append(buyerLine)


#print("Events:-",events,"Tickets: -",ticket,"Buyer: -",buyer) 

for i in range(int(numberOfBuyers)):
    minDist  = math.inf
    coOrdinate = buyer[i]
    for k,v in events.items():
        preevent = eventId
        betwDist = manhattan_distance(coOrdinate[0],coOrdinate[1],v[0],v[1])
        if betwDist<=minDist and len(ticket[k])!=0:
            minDist = betwDist
            eventId = k
            minprice = ticket[eventId][0]
        elif betwDist == minDist and len(ticket[k])!=0:
            if minprice > ticket[k][0]:
                eventId = preevent
                minprice = ticket[k][0]
    #print(ticket,eventId)    
    if eventId in ticket and ticket[eventId]:
            tickets = ticket[eventId].pop(0)
        #print(tickets)
    else:
        eventId = -2
        tickets = 0
    print(eventId+1,tickets)
    
# The solution to the first sample above would be to output the following to console:
# (Obviously, your solution will need to figure out the output and not just hard code it)
'''





The file Get_Requests_For_GIF_Images.py contains:
def sumedh_sol(filepath):
    s  = set()
    with open(filepath) as fp:
       for cnt, line in enumerate(fp):
           l = line.split()
           if "200" in l[-2] or "200" in l[-1]  and "gif" in l[-4].lower() and l[5].split('"')[1]=='GET':
                   temp = l[-4].split('/')
                   s.add(temp[-1])
                   #print(s)
    fp.close()
    f = open("gifs_hosts_access_log_00.txt", "w")
    s = list(s)
    for i in range(len((s))-1):
        print(s[i])
        f.write((s[i])+"\n")
    print(s[len(s)-1])
    f.write(s[len(s)-1])
    f.close()


def sakshat_sol(filepath):
    res = set()
    with open(filepath) as fp:
        for s in fp:
            s = s.split('"')
            # print(s)
            c = s[-1].strip().split(' ')
            if '200' not in c:
                continue
            b = s[1].strip().split('/')
            # print(b)
            flag = False
            for i in b:
                if 'GET' in i:
                    flag = not flag
                if 'gif' in i or 'GIF' in i:
                    temp = i.split(' ')[0]
                    if flag:
                        res.add(temp)
                    break
    print(res)

if __name__ == '__main__':
    filepath = 'hosts_access_log_00.txt'
    sumedh_sol(filepath)
    #sakshat_sol(filepath)

The file gifs_hosts_access_log_00.txt contains:

livevideo.GIF
KSC-logosmall.gif
NASA-logosmall.gif
count.gif
The file gluMandar.py contains:
'''

import collections
import datetime as d



data = [{"game_id":"Racing","user_id":"ABC123","amt":5,"date":"2020-01-01"},
        {"game_id":"Racing","user_id":"ABC123","amt":1,"date":"2020-01-04"},
        {"game_id":"Racing","user_id":"CDE123","amt":1,"date":"2020-01-04"},
        {"game_id":"DH","user_id":"CDE123","amt":100,"date":"2020-01-03"},
        {"game_id":"DH","user_id":"CDE456","amt":10,"date":"2020-01-02"},
        {"game_id":"DH","user_id":"CDE789","amt":5,"date":"2020-01-02"},
        {"game_id":"DH","user_id":"CDE456","amt":1,"date":"2020-01-03"},
        {"game_id":"DH","user_id":"CDE456","amt":1,"date":"2020-01-03"}]

no_of_players = collections.defaultdict(set)
cumulative_sum = collections.defaultdict(lambda: [0] * 4)
game_id = []

for i in range(len(data)):
    no_of_players[data[i]['game_id']].add(data[i]['user_id'])
#print(no_of_players)

dates = ["2020-01-01","2020-01-02","2020-01-03","2020-01-04"]
end_date = max(data, key=lambda r: r['date'])
print(end_date['date'])
end_date = d.datetime.strptime(end_date['date'], "%Y-%m-%d")
print(end_date)

for k,v in no_of_players.items():
    game_id.append(k)

for i in range(len(dates)):
    for j in range(len(data)):
        if data[j]['date'] == dates[i]:
            cumulative_sum[data[j]['game_id']][i] +=data[j]['amt']
#print(len(cumulative_sum))
for k,v in cumulative_sum.items():
    temp =v
    for j in range(1,len(temp)):
        temp[j] = temp[j-1]+temp[j]
    cumulative_sum[k] = temp
print(cumulative_sum)
print("Game    Age      Cum_rev     Total_unique_payers_per_game")
for k,v in cumulative_sum.items():
    for j in range(len(v)):
        print(k,"\t",j,"\t",v[j],"\t",len(no_of_players[k]))

'''


import collections
import datetime as d
data = [{"game_id":"Racing","user_id":"ABC123","amt":5,"date":"2020-01-01"},
        {"game_id":"Racing","user_id":"ABC123","amt":1,"date":"2020-01-04"},
        {"game_id":"Racing","user_id":"CDE123","amt":1,"date":"2020-01-04"},
        {"game_id":"DH","user_id":"CDE123","amt":100,"date":"2020-01-03"},
        {"game_id":"DH","user_id":"CDE456","amt":10,"date":"2020-01-02"},
        {"game_id":"DH","user_id":"CDE789","amt":5,"date":"2020-01-02"},
        {"game_id":"DH","user_id":"CDE456","amt":1,"date":"2020-01-03"},
        {"game_id":"DH","user_id":"CDE456","amt":1,"date":"2020-01-03"}]

class Cumulative:

    def __init__(self,data):
        self.data = data
        self.finalResult = list()

    def getRow(self,game, Age, Cum_rev, unique_players=0):
        d = {
            'game': game,
            'Age': Age,
            'Cum_Rev': Cum_rev,
            'Unique_Players': unique_players
        }
        return d

    def getAmt(self, game, date):
        amt = 0
        for i in self.data:
            if i['game_id'] == game and i['date'] == date:
                amt += i['amt']
        return amt

    def getUniquePlayers(self):
        no_of_players = collections.defaultdict(set)
        for i in self.data:
            no_of_players[i['game_id']].add(i['user_id'])
        return no_of_players

    def getCumulative(self):
        numberOfPlayers = self.getUniquePlayers()


        game = set()
        for i in data:
            game.add(i['game_id'])

        end_date = max(data, key=lambda r: r['date'])
        end_date = d.datetime.strptime(end_date['date'], "%Y-%m-%d")


        for g in game:
            start_date = d.datetime.strptime('2020-01-01', "%Y-%m-%d")
            age = 0
            cum_amt = 0
            while start_date <= end_date:
                amt = self.getAmt(game=g, date=start_date.strftime('%Y-%m-%d'))
                cum_amt += amt
                l = self.getRow(game=g, Age=age, Cum_rev=cum_amt, unique_players= len(numberOfPlayers[g]))
                age += 1
                self.finalResult.append(l)
                start_date += d.timedelta(days=1)
        return self.finalResult
c = Cumulative(data)
result = c.getCumulative()
print("Game    Age      Cum_rev     Total_unique_payers_per_game")
for ele in result:
    print(ele['game'],'\t',ele['Age'],'\t',ele['Cum_Rev'],'\t',ele['Unique_Players'])





The file GoldmanSachs_2D_LIst.py contains:
def sum_2d(arr,k):
    sum = 0
    print("\nFinding Sum of each row:\n")
    dict={}
    for i in range(len(arr)):
        for j in range(len(arr)):
            # Add the element
            sum += arr[i][j]
        dict[i]=sum
        sum = 0
        #print("Sum of the row", i, "=", dict)
    sorted_dict = sorted(dict.items(), key=lambda kv: kv[1],reverse=True)
    #print("Sum of the row", i, "=", sorted_dict)
    print(arr[sorted_dict[k - 1][0]])
    return sorted_dict[k - 1][0]

if __name__ == '__main__':
    a = [[80, 96, 81,77], [78, 71, 93,75],[71,98,70,95],[80,96,89,77]]
    b = [[74,92,75,73],[74,92,75,73],[73,88,99,80]]
    c =[[74,92,75,73],[74,92,75,73],[74,92,75,73]]
    k = 3
    ans = sum_2d(c,k)
    print(ans)
    # print(dict[k-1][0])
The file Goldman_Shares Purchase.py contains:
'''
def Solution(word):
    soln_set = []
    # i points to the first char and j to the last char.
    i, lenofWord = 0, len(word)
    count = 0
    for i in range(0, lenofWord-2):
        j = lenofWord
        # This would break once a word in that sequence is found which doesnt have ABC, starting from the end towards allows us to break sooner.
        while j > i:
            if checkABC(word[i:j]):
                count += 1
                j -= 1
            else:
                break

    print(count)
'''

def  Solution2(word):
    dict = {'A':[],'B':[],'C':[]}
    maxpos = []
    for i, ltr in enumerate(word):
        if ltr == 'A':
            dict['A'].append(i)
            maxpos.append(i)
        if ltr == 'B':
            dict['B'].append(i)
            maxpos.append(i)
        if ltr == 'C':
            dict['C'].append(i)
            maxpos.append(i)
    print(dict)
    print(max(maxpos))

'''
def findMin(dict):
    for i in range(0,2):
        #dict[0]







def checkABC(partWord):
    if 'A' in partWord and 'B' in partWord and 'C' in partWord:
        return True
    else:
        return False
'''

'''
Solution 2

def analyzeInvestments(s):
    count = 0
    for i in range(len(s)):
        a = False
        b = False
        c = False
        for j in range(i+1, len(s) + 1):
            if a or 'A' in s[i:j]:
                a = True
            if b or 'B' in s[i:j]:
                b = True
            if c or 'C' in s[i:j]:
                c = True
            if a and b and c:
                count = count + len(s) - j + 1
                break
    print(count)
'''
test = ["ABC", "ABCCBA", "PQACBA", "ABBCZBAC"]
Solution2("ABCACBA")
#analyzeInvestments("ABBCZBAC")
The file goodSegment.py contains:
import  math
def goodSegment(badNumber, lower, upper):
    badNumber = sorted(badNumber)
    temp = []
    #print("Sorted List",badNumber)
    for i in range(len(badNumber)):
        if lower<=badNumber[i]<=upper:
            temp.append(badNumber[i])
    #maxdiff = -math.inf
    maxdiff = temp[0]-1 - lower
    if upper - temp[-1]>maxdiff:
        maxdiff = upper - temp[-1]
    #print("Res before for",maxdiff)

    for i in range(1,len(temp)):
        if maxdiff< (temp[i] - temp[i - 1])-1:
            maxdiff = (temp[i] - temp[i - 1])-1
        #print(maxdiff)

    #print(maxdiff)
    return  maxdiff

if __name__ == '__main__':
    print(goodSegment([37,7,22,15,49,60],3,48))
    print(goodSegment([5,4,2,15], 1, 10))
    print(goodSegment([8,6,20,12], 1, 30))
    print(goodSegment([2], 1, 3))
The file goodTuple.py contains:
#a = [1,1,1,2,1,3,4]
count =0
a = [1,1,2,1,2,1,1]
#a= []
if len(a)==0:
    print("Not a good tuple")
for i in range(len(a)-2):
    s = set()
    print(a[i],a[i+1],a[i+2])
    s.add(a[i])
    s.add(a[i+1])
    s.add(a[i+2])
    if len(s)==2:
        count+=1
        print("Good Tuple")
    else:
        print("Not a good tuple")
print("Count :- ",count)
The file Google_Minimum_Domino_Rotations_For_Equal_Row.py contains:
# Leetcode - 1007 - https://leetcode.com/problems/minimum-domino-rotations-for-equal-row/
# Google - https://leetcode.com/discuss/interview-question/352460/Google-Online-Assessment-Questions

import  collections
def minDominoRotations(A, B):
    """
    :type A: List[int]
    :type B: List[int]
    :rtype: int
    """
    n = len(A)
    d = collections.defaultdict(int)
    maxVal = float('-inf')
    num = 0  # num: highest frequency occurred
    # only count the num occurred most frequently
    for i in range(n):
        d[A[i]] += 1
        d[B[i]] += 1
        if d[A[i]] > maxVal:
            maxVal = d[A[i]]
            num = A[i]
        if d[B[i]] > maxVal:
            maxVal = d[B[i]]
            num = B[i]
    # if the frequency of the num < n, there's no reason it can be achieved the same number in whole row
    if maxVal < n:
        return -1

    cntRotate = 0  # count one of the sides to achieve all numbers are same in B
    skipRotate = 0  # when two sides are same as the num occurred most frequently
    for i in range(n):
        if A[i] != num and B[i] != num:  # non of sides are same as the num
            return -1
        if A[i] == num and B[i] == num:  # two sides are same as the num, so do not need to rotate
            skipRotate += 1
            continue
        if A[i] == num:  # if A's side is same as the num, rotate it the B side
            cntRotate += 1
    # count the minimum rotation:
    # min(all the numbers in B are same after rotation, all the numbers in A are same after rotation)
    return min(cntRotate, n - skipRotate - cntRotate)


print(minDominoRotations([1,2,3,6,3,2],[2,1,2,2,2,4]))
print(minDominoRotations([1,2,1,2],[2,6,1,2]))
The file Google_Watering_Flowers_2.0.py contains:
# Link Ref - https://leetcode.com/discuss/interview-question/394347/


class Worker:
    def __init__(self, capacity, ptr=0, water=0):
        self.capacity = capacity
        self.ptr = ptr
        self.water = water
        self.n_refill = 0

    def refill(self):
        self.water = self.capacity
        self.n_refill += 1

    def water_plant(self, plant):
        if plant > self.water:
            self.refill()
            self.water_plant(plant)
        else:
            self.water -= plant


def solution(plants, capacity1, capacity2):
    result = 0
    n_plants = len(plants)
    # current tank state of each worker
    worker_left, worker_right = Worker(capacity1, 0), Worker(capacity2, n_plants - 1)
    # watering process
    while worker_left.ptr <= worker_right.ptr:
        # concurrent watering
        if worker_left.ptr < worker_right.ptr:
            # logic for worker_left
            plant_left = plants[worker_left.ptr]
            worker_left.water_plant(plant_left)
            # logic for worker_right
            plant_right = plants[worker_right.ptr]
            worker_right.water_plant(plant_right)
            # move together
            worker_left.ptr += 1
            worker_right.ptr -= 1
        # joint watering
        else:
            plant = plants[worker_left.ptr]
            # not enough water
            if worker_left.water + worker_right.water < plant:
                result += 1
            break
    return worker_left.n_refill + worker_right.n_refill + result


if __name__ == '__main__':
    plants = [2, 4, 5, 1, 2]
    print(solution(plants, 5, 7))  # should return 3


The file gridOfLife.py contains:
def ans(grid,k,rules):
    corners = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[-1,-1],[1,-1],[-1,1]]
    lc = [[0]*len(grid[0])]*len(grid)
    for l in range(k):
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                count = 0
                for f in range(8):
                    r = i
                    c = j
                    r += corners[f][0]
                    c += corners[f][1]
                    if r >= 0 and r < len(grid) and c >= 0 and c<len(grid[0]) and grid[r][c] == 1:
                        count += 1
                lc[i][j] = count
        #print("lc---",lc)
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if rules[lc[i][j]] == 'alive':
                    #print(rules[lc[i][j]])
                    grid[i][j] = 1
                else:
                    grid[i][j] = 0
        print("Grid",k,grid)
    return grid


def calcualte_live_cell(grid,k,rules):
    X = [-1,-1,-1,0,0,1,1,1]
    Y = [-1,0,1,-1,1,-1,0,1]

    alive= []
    for i in range(len(grid)):
        temp =[]
        for j in range(len(grid[0])):
            num_alive = 0
            for k in range(8):
                x= i+X[k]
                y = j+Y[k]

                if x>=0 and x<len(grid) and y>=0 and y< len(grid[0]) and grid[x][y]:
                    num_alive+=1
            temp.append(num_alive)

        alive.append(temp)

    for i in range(len(alive)):
        for j in range(len(alive[0])):
            if rules[alive[i][j]]:
                grid[i][j]=1
            else:
                grid[i][j] = 0

    #print(alive)
    print(grid)



#grid = [[0,1,0,0],[0,0,0,0]]
#grid = [[0,1,0,0],[0,0,0,0]]
grid = [[0,1,0,0],[0,0,0,0]]
k = 1
rules = ['dead','alive','dead','dead','dead','dead','dead','dead','dead']
#rules = ['dead','alive','dead','dead','dead','alive','dead','dead','dead']
print(ans(grid,k,rules))

calcualte_live_cell(grid,k,rules)
The file hosts_access_log_00.txt contains:
unicomp6.unicomp.net -- [01/Jul/1995:00:00:06 -0400] "GET /shuttle/countdown/ HTTP/1.0" 200 3985
burger.letters.com - - [01/Jul/1995:00:00:11 -0400] "GET /shuttle/countdown/liftoff.html HTTP/1.0" 304 0 
burger.letters.com - - [01/Jul/1995:00:00:12 -0400] "GET /images/NASA-logosmall.gif HTTP/1.0" 304 O 
burger.letters.com - - [01/Jul/1995:00:00:12 -0400] "GET /shuttle/countdown/video/livevideo.GIF HTTP/1.0" 200 0 
d104.aa.net - - [01/Jul/1995:00:00:13 -0400] "GET /shuttle/countdown/ HTTP/1.0" 200 3985 
unicomp6.unicomp.net - - [01/Jul/1995:00:00:14 -0400] "GET /shuttle/countdown/count.gif HTTP/1.0" 200 40310 
unicomp6.unicomp.net - - [01/Jul/1995:00:00:14 -0400] "GET /images/NASA-logosmall.gif HTTP/1.0" 200 786 
unicomp6.unicomp.net - - [01/Jul/1995:00:00:14 -0400] "GET /images/KSC-logosmall.gif HTTP/1.0" 200 1204 
d104.aa.net - - [01/Jul/1995:00:00:15 -0400] "GET /shuttle/countdown/count.gif HTTP/1.0" 200 40310 
d104.aa.net - - [01/Jul/1995:00:00:15 -0400] "GET /images/NASA-logosmall.gif HTTP/1.0" 200 786
The file IMC.py contains:
'''
theDict = {chr(y): y - 64 for y in range(65, 91)}
print(theDict)
a = "1B 2C, 2D 4D"
x = a.split(',')
newlist = []
for i in (0, len(x) - 1):
    y = x[i].split()
    for i in range(0, len(y)):
        z = list(y[i])
        z[0] = int(z[0])
        z[1] = theDict[z[1]]
        z = ','.join(map(str, z))
        newlist.append(z)
for i in range(len(newlist)):
    newlist[i] = eval(newlist[i])

print(newlist)
for i in range(0, len(newlist), 2):
    temp = newlist[i] + newlist[i + 1]
    print(temp)
    maxnum = max(temp)
    minnum = min(temp)
    print(maxnum, minnum)
    '''


import string
import copy
def artifact(N, artifacts, search):
    # 4 , "1B 2C, 2D 4D" , "2B 2D 3D 4D 4A"

    mapOfArtifact = {}
    artifactsString = artifacts.split(",")

    for idx, artifact in enumerate(artifactsString):

        mapOfArtifact[idx] = findAllpositions(artifact)

    tempMap = copy.deepcopy(mapOfArtifact)
    searchPos = search.split()
    countOfPartial = 0
    countOfFull = 0

    for each in searchPos:
        for artifact in mapOfArtifact:
            if each in mapOfArtifact[artifact]:
                mapOfArtifact[artifact].remove(each)
    for idx,element in mapOfArtifact.items():
        if len(element) == 0:
            countOfFull += 1
        elif len(element) < len(tempMap[idx]):
            countOfPartial += 1

    print(countOfFull)
    print(countOfPartial)

def findAllpositions(s):
    a = dict()
    n = 4
    j = 65
    for i in range(n):
        a[chr(j)] = i + 1
        j += 1

    t = s.split()[0]
    b = s.split()[1]
    matrix = [[0] * n]*n
    bDict = dict()
    k = 65
    for i in range(n):
        bDict[i + 1] = chr(k)
        k += 1

    temp = []

    for i in range(int(t[0]), int(b[0]) + 1):
        for j in range(a[t[1]] -1, a[b[1]]):
            temp.append(str(i) + str(bDict[j+1]))

    return temp

findAllpositions("2D 4D")
#artifact(4, "1B 2C,2D 4D" , "2B 2D 3D 4D 4A")
artifact(4, "1A 1B,2C 2C" , "1B")
The file implementationOfRequest.py contains:
import requests
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.action_chains import ActionChains

r = requests.get('https://sjogleka.github.io/')
print(r.headers)
print(r.status_code)
if r.status_code==200:
    driver = webdriver.Chrome(executable_path="C:\Program Files (x86)\Google\Chrome\chromedriver.exe")
    driver.get("https://sjogleka.github.io/")
    driver.maximize_window()

    WebDriverWait(driver,15).until(EC.presence_of_element_located((By.XPATH,"//a[@href='portfolio-single.html']")))
    mlPage = driver.find_element_by_xpath("//a[@href='portfolio-single.html']")
    action = ActionChains(driver).move_to_element(mlPage)
    mlPage.click()
    #gitML = driver.find_element_by_xpath("//a[@href='https://github.com/sjogleka/Machine-Learning']")
    #driver.implicitly_wait(30)
    #gitML.click()
    driver.__exit__()
The file initial_public_offering.py contains:
def getUnallottedUsers(bids, totalShares):
    price_dict = dict()
    output = []
    for i in bids:
        if i[2] not in price_dict:
            price_dict[i[2]] = [[i[0], i[1], i[3]]]
        else:
            price_dict[i[2]].append([i[0], i[1], i[3]])
    for i in price_dict:
        price_dict[i] = sorted(price_dict[i], key=op.itemgetter(2))
    while totalShares > 0:
        max_price = max(price_dict.keys())
        if len(price_dict[max_price]) == 1:
            print(price_dict)
            print(price_dict[max_price])
            totalShares -= price_dict[max_price][0][1]
            price_dict.pop(max_price)
        else:
            if (totalShares // len(price_dict[max_price])) > 0:
                x = totalShares // len(price_dict[max_price])
                for i in price_dict[max_price]:
                    i[1] -= x
                    totalShares -= x
                y = totalShares % len(price_dict[max_price])
                i = 0
                while y > 0 and i < len(price_dict[max_price]):
                    if price_dict[max_price][i][1] == 0:
                        i += 1
                        continue
                    price_dict[max_price][i][1] -= 1
                    totalShares -= 1
                    i += 1
                    y -= 1
            else:
                y = totalShares % len(price_dict[max_price])
                i = 0
                while y > 0 and i < len(price_dict[max_price]):
                    price_dict[max_price][i][1] -= 1
                    totalShares -= 1
                    i += 1
                    y -= 1
                for j in range(i, len(price_dict[max_price]) - 1):
                    output.append(price_dict[max_price][i][0])

            price_dict.pop(max_price)

    for key in price_dict:
        for i in range(0, len(price_dict[key])):
            output.append(price_dict[key][i][0])

    return output
The file JSON_manipulation.py contains:
import json
import requests
'''
searchFor = input("Search For")
temp = requests.get("https://jsonmock.hackerrank.com/api/movies/search/?Title="+searchFor)
data = temp.json()
total_pages = data['total_pages']
res =[]
for i in range(total_pages):
    data2  = requests.get("https://jsonmock.hackerrank.com/api/movies/search/?Title=" + searchFor+"&page="+str(i)).json()['data']
    for ele in range(len(data2)):
        print(data2[i])
        res.append(data2[i]['Title'])
print(res)
print(sorted(res))
'''

data = json.load(open('read_json.json','r'))

print(data)
source = data['origin_addresses'][0]
destinations = data['destination_addresses']
entries = data['rows'][0]['elements']


#print(source)
#print(destinations,len(destinations))
#print(entries,len(entries))


res= []
for i in range(len(destinations)):
    res.append((destinations[i],entries[i]['distance']['text'],entries[i]['duration']['text']))
print("Source\t\t\t\t Destination\t\t\t\t Distance\t\t\t\t Duration")
for i in range(len(res)):
    temp  = res[i][0].split(',')
    temp = ','.join(temp[:-1])
    #print(temp)
    print(','.join(source.split(',')[:-1]),"\t",temp,"\t\t",res[i][1],"\t\t",res[i][2])


The file kClosestFromOrigin.py contains:
import  math, operator
def distance(x,y):
    return int(math.sqrt(x**2+y**2))

def kClosest(points,k):
    d = {}
    op = []
    for i in range(len(points)):
        x = points[i][0]
        y = points[i][1]

        d[i] = distance(x,y)

    res = sorted(d.items(),key=lambda x:(x[1],x[0]))[:k]
    for i in range(k):
        op.append(points[res[i][0]])

    return op








if __name__ == '__main__':
    #points = [[3, 3], [5, -1], [-2, 4]]
    points = [[1, 3], [-2, 2]]
    #K = 2
    K = 1
    print(kClosest(points,K))
The file kDifference_Twitter_Gaurav.py contains:
def kDifference(nums, k):
    if k < 0: return 0
    numsSet, pairsSet = set(), set()
    for num1 in nums:
        for num2 in [num1 + k, num1 - k]:
            if num2 in numsSet:
                pairsSet.add(tuple(sorted([num1, num2])))
        numsSet.add(num1)
    print(pairsSet)
    return len(pairsSet)

def kDiff(nums,k):
    d = {}
    s = set()
    for i in range(len(nums)):
        d[nums[i]] = [nums[i]+k,nums[i]-k]
    count = 0
    for i in range(len(nums)):
        if d[nums[i]][0] in d.keys():
            temp = tuple(sorted([d[nums[i]][0], nums[i]]))
            if temp not in s:
                s.add(temp)
                count+=1
        if d[nums[i]][1] in d.keys():
            temp = tuple(sorted([d[nums[i]][1], nums[i]]))
            if temp not in s:
                s.add(temp)
                count+=1

    print(count)
    print(d)


# Driver function to test above function
#nums = [1,5,3,4,2]
nums = [1,5,3,4,2]
#nums = [363374326,364147539,61825163,107306571,1281246024,139946991,428047635,491595254,879792181,106926279]
k= 2
print(kDifference(nums, k))
kDiff(nums,k)
The file KMaxSumInTwoArrays.py contains:
import heapq
def kMaxSumCombinations(arr1,arr2,k):
    d= {}
    for i in arr1:
        for j in arr2:
            d[i+j] = (i,j)

    items = sorted(d.keys(),reverse=True)
    #print(items)
    return items[:k]

def kMaxSumCombintion_1(arr1,arr2,k):
    arr1.sort()
    arr2.sort()
    #print(arr1,arr2)
    maxComb = []
    visited = set()
    heapq.heappush(maxComb,(-(arr1[len(arr1)-1]+arr2[len(arr2)-1]),len(arr1)-1,len(arr2)-1))
    #print(maxComb)
    res = []
    visited.add((len(arr1)-1,len(arr2)-1))
    for i in range(k):
        #print(maxComb)
        temp = heapq.heappop(maxComb)
        res.append(-temp[0])
        id1,id2 = temp[1],temp[2]
        if (id1-1,id2) not in visited:
            visited.add((id1-1,id2))
            tempsum1 = arr1[id1 - 1] + arr2[id2]
            heapq.heappush(maxComb, (-tempsum1, id1 - 1, id2))
        if (id1, id2-2) not in visited:
            visited.add((id1, id2-2))
            tempsum2 = arr1[id1] + arr2[id2 - 1]
            heapq.heappush(maxComb, (-tempsum2, id1, id2-1))
    print(res)




if __name__ == '__main__':
    #print(kMaxSumCombinations([3,2],[1,4],2))
    #print(kMaxSumCombinations([4, 2, 5, 1],[8, 0, 3, 5], 3))

    #print(kMaxSumCombintion_1([3, 2], [1, 4], 2))
    print(kMaxSumCombintion_1([4, 2, 5, 1],[8, 0, 3, 5], 3))

The file LeetCode_108_SortedArray_To_BST.py contains:
class TreeNode:
    def __init__(self,x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def sortArrayToBST(self,ar):
        if len(ar)==0:
            return None
        mid = len(ar)//2
        r = TreeNode(ar[mid])
        r.left=self.sortArrayToBST(ar[:mid])
        r.right = self.sortArrayToBST(ar[mid+1:])

        return r

    def inOrder(self,root):
        def helper(root,res):
            if root:
                helper(root.left,res)
                res.append(root.val)
                helper(root.right,res)
            else:
                res.append("null")
        res = []
        helper(root, res)
        return res

    def preOrder(self,root):
        print(root)
        def helper(root,res):
            if root:
                res.append(root.val)
                helper(root.left,res)
                helper(root.right,res)

        res = []
        helper(root, res)
        return res

if __name__ == '__main__':
    s = Solution()
    arr = [-10,-3,0,5,9]
    print(s.inOrder(s.sortArrayToBST(arr)))
    print(s.preOrder(s.sortArrayToBST(arr)))
'''    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.left.left = TreeNode(4)
    root.left.right = TreeNode(5)
    '''
    #print(s.inOrder(root))

The file LeetCode_1130_minimize_parent_cost.py contains:
def mctFromLeafValues(A):
    res, n = 0, len(A)
    stack = [float('inf')]
    for a in A:
        while stack[-1] <= a:
            mid = stack.pop()
            res += mid * min(stack[-1], a)
        stack.append(a)
    while len(stack) > 2:
        res += stack.pop() * stack[-1]
    return res


print(mctFromLeafValues([4,6,2]))
print(mctFromLeafValues([5,3,1]))
print(mctFromLeafValues([2,2,1]))
The file LeetCode_212_Word_Search.py contains:
import copy

def dfs(new_board,r,c,word,idx):
    if idx>= len(word):
        return  True

    if word[idx]!=new_board[r][c]:
        return False

    if r<0 or r>=len(new_board) or c<0 or c>=len(new_board[r]):
        return False
    new_board[r][c] = '-1'

    if dfs(new_board,r+1,c,word,idx+1) or dfs(new_board,r-1,c,word,idx+1) or dfs(new_board,r,c+1,word,idx+1) or dfs(new_board,r,c-1,word,idx+1):
        return True

    '''
    x = [1, -1, 0, 0]
    y = [0, 0, -1, 1]
    for m in range(4):
        new_r = r+x[m]
        new_c = c+y[m]
        if 0 <= new_r < len(new_board) and 0 <= new_c < len(new_board[0]):
            if dfs(new_board,new_r,new_c,word,idx+1) :
                return True
    '''

    new_board[r][c] = word[idx]

    return False

def findwords(board,words):
    res = []
    for i in range(len(words)):
        found = False
        new_board = copy.deepcopy(board)
        print(".......")
        print(words[i])
        print(".......")
        for j in range(len(board)):
            for k in range(len(board[0])):
                if dfs(new_board,j,k,words[i],0):
                    res.append(words[i])
                    found = True
            if found:
                break

    return res




if __name__ == '__main__':
    '''
    board1 = [
        ["o", "a", "a", "n"],
        ["e", "t", "a", "e"],
        ["i", "h", "k", "r"],
        ["i", "f", "l", "v"]
    ]
    words1 = ["oath", "pea", "eat", "rain"]
    
    board1 = [["a", "b"], ["c", "d"]]
    words1 = ["ab", "cb", "ad", "bd", "ac", "ca", "da", "bc", "db", "adcb", "dabc", "abb", "acb"]
    #expected = ["ab","ac","bd","ca","db"]

    board1 = [["a","b","c"],["a","e","d"],["a","f","g"]]
    words1 = ["abcdefg","gfedcbaaa","eaabcdgfa","befa","dgc","ade"]
    '''
    board1 = [["a"]]
    words1 = ["a"]

    print(findwords(board1,words1))


The file leetcode_26_remove_duplicates.py contains:
def removeDuplicates(nums):
    i = 0
    print(nums)
    while i<len(nums)-1:
        if nums[i]==nums[i+1]:
            del nums[i]
        else:
            i+=1
    return nums


print(removeDuplicates([0,0,1,1,1,2,2,3,3,3,4]))
#print(removeDuplicates([1,1,2]))
The file leetcode_27_remove_element.py contains:
from typing import List
def removeElement(nums: List[int], val: int) -> int:
    length = len(nums)
    count = 0
    for i in range(0,length):
        #print(nums[i],val,length)
        i -=count
        if nums[i]==val:
            print("in if", nums[i])
            #nums.pop(i)
            nums.remove(nums[i])
            count +=1
    return len(nums)



if __name__ == '__main__':
    print(removeElement([0,1,2,2,3,0,4,2],2))
The file leetcode_28_return_first_occurence.py contains:

def strStr(haystack: str, needle: str) -> int:
    print(haystack.find(needle))
    return haystack.find(needle)



if __name__ == '__main__':
    strStr("hello","ll")
    strStr("aaaaa", "bba")
    strStr("aaaaa", "")
    strStr("a","a")

The file level_order_traversal.py contains:
class Node:
    def __init__(self,root):
        self.val = root
        self.left = None
        self.right = None


class bfs:
    res = []
    def oddsum(self,root):
        queue = []
        level = 0
        if root:
            queue.append((root,level))
        while len(queue)>0:
            data = queue.pop(0)
            if data[0].val:
                self.res.append((data[0].val,data[1]))
                if data[0].left:
                    queue.append((data[0].left,level+1))
                if data[0].right:
                    queue.append((data[0].right,level+1))
                level+=1
        return self.res

class bfs2:
    def traverser2(self,r):
        res= []
        queue = []
        if r:
            queue.append(r)
        while queue:
            data = queue.pop(0)
            res.append(data.val)
            print(res)
            if data.left:
                queue.append(data.left)
            if data.right:
                queue.append(data.right)

        return res


if __name__ == '__main__':
    root = Node(3)
    root.left = Node(9)
    root.right = Node(20)
    root.left.left = Node(15)
    root.left.right = Node(7)
    root.left.left.left = Node(10)
    root.left.left.right = Node(10)
    traverse = bfs()
    t = traverse.oddsum(root)
    print(t)

    traverse2 = bfs2()
    t = traverse2.traverser2(root)
    #print(t)

'''
    res = [[]]
    for i in range(len(t)):
        if len(res)-1==t[i][1]:
            res[t[i][1]].append(t[i][0])
        else:
            res.append([])
            res[t[i][1]].append(t[i][0])
        print(res)
'''
The file LinkedList.py contains:
class ListNode:
    def __init__(self,x):
        self.val = x
        self.next  =None

class LinkedList:
    def __init__(self):
        self.head = None

    def push(self,x):
        print("---- Pusing at end -----",x)
        new_node = ListNode(x)
        if not self.head:
            new_node.next = None
            self.head = new_node

        last = self.head
        while last.next:
            last= last.next

        last.next = new_node
        new_node.next = None

    def printAll(self):
        last = self.head
        op = []
        while last:
            op.append(last.val)
            last = last.next
        return op

    def length(self):
        last = self.head
        length = 0
        while last:
            length+=1
            last = last.next

        return length

    def addAtfirst(self,x):
        print("---- Adding at start -----",x)
        new_node = ListNode(x)
        new_node.next = self.head
        self.head = new_node

    def deleteNode(self,x):
        print("---- Deleting the node -----",x)
        prev = self.head
        targetNode = self.head
        if self.head.val ==x:
            self.head = self.head.next

        while targetNode.val != x:
            #print("---target---",targetNode.val)
            #print("----prev--", prev.val)
            prev = targetNode
            targetNode = targetNode.next
        prev.next = targetNode.next

if __name__ == '__main__':
    l = LinkedList()
    l2 = LinkedList()
    l.push(2)
    l.push(3)
    l.push(4)
    l.push(1)
    l2.addAtfirst(2)
    l2.addAtfirst(3)
    l2.addAtfirst(4)
    l2.addAtfirst(1)
    print(l.printAll())
    print(l2.printAll())
    print(l.length())
    l.deleteNode(4)
    print(l.printAll())
    l.addAtfirst(7)
    l.push(7)
    print(l.printAll())
    l.deleteNode(7)
    print(l.printAll())
    l.deleteNode(7)
    print(l.printAll())

The file LL_in_python.py contains:
class Node:
    def __init__(self,data):
        self.data = data;
        self.next = None;


n1 = Node(21);
n2 = Node(22);

n1.next = n2;

print(n1.data,n2.data)

a = [1,2,4,6,8,9,1]
print(a)
a.sort()
print("Pop :- ",a.pop(3))
print(a)
a.reverse()
print("Reverse :-",a)

The file longestIncreasingPathInMatrix.py contains:
def longestIncreasingPath(matrix):
    tempq = 0
    def dfs(i,j,path,ret1):
        x= [1,-1,0,0]
        y = [0,0,1,-1]
        num = matrix[i][j]
        matrix[i][j] = -1

        for m in range(4):
            new_i = i + x[m]
            new_j = j + y[m]
            if 0<=new_i<r and 0<=new_j<c and matrix[new_i][new_j]>num:
                ret1.append(dfs(new_i,new_j,path+[matrix[new_i][new_j]],ret1))
                #print("After",ret1)


        matrix[i][j] = num
        print(path)

        return len(path)


    r = len(matrix)
    c =len(matrix[0])
    pathLength = 0
    ret = []
    for i in range(r):
        for j in range(c):
            print("......",nums[i][j],'......')
            path = [nums[i][j]]
            dfs(i,j,path,ret)
    print(max(ret))


if __name__ == '__main__':
    #nums = [[9,9,4],[6,6,8],[2,1,1]]
    nums = [[3,4,5],[3,2,6],[2,2,1]]
    longestIncreasingPath(nums)

The file longestKeyPress.py contains:
import collections
def longestKeyPress(keys_and_times):
    time_for_longest_keypress = -1
    temp_key = 0
    time_for_previous_keypress = 0

    for i in range(len(keys_and_times)):
        key_press_time = keys_and_times[i][1] - time_for_previous_keypress
        if key_press_time > time_for_longest_keypress:
            time_for_longest_keypress = key_press_time
            temp_key = keys_and_times[i][0]
        time_for_previous_keypress = keys_and_times[i][1]
    return chr(ord('a') + temp_key)



def segment(x,arr):
    maxElement = -float("inf")
    n = len(arr)
    Qi = collections.deque()
    for i in range(x):
        while Qi and arr[i] < arr[Qi[-1]]:
            Qi.pop()
        Qi.append(i)
    for i in range(x, n):
        if arr[Qi[0]] > maxElement:
            maxElement = arr[Qi[0]]
        while Qi and Qi[0] <= i - x:
            Qi.popleft()

        while Qi and arr[i] < arr[Qi[-1]]:
            Qi.pop()
        Qi.append(i)
    if arr[Qi[0]] > maxElement:
        maxElement = arr[Qi[0]]

    return maxElement

if __name__ == '__main__':
    print(longestKeyPress([[0,2],[1,3],[0,7]]))
    print(longestKeyPress([[0, 1], [0, 3], [4, 5],[5,6],[4,10]]))
    print(longestKeyPress([[0, 3], [20, 5], [2, 6],[15,7],[9,8],[19,9],[24,10],[4,12],[3,13]]))

    print(segment(1,[1000000000]))
The file longest_sub_grid.py contains:
def matrxi1(a,maxSum):
    n = len(a)
    for i in range(n-1,-1,-1):
        for j in range(0,n-i):
            for k in range(0,n-i):
                sum = 0
                for l in range(j,j+i):
                    for m in range(k,k+i):
                        print(l,m)
                        sum+= a[l][m]
                if (sum <= maxSum):
                    return (i)
    return 0


def matrxi(a, maxSum):
    n = len(a)
    for i in range(n, 0, -1):
        flag = 0
        for j in range(0, n - i + 1):
            if (j == 0 or flag == 1):
                flagk = 0
                for k in range(0, n - i + 1):
                    if (k == 0 or flagk == 1):
                        sum = 0
                        for l in range(j, j + i):
                            for m in range(k, k + i):
                                sum += a[l][m]
                        if (sum <= maxSum):
                            flagk = 1
                            flag = 1
                        else:
                            flag = 0
                            flagk = 0
            else:
                break
        if j == n - i and flag == 1:
            return i

    return 0


#print(matrxi([[1,1,1],[1,1,1],[1,1,1]],4))
#print(matrxi([[1,1,1],[1,1,1],[1,1,1]],4))

print(prblm_11())
The file Manager_Employee.py contains:
def iterate(emp1,temp,designation_emp):
    #print(designation_emp.get(emp1))
    if(designation_emp.get(emp1)!="Boss"):
        temp.append(designation_emp.get(emp1))
        iterate(designation_emp.get(emp1),temp,designation_emp)
    return temp




if __name__ == '__main__':
    temp = []
    temp2=[]
    set_emp = set(["Gaurav","Sakshat","Pratik","Sumedh","Anup","Pawan","Srishti"])
    designation_emp = {"Gaurav":"Sumedh","Sakshat":"Sumedh","Pratik":"Sumedh","Sumedh":"Anup","Anup":"Srishti","Pawan":"Srishti","Srishti":"Boss"}
    #print(designation_emp.get("Srishti"))
    a = iterate("Gaurav",temp,designation_emp)
    b = iterate("Sumedh",temp2,designation_emp)
    s = set()
    a.reverse()
    b.reverse()
    print("a = ", a)
    print("b = ", b)
    LCM = "none"
    if len(a)<len(b):
        for i in range(len(a)):
            if a[i]!=b[i]:
                LCM = a[i-1]
        if LCM == "none":
            LCM = b[len(a)-1]
    else:
        for i in range(len(b)):
            if b[i]!=a[i]:
                LCM = b[i-1]
        if LCM == "none":
            LCM = a[len(b)-1]

    print(LCM)


    '''
    if len(a)>len(b):
        for i in range(len(a)):
            s.add(a[i])
    else:
        for i in range(len(b)):
            s.add(b[i])
    print("s - ",s)
    if len(a)>len(b):
        print("In if",len(a))
        for i in range(len(a)-1,-1,-1):
            #print(i)
            if a[i] not in s:
                print(a[i])
                LCM = a[i+1]
                print(LCM)
                break
            else:
                print("In else")
        print("Out of for")
    else:
        for i in range(len(b)-1,-1,-1):
            if b[i] not in s:
                LCM = b[i + 1]
                break
    #print(LCM)
    
    '''
The file mapping_number_Goldman.py contains:
def strangeSort(mapping, nums):
    m = {}
    out = {}
    return_list = []
    for k, v in enumerate(mapping):
        m[v] = k
    for num in nums:
        number = 0
        for c in num:
            n = int(c)
            number = number * 10 + m[n]
        if number not in out:
            out[number] = []
        out[number].append(num)
    for each in sorted(out.keys()):
        for num in out[each]:
            return_list.append(num)
    print(return_list)

if __name__ == '__main__':
    mapping = [2, 1, 4, 8, 6, 3, 0, 9, 7, 5]
    nums = ['8', '12', '02', '4', '023', '65', '83', '224', '50']
    strangeSort(mapping,nums)
The file matchNomatch.py contains:
from collections import deque
class mathNomatch:
    def __init__(self,pattern):
        self.pattern = deque()
        self.pattern = pattern
        self.q = []
        self.patternLen = len(self.pattern)

    def match(self,ip):
        if len(self.q)<len(self.pattern):
            self.q.append(ip)
        else:
            self.q.pop(0)
            self.q.append(ip)

        #print(self.pattern,self.q,type(self.q))
        if self.q == self.pattern:
            return  "Match Found"
        else:
            return "No Match"

if __name__ == '__main__':
    s1 = mathNomatch([True,True,False,True])
    s2 = mathNomatch([True,False, True, True])
    while True:
        ip1 = input()
        if ip1.lower() == "true":
            print("... Calling s1 ....")
            print(s1.match(True))
            print("... Calling s2 ....")
            print(s2.match(True))
        else:
            print("... Calling s1 ....")
            print(s1.match(False))
            print("... Calling s2 ....")
            print(s2.match(False))







The file matchPrefix.py contains:
def prefixMatching(arr, str1, k):
    if k > len(str1):
        return "Error"
    prefix = str1[:k]
    #print(prefix)
    count =0
    for i in range(len(arr)):
        if len(arr[i])>k and arr[i][:k] == prefix:
            count +=1
    return count

if __name__ == '__main__':
    str1 = ["abba", "abbb", "abbc", "abbd", "abaa", "abca"]
    str2= ["geeks","geeksforgeeks","forgeeks"]
    print(prefixMatching(str1,"abbg",3))
    print(prefixMatching(str1, "abg", 2))
    print(prefixMatching(str1, "xyz", 2))
    print(prefixMatching(str2, "geeks", 2))
The file matrixQueries.py contains:
import math
def createMatrix(n,m):
    Matrix = [[x*y for x in range(1,n+1)] for y in range(1,m+1)]
    return Matrix

def matrixquery(n,m,queries):
    result=[]
    min_row=1
    row=[]
    min_column=1
    col=[]
    for query in queries:
        if query[0] == 0:
            result.append((min_row)*(min_column))
        elif query[0] == 1:
            row.append(query[1])
            for i in range(1,n+1):
                if i not in row:
                    min_row=i
                    break
        else:
            col.append(query[1])
            for i in range(1,m+1):
                if i not in col:
                    min_column=i
                    break
        print(min_row,min_column)
    return result


def matrixquery(n,m,queries):
    matrix=[]
    result=[]
    for i in range(0,n):
        matrix.append([])
        for j in range(0,m):
            matrix[i].append((i+1)*(j+1))
    for query in queries:
        if query[0] == 0:
            mini = min(min(matrix))
            result.append(mini)
        elif query[0] == 1:
            for i in range(0,m):
                matrix[query[1]-1][i] = math.inf
        else:
            for i in range(0,n):
                matrix[i][query[1]-1] = math.inf
    print(matrix)
    return result



matrix = createMatrix(3,3)
print(matrix)
print(min(min(matrix)))
res = []
#n = 10
#m = 2
#n = 100000
#m = 100000
n = 3
m = 4
queries  = [[0],[1,2],[0],[2,1],[0],[1,1],[0]]
#queries  = [[1,1],[2,2],[0]]
#queries = [[0]]
#print(matrixquery(n,m,queries))



def matrixLogic(n, m, queries):
    row = []
    col = []
    mini = []

    for i in range(1,n+1):
        row.append(i)

    for j in range(1,m+1):
        col.append(j)

    print(row, col)

    for query in queries:
        if query[0] == 0:
            mini.append(row[0]*col[0])
        elif query[0] == 1:
            row.remove(query[1])
        elif query[0] == 2:
            col.remove(query[1])

    return mini

print(matrixLogic(n,m,queries))


The file maxArithmaticLength.py contains:
import sys

def sortArray(a,b):
    c = set()
    i,j = 0,0
    while i < len(a) and j < len(b):
        if a[i] < b[j]:
            c.add(a[i])
            i+=1
        else:
            c.add(b[j])
            j+=1
    while i < len(a):
        c.add(a[i])
        i+=1
    while j < len(b):
        c.add(b[j])
        j+=1
    return list(c)

def maxArithmeticLength(a,b):
    c = sortArray(a,b)
    minDiff = sys.maxsize
    maxDiff = -sys.maxsize
    for i in range(len(c)-1):
        if minDiff > c[i+1] - c[i]:
            minDiff = c[i+1] - c[i]
        if maxDiff < c[i+1] - c[i]:
            maxDiff = c[i+1] - c[i]
    result = -1
    setA = set(a)
    while minDiff <= maxDiff:
        temp = set()
        count = 1
        j = 0
        i = c[j]
        temp.add(i)
        while j < len(c):
            i += minDiff
            if i in c:
                count += 1
                temp.add(i)
            else:
                break
            j+=1
        minDiff += 1
        if setA.issubset(temp):
            if result < count:
                result = count
    return result

print(maxArithmeticLength([0,4,8,16],[0,2,6,12,14,20]))
print(maxArithmeticLength([4,8,16],[0,2,6,10,12,14,20]))
The file maximumLevelSum.py contains:


class Node:

    def __init__(self,root):
        self.val = root
        self.left = None
        self.right = None



def findSum(root):
    def helper(r,level):
        if r:
            print(level_sum)
            helper(r.left,level+1)
            if level in level_sum:
                level_sum[level]+=r.val
            else:
                level_sum[level]=r.val
            helper(r.right,level+1)

    level_sum = {}
    helper(root,1)
    print(level_sum)

    return max(level_sum)



if __name__ == '__main__':
    root = Node(1)
    root.left = Node(2)
    root.right = Node(3)
    root.left.left = Node(4)
    root.left.right = Node(5)
    root.right.left = Node(6)
    root.right.right = Node(7)
    root.right.left.left = Node(8)

    print(findSum(root))

The file maxThreadActive.py contains:
def maxActiveThread(intervals):
    d = {}

    for start,end in intervals:
        if start not in d:
            d[start] = 0
        if end not in d:
            d[end] = 0

        d[start]+=1
        d[end]-=1

    print(d)
    total_thread,max_thread =0,0
    for i in sorted(d.keys()):
        total_thread += d[i]
        max_thread = max(max_thread,total_thread)

    print(max_thread)

if __name__ == '__main__':
    maxActiveThread([[2,4],[3,5],[1,4],[5,7]])




The file maxWithoutIfElse.py contains:
def maxWithoutif(a,b):
    return (a>b)*a + (b>a)*b

def minWithoutif(a,b):
    return (a>b)*b + (b>a)*a

print(maxWithoutif(6,5))
print(minWithoutif(6,5))

The file memoryAllocator.py contains:
def allocate(arr,index):
    for i in range(len(arr)):
        if len(arr[i:i+index])!=index:
            return -1,arr
        if sum(arr[i:i+index]) ==0:
            arr[i:i+index] = [1]*(i+index-i)
            return i,arr
    return -1,arr

def memoryAllocator(a,queries):
    print("----------------------------------")
    res = []
    counter = 0
    atomic_counter = []
    atomic_index= []
    for i in  range(len(queries)):
        if queries[i][0] == 0:
            #print("---- Adding ----")
            op,a = allocate(a,queries[i][1])
            #print(op)
            if op!=-1:
                counter+=1
                atomic_counter.append(counter)
                atomic_index.append(queries[i][1])
            res.append(op)
            #print(res,atomic_counter)
        else:
            #print("----- Erasing -----")
            #print(atomic_counter)
            if queries[i][1] in atomic_counter:
                id = atomic_counter.index(queries[i][1])
                #print(atomic_index[id])
                a[res[id]:res[id]+queries[id][1]] =[0]* (id+queries[id][1]-id)
                res.append(atomic_index[id])
            else:
                res.append(-1)
    print("Final o/p: - ",res)

            #print(res[id],queries[id][1])



if __name__ == '__main__':
    memoryAllocator([0,1,0,0,0,1,1,0,0,0,1,0,0],[[0,2],[0,1],[0,1],[1,2],[1,4],[0,4]])
    memoryAllocator([0,0,0,0],[[0,4],[0,1],[1,1],[0,2],[0,2]])
    memoryAllocator([1],[[0,1],[1,1]])

The file mergetwoalternate.py contains:
a = "abc"
b = "def"
i =0
result =""
while i<len(a) or i<len(b):
    if i<len(a):
        result=result+a[i]
    if i<len(b):
        result = result + b[i]
    i+=1
print(result)

The file Microsoft_1.py contains:
#s = "aaBabcDaA"
#s = "Codility"
#s = "cCaAvVzXZ"
s = "cCeEzZ"
res = ""
res1=-1
t =set()
#print(ord("a"),ord("A"))
for i in range(len(s)):
    t.add(ord(s[i]))

for i in range(len(s)):
    if ord(s[i])+32 in t and res1<ord(s[i]):
        res = s[i]
        res1 = ord(s[i])
if res:
    print(res)
else:
    print("NO")
The file minContiguousLengthOfSubArray.py contains:
'''
def twoIntegers(A,s):
    op = []
    for i in range(len(A)):
        sum =A[i]
        for j in range(i+1,len(A)):
            #print("i",A[i],"j",A[j])
            sum+=A[j]
            if sum>=s:
                if len(op)==0 or j-i<len(op):
                    op =A[i:j+1]
                    break
    print(op)
    return len(op)
'''
import math
def twoIntegers(A,s):
    window_sum,window_start = 0,0
    min_length = math.inf
    for end in range(len(A)):
        window_sum+=A[end]
        while window_sum>=s:
            prev = min_length
            min_length = min(min_length,end-window_start+1)
            if min_length<prev:
                op = A[window_start:end + 1]
            window_sum-=A[window_start]
            window_start+=1

    print(op)
    return min_length



if __name__ == '__main__':
    s = 7
    #s = 6
    #s =20
    #s = 1
    A = [2,3,1,2,4,3]
    #A = [1,1,2,2,2,1,1]
    #A = [2,3,1,2,4,3]
    #A = []
    #Output =2

    print(twoIntegers(A,s))

The file mineSweeper.py contains:
def dfs(field,x,y,visited):
    count  =0
    print("-------- dfs ----------")
    if 0 <= x + 1 < len(field) and field[x+1][y] and [x+1,y] not in visited:
        print(x+1,y)
        count +=1
    if 0 <= x - 1 < len(field) and field[x-1][y] and [x-1,y] not in visited:
        print(x - 1, y)
        count += 1
    if 0 <= y + 1 < len(field[0]) and field[x][y+1] and [x,y+1] not in visited:
        print(x, y+1)
        count += 1
    if 0 <= y - 1 < len(field[0]) and field[x][y-1] and [x,y-1] not in visited:
        print(x , y-1)
        count += 1

    if 0<=x-1<len(field) and 0<=y-1<len(field) and field[x-1][y-1] and [x-1,y-1] not in visited:
        print(x - 1, y-1)
        count+=1
    if 0<=x+1<len(field) and 0<=y-1<len(field) and field[x+1][y-1] and [x+1,y-1] not in visited:
        print(x + 1, y-1)
        count+=1
    if 0<=x-1<len(field) and 0<=y+1<len(field) and field[x-1][y+1] and [x-1,y+1] not in visited:
        print(x - 1, y+1)
        count+=1
    if 0<=x+1<len(field) and 0<=y+1<len(field) and field[x+1][y+1] and [x+1,y+1] not in visited:
        print(x + 1, y+1)
        count+=1

    print(count)
    return count

def dfs1(field,x,y,visited):
    count  =0
    row = [1, -1, 0, 0, -1, 1, -1, 1]
    col = [0, 0, 1, -1, -1, -1, 1, 1]
    for i in range(8):
        #print("-------- dfs ----------")
        if 0<=x+row[i]<len(field) and 0<=y+col[i]<len(field[0])and field[x+row[i]][y+col[i]] and [x+row[i],y+col[i]] not in visited:
            count+=1
    #print(count)
    return count


def minsweeper(field, x,y):
    q = []
    visited = []
    row = [1,-1,0,0,-1,1,-1,1]
    col = [0,0,1,-1,-1,-1,1,1]
    if field[x][y]:
        #print("in if")
        return [[-1]*len(field[0])]*len(field)
    else:
        #print("in else")
        q.append([x,y])
        while q:
            data = q.pop(0)
            cnt = dfs1(field,data[0],data[1],visited)
            visited.append(data)
            field[data[0]][data[1]] =cnt
            if cnt == 0:
                for i in range(8):
                    if 0 <= data[0] + row[i]<len(field) and 0<=data[1]+col[i]<len(field[0])and [data[0] + row[i], data[1]+col[i]] not in visited and [data[0] + row[i], data[1]+col[i]] not in q:
                        q.append([data[0]+row[i],data[1]+col[i]])
    #print(field)

    for i in range(len(field)):
        for j in range(len(field[0])):
            if type(field[i][j]) == bool:
                field[i][j] = -1

    return field




if __name__ == '__main__':
    #field = [[False,True,True],[True,False,True],[False,False,True]]
    field = [[True, False, True,True,False], [True, False, False, False, False], [False, False, False, False, False],[True,False,False,False,False]]
    #field = [[True, False, False, False, False,True],[True, False, False, False, False,False],[True, True, False, False, False,False],[False, False, True, False, False,False],[False, False, True, True, True, True]]
    #x = 1
    #y =1
    x= 3
    y = 2
    #x =0
    #y = 5
    print(minsweeper(field,x,y))

The file minimumUniqueArraySum.py contains:
'''
import collections
def minIncrementForUnique(A):
    count = collections.Counter(A)
    taken = []
    ans = 0
    res = []
    for x in range(100000):
        if count[x] >= 2:
            taken.extend([x] * (count[x] - 1))
            res.append(x)
        elif taken and count[x] == 0:
            res.append(x)
            ans += x - taken.pop()
    print(res)
    print(sum(res))
    return ans


def minIncrementForUnique(A):
    A.sort()
    ret = 0
    cur = -1
    res = []
    for num in A:
        cur = max(cur, num)
        res.append(cur)
        ret += cur - num
    return res





# Driver code
#A = [3, 2, 1, 2, 1, 7]
#A = [1,2,2]
A = [4,2,2,4,5]
print(minIncrementForUnique(A))

'''

MAX = 50


def solve(dp, a, low, high, turn):
    # If only one element left.
    if (low == high):
        return a[low] * turn

        # If already calculated,
    # return the value.
    if (dp[low][high] != 0):
        return dp[low][high]

        # Computing Maximum value when element
    # at index i and index j is to be chosed.
    dp[low][high] = max(a[low] * turn + solve(dp, a,
                                              low + 1, high, turn + 1),
                        a[high] * turn + solve(dp, a,
                                               low, high - 1, turn + 1))
    print(dp)

    return dp[low][high]


# Driver Code
if __name__ == "__main__":
    arr = [1, 3, 1, 5, 2]
    n = len(arr)

    dp = [[0 for x in range(MAX)]
          for y in range(MAX)]

    print(solve(dp, arr, 0, n - 1, 1))
The file minMoves_Chess.py contains:
# Python3 code to find minimum steps to reach
# to specific cell in minimum moves by Knight
class cell:
    def __init__(self, x=0, y=0, dist=0):
        self.x = x
        self.y = y
        self.dist = dist

def isInside(x, y, N):
    if x >= 1 and x <= N and y >= 1 and y <= N:
        return True
    return False

def minMoves(n, startRow, startCol, endRow, endCol):
    startRow +=  1
    startCol += 1
    endRow += 1
    endCol += 1
    dx = [2, 2, -2, -2, 1, 1, -1, -1]
    dy = [1, -1, 1, -1, 2, -2, 2, -2]
    queue = []
    queue.append(cell(startRow, endRow, 0))
    visited = [[False for i in range(N + 1)]for j in range(N + 1)]
    visited[startRow][endRow] = True
    while len(queue) > 0:
        t = queue[0]
        queue.pop(0)
        if (t.x == startCol and
                    t.y == endCol):
            return t.dist
        for i in range(8):
            x = t.x + dx[i]
            y = t.y + dy[i]
            if isInside(x, y, N) and not visited[x][y]:
                visited[x][y] = True
                queue.append(cell(x, y, t.dist + 1))

if __name__ == '__main__':
    N = 9
    #knightpos = [6, 2]
    #targetpos = [1, 6]
    startRow = 4
    startCol = 4
    endRow = 4
    endCol = 8
    print(minMoves(N,startRow,startCol,endRow,endCol))


The file most_common_words.py contains:
import re

def retrieveMostFrequentlyUseWords(literatureText, wordsToExclude):
    for i in range(len(wordsToExclude)):
        wordsToExclude[i] = wordsToExclude[i]

    print(wordsToExclude)
    wordsToExclude = set(wordsToExclude)
    words = {}
    for i in range(len(literatureText)):
      if literatureText[i] != " " and not literatureText[i].isalpha():
          literatureText[i] = " "
    inputStr = "".join(literatureText).lower()
    inputList = inputStr.split(" ")
    for word in inputList:
      if not word:
        continue
      if word not in wordsToExclude:
        if word not in words:
          words[word] = 1
        else:
          words[word] += 1
    sorted_words = sorted(words.items(), key = lambda x: x[1], reverse=True)
    results = []
    max_count = float('-inf')
    for word, freq in sorted_words:
      if max_count <= freq:
        results.append(word)
        max_count = freq
      else:
        break
    return  results

def solution(sentence, stop_words):
    stop_words = [x.lower() for x in stop_words]
    res = re.findall(r'\w+', sentence)
    res = [x.lower() for x in res]

    worddict = {}

    for word in res:
        if word not in worddict:
            worddict[word] = 1
        else:
            worddict[word] += 1

    print(worddict)

    fwords = []
    for value in worddict:
        if (worddict[value] > 1) and (value not in stop_words):
            fwords.append(value)

    print(fwords)


if __name__ == '__main__':
    inputStr = "Jack and Jill went to the market to buy bread and cheese. Cheese is Jack's and Jill's favorite food."
    # inputStr = "Rose is a flower red rose are flower"
    stop_words = ["and", "he", "the", "to", "is", "Jack", "Jill"]
    # stop_words = set(['is', "are", "a"])
    inputStr = list(inputStr)
    #print(retrieveMostFrequentlyUseWords(inputStr,stop_words))
    solution(inputStr,stop_words)
#print(mostCommonWord("Jack and Jill went to the market to buy bread and cheese. Cheese is Jack's and Jill's favorite food",["and", "he", "the", "to", "is", "Jack", "Jill"]))
The file movesToSolve.py contains:
import heapq as heapq
import itertools
import collections


def movesToSolve(board):
    s = ''.join(str(d) for row in board for d in row)
    dq, seen = collections.deque(), {s}
    dq.append((s, s.index('0')))
    steps, height, width = 0, len(board), len(board[0])
    temp = ""
    for i in range(0,len(board[0])*len(board[1])):
        temp = temp+str(i)
    #print(t)
    while dq:
        for _ in range(len(dq)):
            t, i = dq.popleft()
            if t == temp:
                return steps
            x, y = i // width, i % width
            for r, c in (x, y + 1), (x, y - 1), (x + 1, y), (x - 1, y):
                if height > r >= 0 <= c < width:
                    ch = [d for d in t]
                    ch[i], ch[r * width + c] = ch[r * width + c], '0'  # swap '0' and its neighbor.
                    s = ''.join(ch)
                    if s not in seen:
                        seen.add(s)
                        dq.append((s, r * width + c))
        steps += 1
    return -1

#print(movesToSolve([[1,6,3],[8,7,2],[4,0,5]]))
print(movesToSolve([[1,4,2],[3,0,5],[6,7,8]]))
print(movesToSolve([[1,0,2],[3,4,5],[6,7,8]]))
print(movesToSolve([[2,7,1],[6,3,5],[0,4,8]]))
print(movesToSolve([[0,4,2],[3,1,5],[6,7,8]]))
The file mutate_matrix.py contains:
def rotate90Clockwise(A):
    N = len(A)
    for i in range(N // 2):
        for j in range(i, N - i - 1):
            temp = A[i][j]
            A[i][j] = A[N - 1 - j][i]
            A[N - 1 - j][i] = A[N - 1 - i][N - 1 - j]
            A[N - 1 - i][N - 1 - j] = A[j][N - 1 - i]
            A[j][N - 1 - i] = temp
    return  A

def mainDiagonal(mat):
    for i in range(len(mat)):
        for j in range(i + 1):
            temp = mat[i][j]
            mat[i][j] = mat[j][i]
            mat[j][i] = temp
    return mat


def reverseDiagonal(mat):
    for i in range(len(mat)):
        for j in range(len(mat) - i):
            tmp = mat[i][j]
            mat[i][j] = mat[(len(mat) - 1) - j][(len(mat) - 1) - i]
            mat[(len(mat) - 1) - j][(len(mat) - 1) - i] = tmp
    return mat

def rotateMatrix(mat, N):
    for x in range(0, int(N / 2)):

        for y in range(x, N - x - 1):
            temp = mat[y][x]

            mat[y][x] = mat[N - 1 - x][y]

            mat[N - 1 - x][y] = mat[N - 1 - y][N - 1 - x]

            mat[N - 1 - y][N - 1 - x] = mat[x][N - 1 - y]

            mat[x][N - 1 - y] = temp
    return mat


def flipimage(mat):
    for i in range(len(mat)):
        for j in range(i + 1):
            temp = mat[i][j]
            mat[i][j] = mat[j][i]
            mat[j][i] = temp
    return mat


def flipimage2(mat):
    for i in range(len(mat)):
        for j in range(len(mat) - i):
            tmp = mat[i][j];
            mat[i][j] = mat[(len(mat) - 1) - j][(len(mat) - 1) - i];
            mat[(len(mat) - 1) - j][(len(mat) - 1) - i] = tmp
    return mat


def query_matrix(mat, q):
    for i in range(len(q)):
        if q[i] == 0:
            mat = rotateMatrix(mat, len(mat))
        elif q[i] == 1:
            mat = flipimage(mat)
        else:
            mat = flipimage2(mat)
    return mat



#mat = [[1,2,3],[4,5,6],[7,8,9]]
#mat = [[11,2,9,1],[17,4,0,32],[1,7,10,6],[80,3,5,14]]
mat = [[5,5],[1,2]]

'''
mat = rotate90Clockwise(mat).copy()
print(mat)
#print(x)
mat = mainDiagonal(mat).copy()
print(mat)
#print(y)


print(reverseDiagonal(mat))


'''

#print(mainDiagonal(mat))
q = [2,0,2,0,1]
#q = [0,1,2,0]
for i in range(len(q)):
    if q[i] == 0:
        mat = rotate90Clockwise(mat)
    elif q[i] == 1:
        mat = mainDiagonal(mat)
    else:
        mat = reverseDiagonal(mat)
    print(q[i],mat)
print("-----------------------------")
The file nailsHammered.py contains:
def Solution(A, K):
    n = len(A)
    best = 0
    count = 1

    for i in range(n - K - 1):
        if (A[i] == A[i + 1]):
            count = count + 1
        else:
            count = 1 # Changes
        best = max(best, count)

    result = best + K # Changes
    return result


def Solution1(A,K):
    n = len(A)
    best = 0
    count = 1
    for i in range(n-K-1):
        if (A[i]==A[i+1]):
            count = count+1
        else:
            count = 0
        best = max(best,count)
    if count == 0 and best == 1:
        result = best + K
    else:
        result = best+1+K
    return result

#A= [1,1,3,3,3,4,5,5,5,5]
#A= [1,1,3,3,3,5,6,7]
#A=[1,2]
A =[]
#A = [1,2,3,4,5]
#A = [3,3,3,4]
#A = [1,2,3,4,4,5,5,7,7]
K = 0
print(Solution(A,K))
The file nary_bfs_traverse.py contains:
class NewNode:
    def __init__(self,root):
        self.val = root
        self.child= []

class bfs:
    res = 0
    def traverse(self,r):
        queue = []
        if r:
            queue.append(r)
        while len(queue)>0:
            data = queue.pop(0)
            self.res +=data.val
            for i in range(len(data.child)):
                    queue.append(data.child[i])

        return self.res



if __name__ == '__main__':
    root = NewNode(1)
    root.child.append(NewNode(2))
    root.child.append(NewNode(3))
    root.child.append(NewNode(4))
    root.child[0].child.append(NewNode(5))
    root.child[0].child[0].child.append(NewNode(10))
    root.child[0].child.append(NewNode(6))
    root.child[0].child[1].child.append(NewNode(11))
    root.child[0].child[1].child.append(NewNode(12))
    root.child[0].child[1].child.append(NewNode(13))
    root.child[2].child.append(NewNode(7))
    root.child[2].child.append(NewNode(8))
    root.child[2].child.append(NewNode(9))
    b = bfs()
    print(b.traverse(root))
The file nonpalindrom.py contains:
pali = 'ada'

new_string = ""

replaced = False
#if len(pali)==3 and if pali[0]=='a'
for i, c in enumerate(pali):
    if not replaced:
        if c > 'a' and (len(pali)//2 != i or len(pali)%2 == 0):
            new_string += 'a'
            replaced = True
        else:
            new_string += c
    else:
        new_string += c


if new_string == pali:
    print ("IMPOSSIBLE")
else:
    print ("new non palindrome lexicographically smaller string:", new_string)
The file numberOfTokens.py contains:
def numberOfTokens(expiryLimit, commands):
    # Write your code here
    values = dict()
    time = 0

    for c in commands:
        #  extraction values
        action = c[0]
        token_id = c[1]
        time = c[2]

        #  set token
        if action == 0:
            values[token_id] = expiryLimit + time

        #  reset token
        elif action == 1:
            # check if token exists
            if token_id in values.keys():
                expiry_time = values.get(token_id)
                if expiry_time >= time:
                    values[token_id] = values.get(token_id) + expiryLimit - (expiry_time - time)

    # counting values alive after reading all the values
    count = sum(1 for i in values.values() if i >= time)
    return count


print(numberOfTokens(4,[[0,1,1],[0,2,2],[1,1,5],[1,2,7]]))
print(numberOfTokens(3,[[0,1,1],[1,1,4],[1,2,5]]))
The file occurencesInSubarray.py contains:
#----- Occurrences in Subarrays ------

from collections import Counter
def occurrencesInSubarrays_1(arr, m):
    res = []
    i = 0
    while i <= len(arr) - m:
        if (i+m <= len(arr)):
            most_common, num_most_common = Counter(arr[i:i+m]).most_common(1)[0]
            res.append(num_most_common)
        i += 1
    return res

def occurrencesInSubarrays(arr,m):
    res = []
    i = 0
    while i <= len(a) - m:
        lst = a[i:i + m]
        res.append(max(set(a[i:i + m]), key=lst.count))
        i += 1
    return res


#a = [1,3,2,2,3]
#a = [1,2]
a = [2,1,2,3,3,2,2,2,2,1]
#m = 2
m = 3
res = []
print(len(a))
print(occurrencesInSubarrays(a,m))
print(occurrencesInSubarrays_1(a,m))


The file oneToHundredWithoutRecursion.py contains:
def printNumbers(num):
    res = []
    def helper(i):
        if i==num:
            res.append(i)
        else:
            res.append(i)
            helper(i+1)

    helper(1)
    return res

n = 100
print(printNumbers(n))




The file oppositeSum.py contains:
def reverse(Number):
    Reverse = 0
    while (Number > 0):
        Reminder = Number % 10
        Reverse = (Reverse * 10) + Reminder
        Number = Number // 10
    return (Reverse)


def oppositesum(arr):
    output = 0
    pairs = set()
    rev = {}
    #     arr = list(set(arr))
    for i in range(len(arr)):

         += 1
        if arr[i] not in rev.keys():
            rev[arr[i]] = reverse(arr[i])
        for j in range(i + 1, len(arr)):
            if arr[j] not in rev.keys():
                rev[arr[j]] = reverse(arr[j])
            if (arr[i], arr[j]) in pairs:
                output += 1
            elif (arr[i] + rev[arr[j]]) == (rev[arr[i]] + arr[j]):
                pairs.add((arr[i], arr[j]))
                output += 1
    return output

if __name__ == '__main__':
    print(oppositesum([1,20,2,11]))
The file optimalUtilization.py contains:
def find(F, B, T):
    ans = [0, 0, 0]
    F = sorted([x, i] for i, x in F)
    for idy, y in B:
        f = 0
        end = len(F)
        z = T - y
        while f != end:
            m = (int)((f + end) / 2)
            if F[m][0] <= z:
                f = m + 1
            else:
                end = m
        if f != 0 and y + F[f - 1][0] > ans[0]:
            ans = [y + F[f - 1][0], F[f - 1][1], idy]
    return ans[1:]


print(find([[1,8],[2,15],[3,9]],[[1,8],[2,11],[3,12]],20))
The file parking_dilemma.py contains:
def carParkingRoof(cars, k):
    result = float("inf")

    n = len(cars)
    # Sorting the array.
    cars.sort()

    # Find minimum value among
    # all K size subarray.
    for i in range(n - k + 1):
        result = int(min(result, cars[i + k - 1] - cars[i] + 1))
    return result



print(carParkingRoof([2,10,8,17],3))
print(carParkingRoof([1,2,3,10],4))
The file pathWithMaxMinValue.py contains:
import  math
import heapq
if __name__ == '__main__':
    #arr = [[5,4,5],[1,2,6],[7,4,6]]
    #arr = [[3,4,6,3,4],[0,2,1,1,7],[8,8,3,2,7],[3,2,4,9,8],[4,1,2,0,0],[4,6,5,4,3]]
    #arr = [[2, 2, 1, 2, 2, 2], [1, 2, 2, 2, 1, 2]]
    arr = [[2, 0, 5, 2, 0], [2, 4, 4, 4, 3], [1, 5, 0, 0, 0], [5, 4, 4, 3, 1], [1, 3, 1, 5, 3]]
    q = [(-arr[0][0],0,0)]
    total = math.inf
    visited = set()
    while q:
        val, i ,j = heapq.heappop(q)
        visited.add((i,j))
        if -val<total:
            total = -val
        x = [1, -1, 0, 0]
        y = [0, 0, 1, -1]
        if i ==len(arr)-1 and j == len(arr[0])-1:
            break
        for ele in range(4):
            if 0 <= i + x[ele] < len(arr) and 0 <= j + y[ele] < len(arr[0]) and (i + x[ele], j + y[ele]) not in visited:
                heapq.heappush(q,(-arr[i + x[ele]][j + y[ele]],i + x[ele],j + y[ele]))


    print(total)
    print(visited)









    '''
    arr = [[2, 0, 5, 2, 0], [2, 4, 4, 4, 3], [1, 5, 0, 0, 0], [5, 4, 4, 3, 1], [1, 3, 1, 5, 3]]
    total = []
    path = [[0,0]]
    q = [[0,0]]
    while q:
        data = q.pop(0)
        #print(data)
        i = data[0]
        j = data[1]
        if i==len(arr)-1 and j== len(arr[0])-1:
            break
        if [i,j] in path:
            print("----",i,j,"-----")
            maxNum = -math.inf
            maxNumCord = (0, 0)
            num = arr[i][j]
            x = [1,-1,0,0]
            y = [0,0,1,-1]
            for ele in range(4):
                if 0<=i+x[ele]<len(arr) and 0<=j+y[ele]<len(arr[0]) and [i+x[ele],j+y[ele]] not in path:
                    print(i + x[ele],j+y[ele])
                    if [i + x[ele],j+y[ele]] ==[len(arr)-1,len(arr[0])-1]:
                        maxNum = arr[i + x[ele]][j + y[ele]]
                        maxNumCord = [i + x[ele], j + y[ele]]
                        break
                    if arr[i+x[ele]][j+y[ele]] > maxNum:
                        maxNum = arr[i + x[ele]][j+y[ele]]
                        maxNumCord = [i + x[ele], j+y[ele]]
        print(maxNumCord,maxNum)
        if maxNumCord not in path:
            path.append(maxNumCord)
            q.append(maxNumCord)
            total.append(maxNum)

    print(path)
    print(min(total))
    print(len(path)-1)

    if i+1<len(arr) and arr[i+1][j]>maxNum and [i+1,j] not in path:
        maxNum = arr[i+1][j]
        maxNumCord = [i+1,j]
    if i-1>=0 and arr[i-1][j] > maxNum  and [i-1,j] not in path:
        maxNum = arr[i - 1][j]
        maxNumCord = [i-1,j]
    if j+1<len(arr[0]) and arr[i][j+1]>maxNum and [i,j+1] not in path:
        print(arr[i][j+1])
        maxNum = arr[i][j+1]
        maxNumCord = [i,j+1]
    if j-1>=0 and arr[i][j-1]>maxNum  and [i,j-1] not in path:
        maxNum = arr[i][j-1]
        maxNumCord = [i,j-1]

'''
The file Piyusha_7_11.py contains:
# fruits = ['mango','guava','pinapple','pomegranate']
#
# fruity = []
# for f in fruits:
#     fruity.append(f.capitalize())
#     fruity.sort()
#     #sorted(fruity)
#     #print(' '.join(fruity))
#
#
# l1 = ['Tom','Mott',1985,1986]
# l2 = [6,7,8,3,5]
# #print('l2[0]:',l1[1])
#
# #a = [1,2,1,3,-1,1,2,2]
# #a = [-2,-5,4,4,4,3,3,3]
#
#
# from sys import stdin
#
# def myFunc(a):
#     d = {}
#     for i in range(len(a)):
#         if a[i] in d:
#             d[a[i]] = d[a[i]] + 1
#         else:
#             d[a[i]] = 1
#     max_num = max(d.values())
#     temp = 100000
#     print(d)
#     for k, v in d.items():
#         if d[k] == max_num and k < temp:
#             temp = k
#     print("Max Value is: -",temp)
#
# array = []
# for line in stdin:
#     n = int(line)
#     array.append(n)
#
# myFunc(array)
#
# #############################################################
# ######################### Round 2 ###########################
# #############################################################
#
#
# class classA:
#   def __init__(self,x,y):
#     self.a = x+y
#
# x = classA(1,2)
# y =getattr(x,'a')
# setattr(x,'a',y+1)
# print(x.a)
class Bucket:
    def __init__(self):
        self.bucket = []

    def get(self, key):
        for (k, v) in self.bucket:
            if k == key:
                return v
        return -1

    def update(self, key, value):
        found = False
        for i, kv in enumerate(self.bucket):
            if key == kv[0]:
                self.bucket[i] = (key, value)
                found = True
                break

        if not found:
            self.bucket.append((key, value))

        print(self.bucket)

    def remove(self, key):
        for i, kv in enumerate(self.bucket):
            if key == kv[0]:
                del self.bucket[i]


class MyHashMap(object):

    def __init__(self):
        self.key_space = 2069
        self.hash_table = [Bucket() for i in range(self.key_space)]


    def put(self, key, value):
        hash_key = key % self.key_space
        self.hash_table[hash_key].update(key, value)


    def get(self, key):
        hash_key = key % self.key_space
        return self.hash_table[hash_key].get(key)


    def remove(self, key):
        hash_key = key % self.key_space
        self.hash_table[hash_key].remove(key)


hashMap = MyHashMap()
hashMap.put(1, 1)
hashMap.put(2, 2)
print("hashMap.get(1)",hashMap.get(1))
print("hashMap.get(3)",hashMap.get(3))
hashMap.put(2070, 3)
hashMap.put(4139, 9)
print("hashMap.get(2070)",hashMap.get(2070))

The file Piyusha_7_11_part_2.py contains:
def countBits(a, b):
    count = 0
    while (a or b):
        last_bit_a = a & 1
        last_bit_b = b & 1
        if (last_bit_a != last_bit_b):
            count += 1
        a = a >> 1
        b = b >> 1
    return count
a = 6
b = 9
print(countBits(a, b))

################################

def countSetBits( n ):
	count = 0
	while n:
		count += n & 1
		n >>= 1
	return count

def FlippedCount(a , b):
	return countSetBits(a^b)

a1 = 6
b1 = 9
print(FlippedCount(a1, b1))


def ChangeBits(x,y):
    result = -404
    count = 0
    while(x or y):
        last_bit_x = x&1
        last_bit_y = y&1
        if last_bit_x != last_bit_y:
            count+=1
        x =x>>1
        y = y>>1
    result = count
    print(result)

ChangeBits(a,b)

The file Piyusha_Fractal.py contains:
def minimum_jumps(k,j):
    min_jumps = k/j
    min_jumps+=k%j
    #print(int(min_jumps))
    return int(min_jumps)

def missingWords(s,t):
    s = s.split()
    t = t.split()
    length = len(s)
    for i in reversed(s):
        if i in t:
            print(i)
            temp=i
            s.remove(temp)
            t.remove(temp)
            #i-=1
    print(s)

if __name__ == '__main__':
    print(minimum_jumps(3,1))
    print(minimum_jumps(8,3))
    print(minimum_jumps(3,3))

    #missingWords("Sumedh Joglekar","Sumedh")
    #missingWords("I am am using HackerRank to improve programming", "am HackerRank to improve")
    missingWords("Python is an easy to learn powerful programming language It has efficient high-level data structures and a simple but effective approach to objectoriented programming python elegant syntax and dynamic typing","Python is an easy to learn powerful programming language")

The file Pizza_Treats.py contains:


def pizzaTreats1(ar):
    coupon2 = False
    for i in range(len(ar)):
        if (ar[i] > 0):
            if coupon2 == False:
                coupon2 = False if (ar[i] % 2) == 0 else True
            else:
                coupon2 = True if (ar[i] % 2) == 0 else False
        elif (coupon2 == True and ar[i] == 0):
            coupon2 = False
            print("NO")
            return

    if (len(ar) > 0 and coupon2 == False):
        print("YES")
    else:
        print("NO")


pizzaTreats1([1,0,1])
pizzaTreats1([2,3,3,0])
pizzaTreats1([2,3,1])
pizzaTreats1([1,2,1,2])
The file Post.py contains:
#temp = [10,20,10,15,5,30,20]
#temp = [18,5,15,18,11,15,9,7]
temp = [6,18,8,14,10,12,18,9]
#size = 5
size = 8
#k = 1
k = 3
res = 0
while size>0:
    arr = temp[:k]+temp[-k:]
    #print(arr)
    m = max(arr)
    if m in temp[:k]:
        temp.remove(m)
    else:
        temp.reverse()
        temp.remove(m)
        temp.reverse()
    res+=m
    print(res)
    size-=1
The file pratikAmazon.py contains:
given = "pasword"
s = ["pwd","aso","swd","ord"]
d = {}
for k in range(len(s)):
    word = s[k]
    for i in range(len(word)):
        if word[i] not in d:
            d[word[i]]  = []
        for j in range(i+1,len(word)):
            d[word[i]].append(word[j])

d2 =  {}
for k in range(len(s)):
    word = s[k]
    for i in range(len(word)-1,-1,-1):
        if word[i] not in d2:
            d2[word[i]]  = []
        for j in range(i-1,-1,-1):
            d2[word[i]].append(word[j])



print(d)
print(d2)




The file Pratik_DataEngineering.py contains:
ans = -4//1.5
print(ans)


a =  {'a':1,'b':2,'a':3}

print(a)

def foo(a,b,c):pass

foo = [1,2,3,4,5]

#print(foo[-len(foo)])
#print(foo[len(foo)])

print("John")
print("Charles")
print("Chris")
print("---------")
print("John\nCharles\nChris")
The file Pratik_Trend_Micro.py contains:
def MaxTime(A, B, C, D)
    ArrayElements = [A, B, C, D]


    if ArrayElements == ArrayElements - [0, 1, 2]:
        return "NOT POSSIBLE"

    TimeReturn = " : "

    if ArrayElements.include?(2):
        TimeReturn[0] = ArrayElements.delete_at(ArrayElements.find_indexOf(2)).to_s1
    elif ArrayElements.include?(1):
    TimeReturn[0] = ArrayElements.delete_at(ArrayElements.find_indexOf(1)).to_s1
    else
    TimeReturn[0] = 0.to_s1
    if ArrayElements.find_indexOf(0)
        ArrayElements.delete_at(ArrayElements.find_indexOf(0))
    end
    end

    if ArrayElements.length == 4
        return "NOT POSSIBLE"
    end

    if TimeReturn[0] == "2"
        MaxThree = (ArrayElements - [4, 5, 6, 7, 8, 9]).maxOf
    if !MaxThree
    return "NOT POSSIBLE"
    else
    TimeReturn[1] = ArrayElements.delete_at(ArrayElements.find_indexOf(MaxThree)).to_s1
    end
    end

    if TimeReturn[0] == "1" | | TimeReturn[0] == "0"
        maxOf = ArrayElements.maxOf
    TimeReturn[1] = ArrayElements.delete_at(ArrayElements.find_indexOf(maxOf)).to_s1
    end

    if ArrayElements.length == 3
        return "NOT POSSIBLE"
    end

    minute_one_permone = ArrayElements.first
    minute_two_permone = ArrayElements.last
    MnutesPerOne = ArrayElements.join("")
    minutes_permtwo = ArrayElements.reverse.join("")

    if MnutesPerOne > "59" & & minutes_permtwo > "59"
        return "NOT POSSIBLE"
    end

    if MnutesPerOne > "59" & & minutes_permtwo <= "59"
        TimeReturn[3] = minutes_permtwo[0]
    TimeReturn[4] = minutes_permtwo[1]
    elsif
    minutes_permtwo > "59" & & MnutesPerOne <= "59"
    TimeReturn[3] = MnutesPerOne[0]
    TimeReturn[4] = MnutesPerOne[1]
    else
    if MnutesPerOne > minutes_permtwo
        TimeReturn[3] = MnutesPerOne[0]
    TimeReturn[4] = MnutesPerOne[1]
    else
    TimeReturn[3] = minutes_permtwo[0]
    TimeReturn[4] = minutes_permtwo[1]
    end
    end

    if TimeReturn.split(":").join("") > "2359"
        return "NOT POSSIBLE"
    else
        return TimeReturn
    end
    end
The file primeornot.py contains:
def prime(x):
    if x<=2:
        return False
    for i in range(2,x):
        if x%i==0:
            return False

    return True



if __name__ == '__main__':
    print(prime(10))
    print(prime(2))
    print(prime(5))
    print(prime(3))
The file Prime_String.py contains:

def check_prime(a):
    for i in range(2, a):
        if a % i == 0:
            return False
    return True

def find_next_prime(n):
    low = n - 1
    high = n + 1
    while True:
        if check_prime(low):
            return low
        elif check_prime(high):
            return high
        else:
            low -= 1
            high += 1

s = "CABa"
strs = ""
for i in range(len(s)):
    if not check_prime(ord(s[i])):
        a = find_next_prime(ord(s[i]))
        strs = strs + chr(a)
    else:
        strs = strs + s[i]
print(strs)
The file printAncestors.py contains:
class Node:
    def __init__(self,root):
        self.val = root
        self.left =None
        self.right = None

from collections import defaultdict
def printAncestors(node,val):
    q = []
    parent  = defaultdict()
    if node:
        q.append(node)
        parent[node.val] = None
        while q:
            data = q.pop(0)
            if data.left:
                parent[data.left.val] = data.val
                q.append(data.left)
            if data.right:
                parent[data.right.val] = data.val
                q.append(data.right)
        print(parent)
    res = []
    while parent[val]:
        res.append(parent[val])
        val = parent[val]

    print(res)





if __name__ == '__main__':
    # Driver program to test above function
    root = Node(1)
    root.left = Node(2)
    root.right = Node(3)
    root.left.left = Node(4)
    root.left.right = Node(5)
    root.left.left.left = Node(7)

    printAncestors(root, 7)
The file product_minus_sum.py contains:
def getProduct(n):
    product = 1
    while (n != 0):
        product = product * (n % 10)
        n = n // 10
    print(product)
    return product

def sumList(n):
    sum = 0
    while (n != 0):
        sum = sum + (n % 10)
        n = n // 10
    print(sum)
    return sum

# = 123456
n = 1010
print(getProduct(n)-sumList(n))
The file pythonAsOOPS.py contains:
class A:
    def __init__(self):
        print("Initializing A")

    def method1(self,a,b):
        print(a,b)

class B(A):
    def __init__(self):
        print("Initializing B")

    def method1(self,a,b):
        print(a-b)


class C(B):
    def __init__(self):
        print("Initializing B")

    def method1(self,a,b,c):
        print(a,b,c)

class D:
    def __init__(self):
        print("Initializing C")

    def method1(self,a):
        print(a)

############### Multiple Inheritance ##############

class E(B,D):

    def __init__(self):
        print("Initializing E")

    def method1(self,a,b,c):
        print(a,b,c)

if __name__ == '__main__':
    a = A()
    b = B()
    c = C()
    e = E()
    a.method1(2,3)
    b.method1(2,3)
    c.method1(2,1,4)
    e.method1(1,2,3)


The file readingVertically.py contains:
from collections import defaultdict
arr= ["Daisy","Rose","Hyacinth","Poppy"]
d= defaultdict(list)
res =""
for i in range(len(arr)):
    for j in range(len(arr[i])):
        d[j].append(arr[i][j])
for k,v in d.items():
    for elements in range(len(v)):
        res+=v[elements]
print(res)

The file read_json.json contains:
{
  "destination_addresses": [
    "Washington, DC, USA",
    "Philadelphia, PA, USA",
    "Santa Barbara, CA, USA",
    "Miami, FL, USA",
    "Austin, TX, USA",
    "Napa County, CA, USA"
  ],
  "origin_addresses": [
    "New York, NY, USA"
  ],
  "rows": [{
    "elements": [{
        "distance": {
          "text": "227 mi",
          "value": 365468
        },
        "duration": {
          "text": "3 hours 54 mins",
          "value": 14064
        },
        "status": "OK"
      },
      {
        "distance": {
          "text": "94.6 mi",
          "value": 152193
        },
        "duration": {
          "text": "1 hour 44 mins",
          "value": 6227
        },
        "status": "OK"
      },
      {
        "distance": {
          "text": "2,878 mi",
          "value": 4632197
        },
        "duration": {
          "text": "1 day 18 hours",
          "value": 151772
        },
        "status": "OK"
      },
      {
        "distance": {
          "text": "1,286 mi",
          "value": 2069031
        },
        "duration": {
          "text": "18 hours 43 mins",
          "value": 67405
        },
        "status": "OK"
      },
      {
        "distance": {
          "text": "1,742 mi",
          "value": 2802972
        },
        "duration": {
          "text": "1 day 2 hours",
          "value": 93070
        },
        "status": "OK"
      },
      {
        "distance": {
          "text": "2,871 mi",
          "value": 4620514
        },
        "duration": {
          "text": "1 day 18 hours",
          "value": 152913
        },
        "status": "OK"
      }
    ]
  }],
  "status": "OK"
}
The file recursivelySquare.py contains:
def square(x,a):
    if a == 0:
        return 1
    if a ==1:
        return x

    return x*square(x,a-1)


if __name__ == '__main__':
    print(square(2,0))
The file removeOnedigit.py contains:
s = "ab12c"
#t = "1zz456"
t  = "ab24z"
def removeOneDigit(s,t):
    sList = list(s)
    tList = list(t)
    count = 0
    for i in range(len(tList)):
        tl = tList.copy()
        if tList[i].isdigit():
            tl.pop(i)
            if s < ''.join(tl):
                count+=1
    for i in range(len(sList)):
        sl = sList.copy()
        if sList[i].isdigit():
            sl.pop(i)
            if ''.join(sl) < t:
                count+=1
    return count


print(removeOneDigit(s,t))
The file restockingtheWarehouse.py contains:
def restock(itemCount,target):
    keepingAdding=0

    for i in range(len(itemCount)):
        keepingAdding+=itemCount[i]
        if keepingAdding>=target:
            break

    if keepingAdding>=target:
        return keepingAdding-target
    else:
        return target-keepingAdding


if __name__ == '__main__':
    print(restock([10,20,30,40,15],80))
    print(restock([6,1,2,1], 100))
    print(restock([1,2,3,2,1], 4))
The file reverseALinkedList.py contains:
class ListNode:
    def __init__(self,x):
        self.val = x
        self.next  =None

class LinkedList:

    def __init__(self):
        self.head =  None


    def addFirst(self,x):
        new_node = ListNode(x)
        new_node.next  = self.head

        self.head = new_node

    def printAll(self):
        last = self.head
        while last:
            print(last.val)
            last = last.next

    def push(self,x):
        new_node = ListNode(x)
        new_node.next= None
        last = self.head
        while last.next:
            last = last.next
        last.next = new_node

    def reverseLL(self):
        prev = None
        curr = self.head
        while curr:
            nxt = curr.next
            curr.next = prev
            prev = curr
            curr = nxt

        self.head = prev


        '''
        prev = None
        current = self.head
        while current is not None:
            nxt = current.next
            current.next = prev
            prev = current
            current = nxt
        self.head = prev
        '''



if __name__ == '__main__':
    l = LinkedList()

    l.addFirst(1)
    l.addFirst(2)
    l.addFirst(3)
    l.addFirst(4)
    l.push(5)
    l.printAll()
    print("---------------------")
    l.reverseLL()
    l.printAll()

The file ReverselevelordertraversalN-ary tree.py contains:
'''
Level Order traversal of  N ary tree and reverse the level
'''
import  collections
class NewNode:
    def __init__(self,root):
        self.val = root
        self.child = []


def travverse(node):
    q = collections.deque()
    q.append(node)
    s = []
    while q:
        n = q.popleft()
        for i in range(len(n.child)):
            q.append(n.child[i])

        s.insert(0,n.val)

    print(s)



if __name__ == '__main__':
    root = NewNode('A')
    root.child.append(NewNode('B'))
    root.child.append(NewNode('C'))
    #root.child.append(NewNode(4))
    root.child[0].child.append(NewNode('D'))
    root.child[0].child[0].child.append(NewNode('H'))
    root.child[0].child.append(NewNode('E'))
    root.child[1].child.append(NewNode('F'))
    root.child[1].child.append(NewNode('G'))
    root.child[0].child[0].child[0].child.append(NewNode('I'))
    #root.child[0].child[1].child.append(NewNode(11))
    #root.child[0].child[1].child.append(NewNode(12))
    #root.child[0].child[1].child.append(NewNode(13))
    #root.child[2].child.append(NewNode(7))
    #root.child[2].child.append(NewNode(8))
    #root.child[2].child.append(NewNode(9))

    travverse(root)



The file reverseString.py contains:
def reverseString1(x):
    res=""
    for i in x:
        res = i+res

    print(res)

def reverseString2(x):
    res =[]
    finalOP=[]
    for i in x:
        res.append(i)
    while res:
        finalOP.append(res.pop())

    print(''.join(finalOP))


def reverseString3(x):
    print(x[::-1])


if __name__ == '__main__':
    s = "EAITechnology"
    reverseString1(s)
    reverseString2(s)
    reverseString3(s)
    #reverseString1("")
The file romanToInt.py contains:
def romanToInt(s):
    num = 0
    my_funcs = {
        'I': (lambda num: -1 if num >= 5 else 1),
        'V': (lambda num: 5),
        'X': (lambda num: -10 if num >= 50 else 10),
        'L': (lambda num: 50),
        'C': (lambda num: -100 if num >= 500 else 100),
        'D': (lambda num: 500),
        'M': (lambda num: 1000)
    }
    for el in reversed(list(s)):
        # print(el)
        num += my_funcs[el](num)

    return num


#s = ['Louis VIII','Louis VII']
s = ['Philippe I','Philip II']
for i in range(len(s)):
    a =(s[i].split(' '))
    a[1]=str(romanToInt(a[1]))
    a = ''.join(a)
    s[i]=a


#print(s)

print(sorted(s))
The file runLengthEncoding.py contains:
if __name__ == '__main__':
    x = "wwwwaaadexxxxxx"
    op = "w4a3d1e1x6"
    d = {}
    res = ""
    for i in range(len(x)):
        if x[i] in d.keys():
            d[x[i]]+=1
        else:
            d[x[i]] = 1
    print(d)

    for k,v in d.items():
        res+=k+str(v)

    print(res)



The file SAP_SVNT_minDaysToConnectAllCities.py contains:
from collections import deque
import math

def bfs(grid, start,goal):
    queue = deque([[start]])
    seen = set([start])
    while queue:
        path = queue.popleft()
        x, y= path[-1]
        if (x,y) == goal:
            return path
        for x2, y2 in ((x+1,y), (x-1,y), (x,y+1), (x,y-1)):
            if 0 <= x2 < len(grid[0]) and 0 <= y2 < len(grid) and grid[x2][y2] != '#' and (x2, y2) not in seen:
                queue.append(path + [(x2, y2)])
                seen.add((x2, y2))

def minDays(grid,visited,output):
    src=deque()
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == '$':
                pos = [i, j, 0]
                src.appendleft(pos)
    #print(src)
    while len(src)>0:
        curr = src.pop()
        x,y,dist= curr[0],curr[1],curr[2]
        if x+1<len(grid)and visited[x+1][y] == False  and grid[x+1][y]!='#':
            output[x+1][y] = min(output[x+1][y],dist+1)
            src.appendleft((x+1,y,dist+1))
            visited[x+1][y] = True

        if x-1>=0 and visited[x-1][y] == False and grid[x-1][y]!='#':
            output[x - 1][y] = min(output[x-1][y], dist+ 1)
            src.appendleft((x-1,y,dist+1))
            visited[x-1][y] = True

        if y+1<len(grid[0]) and visited[x][y+1] == False and grid[x][y+1]!='#':
            output[x][y+1] = min(output[x][y+1],dist + 1)
            src.appendleft((x,y+1,dist+1))
            visited[x][y+1] = True

        if y-1>=0 and visited[x][y-1] == False  and grid[x][y-1]!='#':
            output[x][y-1] = min(output[x][y-1],dist + 1)
            src.appendleft((x,y-1,dist+1))
            visited[x][y-1] = True


if __name__ == '__main__':
    #g = [['$', '.', '.', '#'],['.', '.', '#', '.'],['#', '.', '$', '.'],['$', '.', '.', '.']]
    g = [['$', '.', '.', '#'],['.', '.', '#', '.'],['#', '.', '$', '.'],['.', '.', '.', '.']]
    #g = [['$','#'],['$','.']]
    visited = [[False for i in range(len(g))] for i in range(len(g[0]))]
    output = [[-1 for i in range(len(g))] for i in range(len(g[0]))]
    src= []
    p = {}
    for i in range(len(g)):
        for j in range(len(g[0])):
            if g[i][j] == '$':
                src.append([(i,j),math.inf])
    for i in range(len(src)):
        for j in range(i+1,len(src)):
            temp = bfs(g,src[i][0],src[j][0])
            if len(temp)<src[i][1]:
                src[i][1] = len(temp)
                p[src[i][0]] = temp
                p[src[j][0]] = temp
    for k,v in p.items():
        for j in range(len(v)):
            output[v[j][0]][v[j][1]] = max(output[v[j][0]][v[j][1]],j)
            visited[v[j][0]][v[j][1]] = True
    print(output)
    for i in range(len(output)):
        for j in range(len(output[0])):
            if output[i][j] == -1:
                output[i][j] = math.inf

    print(visited)
    minDays(g, visited,output)
    total = 0
    for i in range(len(output)):
        for j in range(len(output)):
            if output[i][j] !=math.inf:
                total+=output[i][j]

    print(total)









The file sdeamazon.py contains:
def leftrotate(string,amount):
    s = list(string)
    amount = amount%len(s)
    s = s[amount:]+s[:amount]
    return  s

def rightrotate(string,amount):
    amount = amount%len(string)
    return  leftrotate(string,len(string)-amount)

def rotatestring(originalstring,direction,amount):
    s = originalstring
    for i in range(len(direction)):
        if direction[i] ==0:
            s = leftrotate(s,amount[i])
        else:
            s = rightrotate(s,amount[i])

    return ''.join(s)


#if __name__ == '__main__':



'''
s = "rthura"

print("-------",s.copy())   
s = list(s)
print(len(s))
a = s[5:] + s[:5]
print(a)

#print("",s.copy())



s = "rthura"
s = list(s)
a = s[5:] + s[:5]
print(a)
'''
The file segmentCovering.py contains:
def segmentCovering(listOfTuples):
    sortedBeg = sorted(listOfTuples, key=lambda x: x[0])
    sortedEnd = sorted(listOfTuples, key=lambda x: x[1])
    print("Sorting on the basis of 1st value: - ",sortedBeg,"\nSorting on the basis of 2nd value: - ",sortedEnd)
    thrhold = sortedBeg[0][0] - 1
    print("Initial threshold: -",thrhold)
    listOfPoints = []
    for i in range(len(sortedEnd) - 1):
        beg, end = sortedEnd[i]
        if beg > thrhold:
            listOfPoints.append(end)
            thrhold = end
            print("Updating Threshold:- ",thrhold)
        if listOfPoints[len(listOfPoints) - 1] < sortedEnd[len(sortedEnd) - 1][0]:
            if sortedEnd:
                print(sortedEnd[len(sortedEnd) - 1][0])
                listOfPoints.append(sortedEnd[len(sortedEnd) - 1][0])
        print((listOfPoints))
    return len(listOfPoints)


def segmentCovering_1(listOfTuples):

    sortedBeg = sorted(listOfTuples, key=lambda x: x[0])
    sortedEnd = sorted(listOfTuples, key=lambda x: x[1])
    print(sortedEnd[len(sortedEnd) - 1])

    thrhold = sortedBeg[0][0] - 1
    listOfPoints = []
    for i in range(len(sortedEnd) - 1):
        beg, end = sortedEnd[i]
        if beg > thrhold:
            listOfPoints.append(end)
            thrhold = end
    print(listOfPoints)

    if(len(listOfPoints)) == 0:return 0

    if listOfPoints[len(listOfPoints) - 1] < sortedEnd[len(sortedEnd) - 1][0]:
        if sortedEnd:
            listOfPoints.append(sortedEnd[len(sortedEnd) - 1][0])
    #print(len(listOfPoints))
    result = []
    for p in listOfPoints:
        result.append(p)

    return len(result)
#segment = [[-1,3],[-5,-3],[3,5],[2,4],[-3,-2],[-1,4],[5,5]]
#segment = [[-2,1], [-1,0], [0,1], [1,2]]
segment = [[-1000000000, 1000000000]]
print(segmentCovering_1(segment))
The file send_mail_from_local.py contains:
import smtplib, ssl
'''
port = 587  # For starttls
smtp_server = "smtp.gmail.com"
sender_email = "joglekarsumedh@gmail.com"
receiver_email = "sjogleka@uncc.edu"
password = input("Type your password and press enter:")
message = """\
Subject: Hi there

This message is sent from Python."""

context = ssl.create_default_context()
with smtplib.SMTP(smtp_server, port) as server:
    server.ehlo()  # Can be omitted
    server.starttls(context=context)
    server.ehlo()  # Can be omitted
    server.login(sender_email, password)
    server.sendmail(sender_email, receiver_email, message)
'''
fromaddr = 'joglekarsumedh@gmail.com'
toaddrs  = ['joglekarsumedh@gmail.com']
msg = '''
    From: {fromaddr}
    To: {toaddr}
    Subject: testin'     
    This is a test 
    .
'''
server.starttls()
print("Connection Opened")
server.ehlo("joglekarsumedh@gmail.com")
server.mail(fromaddr)
server.rcpt(toaddrs[0])
server.data(msg)
server.quit()
The file ShallowVsDeep_Copy.py contains:
import copy

if __name__ == '__main__':
    array1 = [1,2,2,5,6,7]
    ########################################### Assignment ###################################################
    print("###################### Assignment ##################")
    array2 = array1
    print("Before Change Array 1:-", array1)
    print("Before Change Array 2:-", array2)
    array2[1]=4
    print("Array 1 after change in array2:-",array1)
    print("Array 2 after change in array2:-", array2)
    array1[2]=3
    print("After change in array 1 Array 1:-", array1)
    print("After Change in array 1 Array 2:-", array2)
    ############################################## Deep Copy ##################################################
    print("###################### Deep copy ##################")
    array3 = copy.deepcopy(array1)
    array3[2]=10
    print("After Deep Copy",array1)
    print("After Deep Copy", array3)
    ################################################# Shallow Copy ##########################################
    print("###################### Shallow copy ##################")
    array4 = copy.copy(array1) ## Shallow copy using copy.
    print("Address of array 1:-",id(array1),"Address of array 4:-",id(array4)) ## Print address of array 1 and array4
    print("Before Change Array 1:-", array1)
    print("Before Change Array 2:-", array4)
    array1[0] = 500
    print("After Shallow Copy", array1)
    print("After Shallow Copy", array4)
    print("--------------------------------------")
    #################################### Special Case List of list ###############################
    ##### This is the actual difference between shallow copy and deep copy ########
    array5 = [[1,2,3],[4,5]]
    array6 = copy.copy(array5)
    print("Before Shallow Copy", array5)
    print("Before Shallow Copy", array6)
    array6[0][1] = 4
    print("After Shallow Copy Change", array5)
    print("After Shallow Copy Change", array6)
    print("ID of a[0]a[1]",id(array5[0]),id(array5[1]),"\nID of b[0]b[1]",id(array6[0]),id(array6[1]))
    print("Id A",id(array5),"Id of B",id(array6))
    print("--------------------------------------")
    array7 = copy.copy(array1)
    print("ID A :- ",id(array1),"ID B :- ",id(array7))

    #### Ref :- https://medium.com/@thawsitt/assignment-vs-shallow-copy-vs-deep-copy-in-python-f70c2f0ebd86 ####

The file snake_string.py contains:
### Print String sinusoidally ######
'''

e.g
 S = Hello_World


    E               _               L           ------------- 1st row
H       L       O       W       R       D       ------------- 2nd row
            L               O                   ------------- 3rd row

op = E_LHLOWRDLO

By Observation:-
1st row index = S[1],S[5] -- diff = 4
2nd row index = S[0], S[2], S[4],S[6] -- diff = 2
3rd row index = S[3],S[7] -- diff = 4
'''

def snake_string(s):
    op =[]
    if len(s)<=1:
        return s

    for i in range(1,len(s),4):
        op.append(s[i])

    for i in range(0,len(s),2):
        op.append(s[i])

    for i in range(3,len(s),4):
        op.append(s[i])

    return "".join(op)

def snake_string_1(s):

    return s[1::4]+s[::2]+s[3::4]
if __name__ == '__main__':
    print(snake_string("Hello_World"))
    print(snake_string_1("Hello_World"))
The file social_network_friends.py contains:
d = {}
#counts = [3,3,1,1,3,3,3,2,2,3,4,4,5,1,2,4,1,2,4,1,2,3]
counts = [5,5,5,3,3,1,1,2,2,1,2,1,2,3,5,5]
#counts = [1,1,1,1]
s = enumerate(counts)
import operator as op
s = sorted(s, key=op.itemgetter(1), reverse= True)
i = 0
while i < len(s):
    j = 0
    #print(s[i][1])
    while i < len(s) and j < s[i][1]:
        print(s[i][0],end=" ")
        #print(s[i][0])
        i+=1
        j+=1
    print()
The file sortMatrixByOccurences.py contains:
from collections import defaultdict
a = [[1,4,-2],[-2,3,4],[3,1,3]]


count = {}
for i in range(len(a)):
    for j in range(len(a)):
        if a[i][j] not in count:
            count[a[i][j]] = 0
        count[a[i][j]] += 1
m = []
x = defaultdict(list)
for k, v in count.items():
    x[v].append(k)

for keys in sorted(x.keys()):
    inp = sorted(x[keys])
    for digits in inp:
        m.extend(digits for x in range(keys))
print(m)
t = 0
for k in range(len(a), 0, -1):
    j = k
    i = len(a) - 1
    while (j <= len(a) - 1):
        a[i][j] = m[t]
        t += 1
        i = i - 1
        j = j + 1
for k in range(len(a) - 1, -1, -1):
    i = k
    j = 0
    while (i >= 0):
        a[i][j] = m[t]
        t += 1
        i = i - 1
        j = j + 1

print(a)
The file sort_by_frequecy_and _then_by_values.py contains:
'''from collections import Counter
def perseus_sort(l):
    counter = Counter(l)
    return sorted(l, key=lambda x: (counter[x], x))


li = [3,1,2,2,4]
print(perseus_sort(li))

'''
import heapq


def popularNToys(numToys, topToys, toys, numQuotes, quotes):
    toys_dict = {}
    for toy in toys:
        toys_dict[toy] = 0

    def toLower(quote):
        for c in quote:
            if not c.isalpha():
                quote = quote.replace(c, ' ')
        return quote.strip().lower()

    toys_count = {}
    toys_list = []

    for q in quotes:
        for word in set(toLower(q).split(' ')):
            if word in toys_dict:
                toys_dict[word] += 1

    for k, v in toys_dict.items():
        toys_list.append((-1 * v, k))

    heapq.heapify(toys_list)
    return [heapq.heappop(toys_list)[1] for x in range(topToys)]


print(popularNToys(6, 2, ["elmo", "elsa", "legos", "drone", "tablet", "warcraft"], 6,
                   ["Elmo is the hottest of the season! Elmo will be on every kid's wishlist!",
                    "The new Elmo dolls are super high quality",
                    "Expect the Elsa dolls to be very popular this year",
                    "Elsa and Elmo are the toys I'll be buying for my kids",
                    "For parents of older kids, look into buying them a drone",
                    "Warcraft is slowly rising in popularity ahead of the holiday season"]))


[""]
The file stack_using_LL.py contains:
class Node:
    def __init__(self,val):
        self.val=val
        self.next = None
class stack:
    def __init__(self):
        self.root = None

    def push(self, data):
        newnode = Node(data)
        newnode.next = self.root
        self.root = newnode

    def pop(self):
        if (self.isempty()):
            return "-1"
        temp = self.root
        self.root = self.root.next
        popped = temp.val
        return popped

    def isempty(self):
        return True if self.root is None else False


if __name__ == '__main__':
    a = [1,2,3,6,3,8,4]
    node = []
    length = len(a)
    s = stack()
    for i in range(len(a)):
        s.push(a[i])
    for i in range(len(a)):
        print (s.pop())


    '''
    for i in range(len(a)):
        node.append(Node(a[i]))
        node[i-1].next = node[i]
    print(node)
    current = node[0]
    while current!=None:
        print(current.val)
        current = current.next
    '''
The file stringAnagram.py contains:
def stringAnagram(str1,str2):
    d= {}
    for i in range(len(str1)):
        if str1[i] in d:
            d[str1[i]] +=1
        else:
            d[str1[i]] = 1

    print(d)
    for  i in range(len(str2)):
        if str2[i] in d and d[str2[i]] >0:
            d[str2[i]]-=1
        else:
            print(str2[i])
            print("Not Anagram")
            break

    return  sum(d.values())==0

if __name__ == '__main__':
    print(stringAnagram("listen","silent"))
    print(stringAnagram("triangle", "integral"))

The file stringreverse.py contains:
def reverseStr(s):
    num = str(s)
    i =0
    res =""
    if len(num) % 2 == 0:
        while i < len(num):
            res += num[i+1]+num[i]
            i=i+2
    else:
        while i < len(num)-1:
            res += num[i+1]+num[i]
            i=i+2
        res+=num[len(num)-1]
    return int(res)


print(reverseStr(1122558898))
print(reverseStr(1123))
print(reverseStr(12345))
print(reverseStr(72328))
The file String_Formation_Target_String.py contains:
from collections import OrderedDict
import itertools
def numWays(words, target):
    count = 0
    x = []
    target = list(target)
    d = OrderedDict()
    dictOrder = OrderedDict()
    for i in range(len(words)):
        temp = list(words[i])
        for j in range(len(temp)):
            if temp[j] in target:
                if temp[j] not in d:
                    d[temp[j]] = []
                d[temp[j]].append(j)
    for i in target:
        if i not in d:
            return 0
        else:
            dictOrder[i] = d[i]
    del(d)
    for i in dictOrder:
        x.append(dictOrder[i])
    res = list(itertools.product(*x))
    for i in res:
        if len(set(i))== len(target) and list(i) == sorted(i):
            count += 1
    return count


if __name__ == '__main__':
    count = 0
    # x = ["adc","aec","efg"]
    # x = ["valya","lyglb","vldoh"]
    x = ["xzu", "dfw", "eor", "mat", "jyc"]
    # target = "ac"
    # target = "val"
    target = "cf"


    print(numWays(x,target))



The file String_reversal.py contains:
a = "Sumedh"
print(len(a))
z =a[0]
for i in range(0,int(len(a)/2)):
    temp = a[len(a)-1]
    print(temp)
    #a[len(a)-1]= a[i]
    #a[i]=temp

print(a[::-1])
a =9
b =5
print(a and b)

The file strobogramaticNumber.py contains:
def findNotStobogrammaticNumbers(start,end):
    d = {"0":"0","1":"1","6":"9","8":"8","9":"6"}
    op  =[]
    for i in range(start,end+1):
        i = str(i)
        temp = ""
        for j in i:
            if j in d:
                temp+=d[j]
            else:
                temp=""
                break
        temp = temp[::-1]
        #print(i,temp)
        if i !=temp and len(temp)==len(i):
            op.append(i)

    print(op)





print(findNotStobogrammaticNumbers(1,100))
The file strokes_to_paint.py contains:
n=int(input())
s=input()
if len(set(s))==1:
    print(1)
else:
    c=0
    for i in range(len(s)-1):
        if s[i]!=s[i+1]:
            c+=1
        else:
            continue

    print(c+1)

The file subStringWithDistinct.py contains:
import collections
def subStringsWithKDistinctCharacters(s, k):
    s = list(s)
    count = 0
    right, left = 0, 0
    hmap = collections.defaultdict(int)
    for x in s:
        hmap[x] += 1

        if len(hmap) < k:
            continue

        if len(hmap) > k:
            del hmap[s[right]]
            right += 1
            left = right

        while hmap[s[right]] > 1:
            hmap[s[right]] -= 1
            right += 1
        count += right - left + 1
    return count

if __name__ == '__main__':
    print(subStringsWithKDistinctCharacters("abaca",2)
The file sum_of_odd_level.py contains:
class Node:
    def __init__(self,root):
        self.val = root
        self.left = None
        self.right = None




class bfs:
    res = []
    def oddsum(self,root):
        queue = []
        level = 0
        if root:
            queue.append((root,level))

        while len(queue)>0:
            data = queue.pop(0)
            print(data[1])
            if data[1]%2!=0:
                self.res.append(data[0].val)
            if data[0].left:
                queue.append((data[0].left,level+1))
            if data[0].right:
                queue.append((data[0].right,level+1))

            level+=1

        print(self.res)



if __name__ == '__main__':
    root = Node(1)
    root.left = Node(2)
    root.right = Node(3)
    root.left.left = Node(4)
    root.left.right = Node(5)
    traverse = bfs()
    print(traverse.oddsum(root))

The file Sum_of_prime_between_range.py contains:
from math import sqrt

def chkprime(numberToCheck):
    if numberToCheck == 1:
        return False
    for i in range(2, int(sqrt(numberToCheck)) + 1):
        if numberToCheck % i == 0:
            return False

    return True

def primeSum(l, r):
    sum = 0

    for i in range(r, (l - 1), -1):
        isPrime = chkprime(i)
        if (isPrime):
            sum += i
    return sum

if __name__ == "__main__":
    l = input()
    r = input()

    print (l)

    #l, r = 4, 13

    # Call the function with l and r
    print(primeSum(int(l), int(r)))

#primeSum(X,Y)
### Function la call kar

The file Take_data.py contains:
import os
import numpy as np
import pandas as pd
import requests
import bs4
import fastnumbers
import csv
import matplotlib.pyplot as plt
import seaborn as sns
import json
print(os.environ['PATH'])
data = pd.read_html('https://en.wikipedia.org/wiki/List_of_S%26P_500_companies')
table = data[0]
sliced_table = table[1:]
header = table.iloc[0]
corrected_table = sliced_table.rename(columns=header)
company_List = ['3M Company','Adobe Systems Inc','Allstate Corp','Amazon.com Inc.','Apple Inc.','American Express Co','JPMorgan Chase & Co.','Visa Inc.','Xilinx','Facebook, Inc.']
corrected_table = corrected_table[corrected_table.Security.isin(company_List)]
#print(len(company_List))
#corrected_table
tickers = corrected_table['Symbol'].tolist()
print (tickers)
s,s2 = 'https://www.worldtradingdata.com/api/v1/stock?symbol=','https://www.worldtradingdata.com/api/v1/stock?symbol='
for i in range(0,len(tickers)-6):
    s = s + tickers[i] + ','
s = s + tickers[len(tickers)-6] + '&api_token=p4nU2OENDDJfkKP6TePnfKAgI4W5sz2GQmsVBehWiAjwLN6srpgbqp8lfiaV'
print(s)
for i in range(len(tickers)-5,len(tickers)-1):
    s2 = s2 + tickers[i] + ','
s2 = s2 + tickers[-1] + '&api_token=p4nU2OENDDJfkKP6TePnfKAgI4W5sz2GQmsVBehWiAjwLN6srpgbqp8lfiaV'
print(s2)
################# Call get method to take response from URL ###################
#response = requests.get("https://www.worldtradingdata.com/api/v1/stock?symbol=AAPL,MSFT,HSBA.L&api_token=demo", timeout=240)
response = requests.get(s, timeout=240)
response2 = requests.get(s2, timeout=240)
#response.status_code
print(response.content)
print(response2.content)
############### Convert the content to json ################
content = response.json()
content2 = response2.json()
#content.keys()
#content = content['data']
#type(content)
#content = json.dumps(content)
keys = content['data'][0].keys()
keys2 = content2['data'][0].keys()
#keys
print(content['data'])
print(content2['data'])
### Witing JSON data into CSV ##################
#csvwriter = csv.writer(first_csv)
with open('D:\sum\Its Study Time\Academic\M.S\Spring_2019\Machine Learning\Project\Sumedh_Work\\first_csv.csv', 'a', newline='') as first_csv:
    csvwriter = csv.DictWriter(first_csv, keys,extrasaction='ignore')
    #csvwriter.writeheader()
    csvwriter.writerows(content['data'])
    csvwriter.writerows(content2['data'])

############# Play using pandas ################
data = pd.read_csv('D:\sum\Its Study Time\Academic\M.S\Spring_2019\Machine Learning\Project\Sumedh_Work\\first_csv.csv')
#data.head
#data.drop()
print(data.shape)
The file Test.py contains:
a = ['0000016c052dcf4101000d746573745f6b65795f313233340012746573745f76616c75655f31323339393038','0000016c052dcf4101000d746573745f6b65795f313233340012746573745f76616c75655f31323339393038']


raw_data = bytes.fromhex(''.join(a))
print(raw_data)
print(len(raw_data))
The file threeCharDistincts.py contains:
def threeCharDistincts(s):
    count = 0
    for i in range(len(s) - 2):
        #print(s[i])
        char_set = set()
        flag = True
        for j in range(i, i + 3):
            if s[j] in char_set:
                flag = False
                break
            else:
                char_set.add(s[j])

        if flag:
            count += 1
    return count

print(threeCharDistincts("aaaaaaabc"))
print(threeCharDistincts("abcdaaae"))
The file Tom_Sawyer.py contains:
def countWays(arr, n):
    pos = [0 for i in range(n)]
    p = 0
    for i in range(n):
        if (arr[i] == 1):
            pos[p] = i + 1
            p += 1
    if (p == 0):
        return 0
    ways = 1
    for i in range(p - 1):
        ways *= pos[i + 1] - pos[i]
    return ways

print(countWays([0,1],2))
The file topological_sort.py contains:
def topological_sort(vertex,op,visited,d):
    print(vertex,'-----------',visited)
    if not visited[vertex]:
        visited[vertex] = True
        for i in d[vertex]:
            topological_sort(i,op,visited,d)
        op.append(vertex)
        print(vertex,visited)




if __name__ == '__main__':
    d = {
        0: [],
        1: [],
        2: [3],
        3: [1],
        4: [0, 1,5],
        5: [2, 0]
    }
    output_stack = []
    recStack = [False]*len(d)
    visited = [False]*len(d)

    for k,v in d.items():
        topological_sort(k,output_stack, visited, d)


    print(output_stack)











The file traversal.py contains:
class Node:
    def __init__(self,x):
        self.val = x
        self.left = None
        self.right = None

class traversals:
    def inorder_traversal(self,root):
        def helperinorder(root,res):
            if root:
                helperinorder(root.left,res)
                res.append(root.val)
                helperinorder(root.right,res)

        res=[]
        helperinorder(root,res)
        return res

    def preorder_traversal(self,root):
        def helperpreorder(root,res):
            if root:
                res.append(root.val)
                helperpreorder(root.left,res)
                helperpreorder(root.right,res)

        res=[]
        helperpreorder(root,res)
        return res

    def postorder_traversal(self,root):
        def helperpostorder(root,res):
            if root:
                helperpostorder(root.left,res)
                helperpostorder(root.right,res)
                res.append(root.val)

        res=[]
        helperpostorder(root,res)
        return res




if __name__ == '__main__':
    root = Node(1)
    root.left =Node(2)
    root.left.left = Node(4)
    root.left.right = Node(5)
    root.right = Node(3)

    #------------- Traversal -----------#
    treaverse = traversals()
    print("Pre order traversal: -",treaverse.preorder_traversal(root))
    print("In order traversal: -",treaverse.inorder_traversal(root))
    print("Post order traversal: -",treaverse.postorder_traversal(root))

The file tst_1.py contains:
import re

def patterMatch(str1):
    result = re.findall('(?<=1)[0]+(?=1)', str1)

    print(result)



    '''
    result = re.findall(r'(10+1)',str1)
    start = 0
    s = set()
    end = len(str1)
    print(result)
    while True:
        result.append(re.findall(r'10+1',str1[start:end]))
        start+=1
        if start==end:
            break
    print(result)

    for i in range(len(result)):
        if result[i] not in s:
            s.add(result[i])

    print(s)
    '''





if __name__ == '__main__':
    patterMatch("1010001001000abc0011101")

    101
    10001
    1001
    101
The file turbulance.py contains:
def findTurbulance(arr,idx,res):
    for j in range(idx,len(arr)-2):
        if arr[j]>arr[j+1] and arr[j+1]<arr[j+2]:
            res.append(j)
            res.append(j+1)
            res.append(j + 2)
            #res.append(arr[j])
            #res.append(arr[j+1])
            #res.append(arr[j+2])
            findTurbulance(arr,j+2,res)
        else:
            break


if __name__ == '__main__':
    #arr = [9,4,2,10,7,8,8,1,9]
    arr = [9, 4, 2, 10, 7, 8, 8, 1, 9]
    maxRange = [0,0]
    for i in range(len(arr)):
        res = []
        findTurbulance(arr,i,res)
        if res and maxRange[1]-maxRange[0]<(res[-1]-res[0]):
            maxRange = [res[0],res[-1]]
        print(res)
        print(maxRange)

    #s = "leet"
    #print(list(s))
    #s = list(s)
    #print(''.join(s))

The file twoSum.py contains:
a = [2,7,11,15]
target = 9
d ={}
for i in range(len(a)):
    if a[i] not in d:
        d[target - a[i]] = i
    else:
        print([d[a[i]],i])



The file two_sum.py contains:
def twoSum(nums,target):
    nums_position = {}
    count = 0
    count_1 = 0
    for i in nums:
        if target - i in nums_position:
            count_1 +=1
        nums_position[i] = count
        count = count + 1
    return count_1


print(twoSum([10,3,5,7,2,8,9,6,1,4],7))
The file uniqueStrings.py contains:
from collections import Counter

str1 = input("Please enter a sentence: ")
words = str1.split(',')
print(words)
s = set()
for i in range(len(words)):
    s.add(words[i].lower())
print(s)
print(len(s))
#c = Counter(words)
#unique = [w for w in words if c[w] == 1]

#print("Unique words: ", unique)


The file universityCareerFair.py contains:
def universityCareerFair(arrival, duration):
    aux = sorted(
        list(zip(arrival, duration)),
        key=lambda p: (sum(p), p[1])
    )
    ans, end = 0, -float('inf')
    for arr, dur in aux:
        if arr >= end:
            ans, end = ans + 1, arr + dur
    return ans


print(universityCareerFair([1,3,5],[2,2,2]))
print(universityCareerFair([1],[5]))
The file Valid_Paranthesis.py contains:
s = input()

'''while "()" in s or "{}" in s or '[]' in s:
    print("in while")
    s = s.replace("()", "").replace('{}', "").replace('[]', "")
if s == "":
    print("True")
else:
    print("False")
'''

for i in range(len(s)):
    #print("in while")
    s = s.replace("()", "").replace('{}', "").replace('[]', "")
if s == "":
    print("True")
else:
    print("False")

#print(isValid("{([()])}"))




The file Ways_to_sum.py contains:
'''
def binomialCoeff(n, k):
    C = [[0 for i in range(k + 1)] for i in range(n + 1)]

    # Caculate value of Binomial Coefficient in bottom up manner
    for i in range(1, n + 1, 1):
        for j in range(1, min(i, k) + 1, 1):
            # Base Cases
            if (j == 0 or j == i):
                C[i][j] = 1

            # Calculate value using previosly stored values
            else:
                C[i][j] = C[i - 1][j - 1] + C[i - 1][j]
    #print(C[n][k])
    return C[n][k]

def CountWays(n,k):
    table = [0] * (n + 1)
    table[0] = 1
    for i in range(0, k):

        for j in range(i, n+1):
            table[j] += table[j - i]

    return table[n]

# Driver Code
if __name__ == '__main__':
    n = 8
    k = 2
    print("Total number of different ways are", binomialCoeff(n - 1, k - 1))
    #print("Total number of different ways are", CountWays(8,2))


'''
def findCombinationsUtil(arr, index, num,reducedNum,main_temp):
    if (reducedNum < 0):
        return 0;
    if (reducedNum == 0):
        temp = []
        for i in range(index):
            temp.append(arr[i])
        main_temp.append(temp)
        return 0;
    prev = 1 if (index == 0) else arr[index - 1];
    for k in range(prev, num + 1):
        arr[index] = k;
        findCombinationsUtil(arr, index + 1, num,reducedNum - k,main_temp);
def findCombinations(n,a):
    arr = [0] * n
    main_temp = []
    findCombinationsUtil(arr, 0, n, n,main_temp)
    count = 0
    for array in main_temp:
        print("In for")
        if max(array) <= a:
            count += 1
    print(count)

n = 100
a=10
findCombinations(n,a)
The file weeklyStockPrice.py contains:
def getWeeklyPrice(nums):
    res = []
    l,sum = 0,0

    for r in range(len(nums)):
        if r-l ==7:
            res.append(round((sum/7.0*100)/100.0,2))
            l+=1
            sum -=nums[l]

        sum+=nums[r]

    res.append(round((sum/7.0*100)/100.0,2))
    print(res)
    return "".join([str(integer) for integer in res])



if __name__ == '__main__':
    print(getWeeklyPrice([7,8,8,11,9,7,5,6]))

The file wordLadder.py contains:
import collections
'''
        adj = collections.defaultdict(list)
        for word in wordList:
            for i in range(len(word)):
                adj[word[:i] + '_' + word[i+1:]].append(word)
        #print(adj)
        visited = set()
        q = collections.deque([(beginWord, 1)])
        while q:
            word, k = q.popleft()
            if word == endWord:
                return k
            if word not in visited:
                visited.add(word)
                for i in range(len(word)):
                    neighbors = word[:i] + '_' + word[i+1:]
                    for neighbor in adj[neighbors]:
                        q.append((neighbor, k+1))
            print(q)
        return 0 

def ladderLength(beginWord, endWord, wordList):
    d = collections.defaultdict(list)

    for word in wordList:
        for letter in range(len(word)):
            d[word[:letter]+'*'+word[letter+1:]].append(word)
    visisted = set()

    queue = collections.deque([(beginWord,1)])
    dummyqueue = []
    #print(queue.popleft())
    while queue:
        print("------------")
        word,level = queue.popleft()
        if word == endWord:
            return  level
        if word not in visisted:
            visisted.add(word)
            for i in range(len(word)):
                tempArr = word[:i]+'*'+word[i+1:]
                #print(tempArr)
                for element in d[tempArr]:
                    #print(queue,element,element in dummyqueue)
                    if element not  in visisted and element not in dummyqueue:
                        dummyqueue.append(element)
                        queue.append((element,level+1))

        print(queue)
    print(d)


print(ladderLength("hit","cog",["hot","dot","dog","lot","log","cog"]))

'''
import collections

def ladderLength(beginWord,endWord,wordList):
    d = collections.defaultdict(list)

    for i in range(len(wordList)):
        for j in range(len(wordList[i])):
            temp = wordList[i]
            d[temp[:j]+'*'+temp[j+1:]].append(temp)
    #print(d)

    visited =set()

    q =collections.deque()
    q.append((beginWord,1))

    while q:
        data, level = q.popleft()
        if data==endWord:
            return level
        #print(data, level)

        if data not in visited:
            visited.add(data)
            for i in range(len(data)):
                temp = data[:i]+'*'+data[i+1:]
                #print(temp,q)
                for element in d[temp]:
                    q.append((element,level+1))

    return 0

if __name__ == '__main__':
    beginWord = "hit"
    endWord = "cog"
    wordList = ["hot", "dot", "dog", "lot", "log", "cog"]
    #print(beginWord)
    print(ladderLength(beginWord,endWord,wordList))






















The file Work_Schedule.py contains:
def sumOfDigits(s):
    sum = 0
    for i in range(len(s)):
        sum += int(s[i])
    return sum;

def findSchedules(workHours, dayHours, pattern):
    x = ()
    if '?' in pattern:
        index = pattern.index('?')
        first = str(pattern[:index])
        last = str(pattern[index+1:len(pattern)])
        for i in range(dayHours+1):
            result = findSchedules(workHours, dayHours, first + str(i) + last)
            x = x + result;
            # print(result)
            # print(x)
    else:
        #Pattern has no Question mark,
        #So, just sum digits and check if it matches WorkHours
        #print(sumOfDigits(pattern),workHours)
        if(sumOfDigits(pattern) == workHours):
            x = x + (pattern,)
    return x
res = findSchedules(56,8,'???8???')
print(res)

The file nailsHammered.py contains:
def Solution(A, K):
    n = len(A)
    best = 0
    count = 1

    for i in range(n - K - 1):
        if (A[i] == A[i + 1]):
            count = count + 1
        else:
            count = 1 # Changes
        best = max(best, count)

    result = best + K # Changes
    return result


def Solution1(A,K):
    n = len(A)
    best = 0
    count = 1
    for i in range(n-K-1):
        if (A[i]==A[i+1]):
            count = count+1
        else:
            count = 0
        best = max(best,count)
    if count == 0 and best == 1:
        result = best + K
    else:
        result = best+1+K
    return result

#A= [1,1,3,3,3,4,5,5,5,5]
#A= [1,1,3,3,3,5,6,7]
#A=[1,2]
A =[]
#A = [1,2,3,4,5]
#A = [3,3,3,4]
#A = [1,2,3,4,4,5,5,7,7]
K = 0
print(Solution(A,K))
The file nary_bfs_traverse.py contains:
class NewNode:
    def __init__(self,root):
        self.val = root
        self.child= []

class bfs:
    res = 0
    def traverse(self,r):
        queue = []
        if r:
            queue.append(r)
        while len(queue)>0:
            data = queue.pop(0)
            self.res +=data.val
            for i in range(len(data.child)):
                    queue.append(data.child[i])

        return self.res



if __name__ == '__main__':
    root = NewNode(1)
    root.child.append(NewNode(2))
    root.child.append(NewNode(3))
    root.child.append(NewNode(4))
    root.child[0].child.append(NewNode(5))
    root.child[0].child[0].child.append(NewNode(10))
    root.child[0].child.append(NewNode(6))
    root.child[0].child[1].child.append(NewNode(11))
    root.child[0].child[1].child.append(NewNode(12))
    root.child[0].child[1].child.append(NewNode(13))
    root.child[2].child.append(NewNode(7))
    root.child[2].child.append(NewNode(8))
    root.child[2].child.append(NewNode(9))
    b = bfs()
    print(b.traverse(root))
The file nonpalindrom.py contains:
pali = 'ada'

new_string = ""

replaced = False
#if len(pali)==3 and if pali[0]=='a'
for i, c in enumerate(pali):
    if not replaced:
        if c > 'a' and (len(pali)//2 != i or len(pali)%2 == 0):
            new_string += 'a'
            replaced = True
        else:
            new_string += c
    else:
        new_string += c


if new_string == pali:
    print ("IMPOSSIBLE")
else:
    print ("new non palindrome lexicographically smaller string:", new_string)
The file numberOfTokens.py contains:
def numberOfTokens(expiryLimit, commands):
    # Write your code here
    values = dict()
    time = 0

    for c in commands:
        #  extraction values
        action = c[0]
        token_id = c[1]
        time = c[2]

        #  set token
        if action == 0:
            values[token_id] = expiryLimit + time

        #  reset token
        elif action == 1:
            # check if token exists
            if token_id in values.keys():
                expiry_time = values.get(token_id)
                if expiry_time >= time:
                    values[token_id] = values.get(token_id) + expiryLimit - (expiry_time - time)

    # counting values alive after reading all the values
    count = sum(1 for i in values.values() if i >= time)
    return count


print(numberOfTokens(4,[[0,1,1],[0,2,2],[1,1,5],[1,2,7]]))
print(numberOfTokens(3,[[0,1,1],[1,1,4],[1,2,5]]))
The file occurencesInSubarray.py contains:
#----- Occurrences in Subarrays ------

from collections import Counter
def occurrencesInSubarrays_1(arr, m):
    res = []
    i = 0
    while i <= len(arr) - m:
        if (i+m <= len(arr)):
            most_common, num_most_common = Counter(arr[i:i+m]).most_common(1)[0]
            res.append(num_most_common)
        i += 1
    return res

def occurrencesInSubarrays(arr,m):
    res = []
    i = 0
    while i <= len(a) - m:
        lst = a[i:i + m]
        res.append(max(set(a[i:i + m]), key=lst.count))
        i += 1
    return res


#a = [1,3,2,2,3]
#a = [1,2]
a = [2,1,2,3,3,2,2,2,2,1]
#m = 2
m = 3
res = []
print(len(a))
print(occurrencesInSubarrays(a,m))
print(occurrencesInSubarrays_1(a,m))


The file oneToHundredWithoutRecursion.py contains:
def printNumbers(num):
    res = []
    def helper(i):
        if i==num:
            res.append(i)
        else:
            res.append(i)
            helper(i+1)

    helper(1)
    return res

n = 100
print(printNumbers(n))




The file oppositeSum.py contains:
def reverse(Number):
    Reverse = 0
    while (Number > 0):
        Reminder = Number % 10
        Reverse = (Reverse * 10) + Reminder
        Number = Number // 10
    return (Reverse)


def oppositesum(arr):
    output = 0
    pairs = set()
    rev = {}
    #     arr = list(set(arr))
    for i in range(len(arr)):

         += 1
        if arr[i] not in rev.keys():
            rev[arr[i]] = reverse(arr[i])
        for j in range(i + 1, len(arr)):
            if arr[j] not in rev.keys():
                rev[arr[j]] = reverse(arr[j])
            if (arr[i], arr[j]) in pairs:
                output += 1
            elif (arr[i] + rev[arr[j]]) == (rev[arr[i]] + arr[j]):
                pairs.add((arr[i], arr[j]))
                output += 1
    return output

if __name__ == '__main__':
    print(oppositesum([1,20,2,11]))
The file optimalUtilization.py contains:
def find(F, B, T):
    ans = [0, 0, 0]
    F = sorted([x, i] for i, x in F)
    for idy, y in B:
        f = 0
        end = len(F)
        z = T - y
        while f != end:
            m = (int)((f + end) / 2)
            if F[m][0] <= z:
                f = m + 1
            else:
                end = m
        if f != 0 and y + F[f - 1][0] > ans[0]:
            ans = [y + F[f - 1][0], F[f - 1][1], idy]
    return ans[1:]


print(find([[1,8],[2,15],[3,9]],[[1,8],[2,11],[3,12]],20))
The file parking_dilemma.py contains:
def carParkingRoof(cars, k):
    result = float("inf")

    n = len(cars)
    # Sorting the array.
    cars.sort()

    # Find minimum value among
    # all K size subarray.
    for i in range(n - k + 1):
        result = int(min(result, cars[i + k - 1] - cars[i] + 1))
    return result



print(carParkingRoof([2,10,8,17],3))
print(carParkingRoof([1,2,3,10],4))
The file pathWithMaxMinValue.py contains:
import  math
import heapq
if __name__ == '__main__':
    #arr = [[5,4,5],[1,2,6],[7,4,6]]
    #arr = [[3,4,6,3,4],[0,2,1,1,7],[8,8,3,2,7],[3,2,4,9,8],[4,1,2,0,0],[4,6,5,4,3]]
    #arr = [[2, 2, 1, 2, 2, 2], [1, 2, 2, 2, 1, 2]]
    arr = [[2, 0, 5, 2, 0], [2, 4, 4, 4, 3], [1, 5, 0, 0, 0], [5, 4, 4, 3, 1], [1, 3, 1, 5, 3]]
    q = [(-arr[0][0],0,0)]
    total = math.inf
    visited = set()
    while q:
        val, i ,j = heapq.heappop(q)
        visited.add((i,j))
        if -val<total:
            total = -val
        x = [1, -1, 0, 0]
        y = [0, 0, 1, -1]
        if i ==len(arr)-1 and j == len(arr[0])-1:
            break
        for ele in range(4):
            if 0 <= i + x[ele] < len(arr) and 0 <= j + y[ele] < len(arr[0]) and (i + x[ele], j + y[ele]) not in visited:
                heapq.heappush(q,(-arr[i + x[ele]][j + y[ele]],i + x[ele],j + y[ele]))


    print(total)
    print(visited)









    '''
    arr = [[2, 0, 5, 2, 0], [2, 4, 4, 4, 3], [1, 5, 0, 0, 0], [5, 4, 4, 3, 1], [1, 3, 1, 5, 3]]
    total = []
    path = [[0,0]]
    q = [[0,0]]
    while q:
        data = q.pop(0)
        #print(data)
        i = data[0]
        j = data[1]
        if i==len(arr)-1 and j== len(arr[0])-1:
            break
        if [i,j] in path:
            print("----",i,j,"-----")
            maxNum = -math.inf
            maxNumCord = (0, 0)
            num = arr[i][j]
            x = [1,-1,0,0]
            y = [0,0,1,-1]
            for ele in range(4):
                if 0<=i+x[ele]<len(arr) and 0<=j+y[ele]<len(arr[0]) and [i+x[ele],j+y[ele]] not in path:
                    print(i + x[ele],j+y[ele])
                    if [i + x[ele],j+y[ele]] ==[len(arr)-1,len(arr[0])-1]:
                        maxNum = arr[i + x[ele]][j + y[ele]]
                        maxNumCord = [i + x[ele], j + y[ele]]
                        break
                    if arr[i+x[ele]][j+y[ele]] > maxNum:
                        maxNum = arr[i + x[ele]][j+y[ele]]
                        maxNumCord = [i + x[ele], j+y[ele]]
        print(maxNumCord,maxNum)
        if maxNumCord not in path:
            path.append(maxNumCord)
            q.append(maxNumCord)
            total.append(maxNum)

    print(path)
    print(min(total))
    print(len(path)-1)

    if i+1<len(arr) and arr[i+1][j]>maxNum and [i+1,j] not in path:
        maxNum = arr[i+1][j]
        maxNumCord = [i+1,j]
    if i-1>=0 and arr[i-1][j] > maxNum  and [i-1,j] not in path:
        maxNum = arr[i - 1][j]
        maxNumCord = [i-1,j]
    if j+1<len(arr[0]) and arr[i][j+1]>maxNum and [i,j+1] not in path:
        print(arr[i][j+1])
        maxNum = arr[i][j+1]
        maxNumCord = [i,j+1]
    if j-1>=0 and arr[i][j-1]>maxNum  and [i,j-1] not in path:
        maxNum = arr[i][j-1]
        maxNumCord = [i,j-1]

'''
The file Piyusha_7_11.py contains:
# fruits = ['mango','guava','pinapple','pomegranate']
#
# fruity = []
# for f in fruits:
#     fruity.append(f.capitalize())
#     fruity.sort()
#     #sorted(fruity)
#     #print(' '.join(fruity))
#
#
# l1 = ['Tom','Mott',1985,1986]
# l2 = [6,7,8,3,5]
# #print('l2[0]:',l1[1])
#
# #a = [1,2,1,3,-1,1,2,2]
# #a = [-2,-5,4,4,4,3,3,3]
#
#
# from sys import stdin
#
# def myFunc(a):
#     d = {}
#     for i in range(len(a)):
#         if a[i] in d:
#             d[a[i]] = d[a[i]] + 1
#         else:
#             d[a[i]] = 1
#     max_num = max(d.values())
#     temp = 100000
#     print(d)
#     for k, v in d.items():
#         if d[k] == max_num and k < temp:
#             temp = k
#     print("Max Value is: -",temp)
#
# array = []
# for line in stdin:
#     n = int(line)
#     array.append(n)
#
# myFunc(array)
#
# #############################################################
# ######################### Round 2 ###########################
# #############################################################
#
#
# class classA:
#   def __init__(self,x,y):
#     self.a = x+y
#
# x = classA(1,2)
# y =getattr(x,'a')
# setattr(x,'a',y+1)
# print(x.a)
class Bucket:
    def __init__(self):
        self.bucket = []

    def get(self, key):
        for (k, v) in self.bucket:
            if k == key:
                return v
        return -1

    def update(self, key, value):
        found = False
        for i, kv in enumerate(self.bucket):
            if key == kv[0]:
                self.bucket[i] = (key, value)
                found = True
                break

        if not found:
            self.bucket.append((key, value))

        print(self.bucket)

    def remove(self, key):
        for i, kv in enumerate(self.bucket):
            if key == kv[0]:
                del self.bucket[i]


class MyHashMap(object):

    def __init__(self):
        self.key_space = 2069
        self.hash_table = [Bucket() for i in range(self.key_space)]


    def put(self, key, value):
        hash_key = key % self.key_space
        self.hash_table[hash_key].update(key, value)


    def get(self, key):
        hash_key = key % self.key_space
        return self.hash_table[hash_key].get(key)


    def remove(self, key):
        hash_key = key % self.key_space
        self.hash_table[hash_key].remove(key)


hashMap = MyHashMap()
hashMap.put(1, 1)
hashMap.put(2, 2)
print("hashMap.get(1)",hashMap.get(1))
print("hashMap.get(3)",hashMap.get(3))
hashMap.put(2070, 3)
hashMap.put(4139, 9)
print("hashMap.get(2070)",hashMap.get(2070))

The file Piyusha_7_11_part_2.py contains:
def countBits(a, b):
    count = 0
    while (a or b):
        last_bit_a = a & 1
        last_bit_b = b & 1
        if (last_bit_a != last_bit_b):
            count += 1
        a = a >> 1
        b = b >> 1
    return count
a = 6
b = 9
print(countBits(a, b))

################################

def countSetBits( n ):
	count = 0
	while n:
		count += n & 1
		n >>= 1
	return count

def FlippedCount(a , b):
	return countSetBits(a^b)

a1 = 6
b1 = 9
print(FlippedCount(a1, b1))


def ChangeBits(x,y):
    result = -404
    count = 0
    while(x or y):
        last_bit_x = x&1
        last_bit_y = y&1
        if last_bit_x != last_bit_y:
            count+=1
        x =x>>1
        y = y>>1
    result = count
    print(result)

ChangeBits(a,b)

The file Piyusha_Fractal.py contains:
def minimum_jumps(k,j):
    min_jumps = k/j
    min_jumps+=k%j
    #print(int(min_jumps))
    return int(min_jumps)

def missingWords(s,t):
    s = s.split()
    t = t.split()
    length = len(s)
    for i in reversed(s):
        if i in t:
            print(i)
            temp=i
            s.remove(temp)
            t.remove(temp)
            #i-=1
    print(s)

if __name__ == '__main__':
    print(minimum_jumps(3,1))
    print(minimum_jumps(8,3))
    print(minimum_jumps(3,3))

    #missingWords("Sumedh Joglekar","Sumedh")
    #missingWords("I am am using HackerRank to improve programming", "am HackerRank to improve")
    missingWords("Python is an easy to learn powerful programming language It has efficient high-level data structures and a simple but effective approach to objectoriented programming python elegant syntax and dynamic typing","Python is an easy to learn powerful programming language")

The file Pizza_Treats.py contains:


def pizzaTreats1(ar):
    coupon2 = False
    for i in range(len(ar)):
        if (ar[i] > 0):
            if coupon2 == False:
                coupon2 = False if (ar[i] % 2) == 0 else True
            else:
                coupon2 = True if (ar[i] % 2) == 0 else False
        elif (coupon2 == True and ar[i] == 0):
            coupon2 = False
            print("NO")
            return

    if (len(ar) > 0 and coupon2 == False):
        print("YES")
    else:
        print("NO")


pizzaTreats1([1,0,1])
pizzaTreats1([2,3,3,0])
pizzaTreats1([2,3,1])
pizzaTreats1([1,2,1,2])
The file Post.py contains:
#temp = [10,20,10,15,5,30,20]
#temp = [18,5,15,18,11,15,9,7]
temp = [6,18,8,14,10,12,18,9]
#size = 5
size = 8
#k = 1
k = 3
res = 0
while size>0:
    arr = temp[:k]+temp[-k:]
    #print(arr)
    m = max(arr)
    if m in temp[:k]:
        temp.remove(m)
    else:
        temp.reverse()
        temp.remove(m)
        temp.reverse()
    res+=m
    print(res)
    size-=1
The file pratikAmazon.py contains:
given = "pasword"
s = ["pwd","aso","swd","ord"]
d = {}
for k in range(len(s)):
    word = s[k]
    for i in range(len(word)):
        if word[i] not in d:
            d[word[i]]  = []
        for j in range(i+1,len(word)):
            d[word[i]].append(word[j])

d2 =  {}
for k in range(len(s)):
    word = s[k]
    for i in range(len(word)-1,-1,-1):
        if word[i] not in d2:
            d2[word[i]]  = []
        for j in range(i-1,-1,-1):
            d2[word[i]].append(word[j])



print(d)
print(d2)




The file Pratik_DataEngineering.py contains:
ans = -4//1.5
print(ans)


a =  {'a':1,'b':2,'a':3}

print(a)

def foo(a,b,c):pass

foo = [1,2,3,4,5]

#print(foo[-len(foo)])
#print(foo[len(foo)])

print("John")
print("Charles")
print("Chris")
print("---------")
print("John\nCharles\nChris")
The file Pratik_Trend_Micro.py contains:
def MaxTime(A, B, C, D)
    ArrayElements = [A, B, C, D]


    if ArrayElements == ArrayElements - [0, 1, 2]:
        return "NOT POSSIBLE"

    TimeReturn = " : "

    if ArrayElements.include?(2):
        TimeReturn[0] = ArrayElements.delete_at(ArrayElements.find_indexOf(2)).to_s1
    elif ArrayElements.include?(1):
    TimeReturn[0] = ArrayElements.delete_at(ArrayElements.find_indexOf(1)).to_s1
    else
    TimeReturn[0] = 0.to_s1
    if ArrayElements.find_indexOf(0)
        ArrayElements.delete_at(ArrayElements.find_indexOf(0))
    end
    end

    if ArrayElements.length == 4
        return "NOT POSSIBLE"
    end

    if TimeReturn[0] == "2"
        MaxThree = (ArrayElements - [4, 5, 6, 7, 8, 9]).maxOf
    if !MaxThree
    return "NOT POSSIBLE"
    else
    TimeReturn[1] = ArrayElements.delete_at(ArrayElements.find_indexOf(MaxThree)).to_s1
    end
    end

    if TimeReturn[0] == "1" | | TimeReturn[0] == "0"
        maxOf = ArrayElements.maxOf
    TimeReturn[1] = ArrayElements.delete_at(ArrayElements.find_indexOf(maxOf)).to_s1
    end

    if ArrayElements.length == 3
        return "NOT POSSIBLE"
    end

    minute_one_permone = ArrayElements.first
    minute_two_permone = ArrayElements.last
    MnutesPerOne = ArrayElements.join("")
    minutes_permtwo = ArrayElements.reverse.join("")

    if MnutesPerOne > "59" & & minutes_permtwo > "59"
        return "NOT POSSIBLE"
    end

    if MnutesPerOne > "59" & & minutes_permtwo <= "59"
        TimeReturn[3] = minutes_permtwo[0]
    TimeReturn[4] = minutes_permtwo[1]
    elsif
    minutes_permtwo > "59" & & MnutesPerOne <= "59"
    TimeReturn[3] = MnutesPerOne[0]
    TimeReturn[4] = MnutesPerOne[1]
    else
    if MnutesPerOne > minutes_permtwo
        TimeReturn[3] = MnutesPerOne[0]
    TimeReturn[4] = MnutesPerOne[1]
    else
    TimeReturn[3] = minutes_permtwo[0]
    TimeReturn[4] = minutes_permtwo[1]
    end
    end

    if TimeReturn.split(":").join("") > "2359"
        return "NOT POSSIBLE"
    else
        return TimeReturn
    end
    end
The file primeornot.py contains:
def prime(x):
    if x<=2:
        return False
    for i in range(2,x):
        if x%i==0:
            return False

    return True



if __name__ == '__main__':
    print(prime(10))
    print(prime(2))
    print(prime(5))
    print(prime(3))
The file Prime_String.py contains:

def check_prime(a):
    for i in range(2, a):
        if a % i == 0:
            return False
    return True

def find_next_prime(n):
    low = n - 1
    high = n + 1
    while True:
        if check_prime(low):
            return low
        elif check_prime(high):
            return high
        else:
            low -= 1
            high += 1

s = "CABa"
strs = ""
for i in range(len(s)):
    if not check_prime(ord(s[i])):
        a = find_next_prime(ord(s[i]))
        strs = strs + chr(a)
    else:
        strs = strs + s[i]
print(strs)
The file printAncestors.py contains:
class Node:
    def __init__(self,root):
        self.val = root
        self.left =None
        self.right = None

from collections import defaultdict
def printAncestors(node,val):
    q = []
    parent  = defaultdict()
    if node:
        q.append(node)
        parent[node.val] = None
        while q:
            data = q.pop(0)
            if data.left:
                parent[data.left.val] = data.val
                q.append(data.left)
            if data.right:
                parent[data.right.val] = data.val
                q.append(data.right)
        print(parent)
    res = []
    while parent[val]:
        res.append(parent[val])
        val = parent[val]

    print(res)





if __name__ == '__main__':
    # Driver program to test above function
    root = Node(1)
    root.left = Node(2)
    root.right = Node(3)
    root.left.left = Node(4)
    root.left.right = Node(5)
    root.left.left.left = Node(7)

    printAncestors(root, 7)
The file product_minus_sum.py contains:
def getProduct(n):
    product = 1
    while (n != 0):
        product = product * (n % 10)
        n = n // 10
    print(product)
    return product

def sumList(n):
    sum = 0
    while (n != 0):
        sum = sum + (n % 10)
        n = n // 10
    print(sum)
    return sum

# = 123456
n = 1010
print(getProduct(n)-sumList(n))
The file pythonAsOOPS.py contains:
class A:
    def __init__(self):
        print("Initializing A")

    def method1(self,a,b):
        print(a,b)

class B(A):
    def __init__(self):
        print("Initializing B")

    def method1(self,a,b):
        print(a-b)


class C(B):
    def __init__(self):
        print("Initializing B")

    def method1(self,a,b,c):
        print(a,b,c)

class D:
    def __init__(self):
        print("Initializing C")

    def method1(self,a):
        print(a)

############### Multiple Inheritance ##############

class E(B,D):

    def __init__(self):
        print("Initializing E")

    def method1(self,a,b,c):
        print(a,b,c)

if __name__ == '__main__':
    a = A()
    b = B()
    c = C()
    e = E()
    a.method1(2,3)
    b.method1(2,3)
    c.method1(2,1,4)
    e.method1(1,2,3)


The file readingVertically.py contains:
from collections import defaultdict
arr= ["Daisy","Rose","Hyacinth","Poppy"]
d= defaultdict(list)
res =""
for i in range(len(arr)):
    for j in range(len(arr[i])):
        d[j].append(arr[i][j])
for k,v in d.items():
    for elements in range(len(v)):
        res+=v[elements]
print(res)

The file read_json.json contains:
{
  "destination_addresses": [
    "Washington, DC, USA",
    "Philadelphia, PA, USA",
    "Santa Barbara, CA, USA",
    "Miami, FL, USA",
    "Austin, TX, USA",
    "Napa County, CA, USA"
  ],
  "origin_addresses": [
    "New York, NY, USA"
  ],
  "rows": [{
    "elements": [{
        "distance": {
          "text": "227 mi",
          "value": 365468
        },
        "duration": {
          "text": "3 hours 54 mins",
          "value": 14064
        },
        "status": "OK"
      },
      {
        "distance": {
          "text": "94.6 mi",
          "value": 152193
        },
        "duration": {
          "text": "1 hour 44 mins",
          "value": 6227
        },
        "status": "OK"
      },
      {
        "distance": {
          "text": "2,878 mi",
          "value": 4632197
        },
        "duration": {
          "text": "1 day 18 hours",
          "value": 151772
        },
        "status": "OK"
      },
      {
        "distance": {
          "text": "1,286 mi",
          "value": 2069031
        },
        "duration": {
          "text": "18 hours 43 mins",
          "value": 67405
        },
        "status": "OK"
      },
      {
        "distance": {
          "text": "1,742 mi",
          "value": 2802972
        },
        "duration": {
          "text": "1 day 2 hours",
          "value": 93070
        },
        "status": "OK"
      },
      {
        "distance": {
          "text": "2,871 mi",
          "value": 4620514
        },
        "duration": {
          "text": "1 day 18 hours",
          "value": 152913
        },
        "status": "OK"
      }
    ]
  }],
  "status": "OK"
}
The file recursivelySquare.py contains:
def square(x,a):
    if a == 0:
        return 1
    if a ==1:
        return x

    return x*square(x,a-1)


if __name__ == '__main__':
    print(square(2,0))
The file removeOnedigit.py contains:
s = "ab12c"
#t = "1zz456"
t  = "ab24z"
def removeOneDigit(s,t):
    sList = list(s)
    tList = list(t)
    count = 0
    for i in range(len(tList)):
        tl = tList.copy()
        if tList[i].isdigit():
            tl.pop(i)
            if s < ''.join(tl):
                count+=1
    for i in range(len(sList)):
        sl = sList.copy()
        if sList[i].isdigit():
            sl.pop(i)
            if ''.join(sl) < t:
                count+=1
    return count


print(removeOneDigit(s,t))
The file restockingtheWarehouse.py contains:
def restock(itemCount,target):
    keepingAdding=0

    for i in range(len(itemCount)):
        keepingAdding+=itemCount[i]
        if keepingAdding>=target:
            break

    if keepingAdding>=target:
        return keepingAdding-target
    else:
        return target-keepingAdding


if __name__ == '__main__':
    print(restock([10,20,30,40,15],80))
    print(restock([6,1,2,1], 100))
    print(restock([1,2,3,2,1], 4))
The file reverseALinkedList.py contains:
class ListNode:
    def __init__(self,x):
        self.val = x
        self.next  =None

class LinkedList:

    def __init__(self):
        self.head =  None


    def addFirst(self,x):
        new_node = ListNode(x)
        new_node.next  = self.head

        self.head = new_node

    def printAll(self):
        last = self.head
        while last:
            print(last.val)
            last = last.next

    def push(self,x):
        new_node = ListNode(x)
        new_node.next= None
        last = self.head
        while last.next:
            last = last.next
        last.next = new_node

    def reverseLL(self):
        prev = None
        curr = self.head
        while curr:
            nxt = curr.next
            curr.next = prev
            prev = curr
            curr = nxt

        self.head = prev


        '''
        prev = None
        current = self.head
        while current is not None:
            nxt = current.next
            current.next = prev
            prev = current
            current = nxt
        self.head = prev
        '''



if __name__ == '__main__':
    l = LinkedList()

    l.addFirst(1)
    l.addFirst(2)
    l.addFirst(3)
    l.addFirst(4)
    l.push(5)
    l.printAll()
    print("---------------------")
    l.reverseLL()
    l.printAll()

The file ReverselevelordertraversalN-ary tree.py contains:
'''
Level Order traversal of  N ary tree and reverse the level
'''
import  collections
class NewNode:
    def __init__(self,root):
        self.val = root
        self.child = []


def travverse(node):
    q = collections.deque()
    q.append(node)
    s = []
    while q:
        n = q.popleft()
        for i in range(len(n.child)):
            q.append(n.child[i])

        s.insert(0,n.val)

    print(s)



if __name__ == '__main__':
    root = NewNode('A')
    root.child.append(NewNode('B'))
    root.child.append(NewNode('C'))
    #root.child.append(NewNode(4))
    root.child[0].child.append(NewNode('D'))
    root.child[0].child[0].child.append(NewNode('H'))
    root.child[0].child.append(NewNode('E'))
    root.child[1].child.append(NewNode('F'))
    root.child[1].child.append(NewNode('G'))
    root.child[0].child[0].child[0].child.append(NewNode('I'))
    #root.child[0].child[1].child.append(NewNode(11))
    #root.child[0].child[1].child.append(NewNode(12))
    #root.child[0].child[1].child.append(NewNode(13))
    #root.child[2].child.append(NewNode(7))
    #root.child[2].child.append(NewNode(8))
    #root.child[2].child.append(NewNode(9))

    travverse(root)



The file reverseString.py contains:
def reverseString1(x):
    res=""
    for i in x:
        res = i+res

    print(res)

def reverseString2(x):
    res =[]
    finalOP=[]
    for i in x:
        res.append(i)
    while res:
        finalOP.append(res.pop())

    print(''.join(finalOP))


def reverseString3(x):
    print(x[::-1])


if __name__ == '__main__':
    s = "EAITechnology"
    reverseString1(s)
    reverseString2(s)
    reverseString3(s)
    #reverseString1("")
The file romanToInt.py contains:
def romanToInt(s):
    num = 0
    my_funcs = {
        'I': (lambda num: -1 if num >= 5 else 1),
        'V': (lambda num: 5),
        'X': (lambda num: -10 if num >= 50 else 10),
        'L': (lambda num: 50),
        'C': (lambda num: -100 if num >= 500 else 100),
        'D': (lambda num: 500),
        'M': (lambda num: 1000)
    }
    for el in reversed(list(s)):
        # print(el)
        num += my_funcs[el](num)

    return num


#s = ['Louis VIII','Louis VII']
s = ['Philippe I','Philip II']
for i in range(len(s)):
    a =(s[i].split(' '))
    a[1]=str(romanToInt(a[1]))
    a = ''.join(a)
    s[i]=a


#print(s)

print(sorted(s))
The file runLengthEncoding.py contains:
if __name__ == '__main__':
    x = "wwwwaaadexxxxxx"
    op = "w4a3d1e1x6"
    d = {}
    res = ""
    for i in range(len(x)):
        if x[i] in d.keys():
            d[x[i]]+=1
        else:
            d[x[i]] = 1
    print(d)

    for k,v in d.items():
        res+=k+str(v)

    print(res)



The file SAP_SVNT_minDaysToConnectAllCities.py contains:
from collections import deque
import math

def bfs(grid, start,goal):
    queue = deque([[start]])
    seen = set([start])
    while queue:
        path = queue.popleft()
        x, y= path[-1]
        if (x,y) == goal:
            return path
        for x2, y2 in ((x+1,y), (x-1,y), (x,y+1), (x,y-1)):
            if 0 <= x2 < len(grid[0]) and 0 <= y2 < len(grid) and grid[x2][y2] != '#' and (x2, y2) not in seen:
                queue.append(path + [(x2, y2)])
                seen.add((x2, y2))

def minDays(grid,visited,output):
    src=deque()
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == '$':
                pos = [i, j, 0]
                src.appendleft(pos)
    #print(src)
    while len(src)>0:
        curr = src.pop()
        x,y,dist= curr[0],curr[1],curr[2]
        if x+1<len(grid)and visited[x+1][y] == False  and grid[x+1][y]!='#':
            output[x+1][y] = min(output[x+1][y],dist+1)
            src.appendleft((x+1,y,dist+1))
            visited[x+1][y] = True

        if x-1>=0 and visited[x-1][y] == False and grid[x-1][y]!='#':
            output[x - 1][y] = min(output[x-1][y], dist+ 1)
            src.appendleft((x-1,y,dist+1))
            visited[x-1][y] = True

        if y+1<len(grid[0]) and visited[x][y+1] == False and grid[x][y+1]!='#':
            output[x][y+1] = min(output[x][y+1],dist + 1)
            src.appendleft((x,y+1,dist+1))
            visited[x][y+1] = True

        if y-1>=0 and visited[x][y-1] == False  and grid[x][y-1]!='#':
            output[x][y-1] = min(output[x][y-1],dist + 1)
            src.appendleft((x,y-1,dist+1))
            visited[x][y-1] = True


if __name__ == '__main__':
    #g = [['$', '.', '.', '#'],['.', '.', '#', '.'],['#', '.', '$', '.'],['$', '.', '.', '.']]
    g = [['$', '.', '.', '#'],['.', '.', '#', '.'],['#', '.', '$', '.'],['.', '.', '.', '.']]
    #g = [['$','#'],['$','.']]
    visited = [[False for i in range(len(g))] for i in range(len(g[0]))]
    output = [[-1 for i in range(len(g))] for i in range(len(g[0]))]
    src= []
    p = {}
    for i in range(len(g)):
        for j in range(len(g[0])):
            if g[i][j] == '$':
                src.append([(i,j),math.inf])
    for i in range(len(src)):
        for j in range(i+1,len(src)):
            temp = bfs(g,src[i][0],src[j][0])
            if len(temp)<src[i][1]:
                src[i][1] = len(temp)
                p[src[i][0]] = temp
                p[src[j][0]] = temp
    for k,v in p.items():
        for j in range(len(v)):
            output[v[j][0]][v[j][1]] = max(output[v[j][0]][v[j][1]],j)
            visited[v[j][0]][v[j][1]] = True
    print(output)
    for i in range(len(output)):
        for j in range(len(output[0])):
            if output[i][j] == -1:
                output[i][j] = math.inf

    print(visited)
    minDays(g, visited,output)
    total = 0
    for i in range(len(output)):
        for j in range(len(output)):
            if output[i][j] !=math.inf:
                total+=output[i][j]

    print(total)









The file sdeamazon.py contains:
def leftrotate(string,amount):
    s = list(string)
    amount = amount%len(s)
    s = s[amount:]+s[:amount]
    return  s

def rightrotate(string,amount):
    amount = amount%len(string)
    return  leftrotate(string,len(string)-amount)

def rotatestring(originalstring,direction,amount):
    s = originalstring
    for i in range(len(direction)):
        if direction[i] ==0:
            s = leftrotate(s,amount[i])
        else:
            s = rightrotate(s,amount[i])

    return ''.join(s)


#if __name__ == '__main__':



'''
s = "rthura"

print("-------",s.copy())   
s = list(s)
print(len(s))
a = s[5:] + s[:5]
print(a)

#print("",s.copy())



s = "rthura"
s = list(s)
a = s[5:] + s[:5]
print(a)
'''
The file segmentCovering.py contains:
def segmentCovering(listOfTuples):
    sortedBeg = sorted(listOfTuples, key=lambda x: x[0])
    sortedEnd = sorted(listOfTuples, key=lambda x: x[1])
    print("Sorting on the basis of 1st value: - ",sortedBeg,"\nSorting on the basis of 2nd value: - ",sortedEnd)
    thrhold = sortedBeg[0][0] - 1
    print("Initial threshold: -",thrhold)
    listOfPoints = []
    for i in range(len(sortedEnd) - 1):
        beg, end = sortedEnd[i]
        if beg > thrhold:
            listOfPoints.append(end)
            thrhold = end
            print("Updating Threshold:- ",thrhold)
        if listOfPoints[len(listOfPoints) - 1] < sortedEnd[len(sortedEnd) - 1][0]:
            if sortedEnd:
                print(sortedEnd[len(sortedEnd) - 1][0])
                listOfPoints.append(sortedEnd[len(sortedEnd) - 1][0])
        print((listOfPoints))
    return len(listOfPoints)


def segmentCovering_1(listOfTuples):

    sortedBeg = sorted(listOfTuples, key=lambda x: x[0])
    sortedEnd = sorted(listOfTuples, key=lambda x: x[1])
    print(sortedEnd[len(sortedEnd) - 1])

    thrhold = sortedBeg[0][0] - 1
    listOfPoints = []
    for i in range(len(sortedEnd) - 1):
        beg, end = sortedEnd[i]
        if beg > thrhold:
            listOfPoints.append(end)
            thrhold = end
    print(listOfPoints)

    if(len(listOfPoints)) == 0:return 0

    if listOfPoints[len(listOfPoints) - 1] < sortedEnd[len(sortedEnd) - 1][0]:
        if sortedEnd:
            listOfPoints.append(sortedEnd[len(sortedEnd) - 1][0])
    #print(len(listOfPoints))
    result = []
    for p in listOfPoints:
        result.append(p)

    return len(result)
#segment = [[-1,3],[-5,-3],[3,5],[2,4],[-3,-2],[-1,4],[5,5]]
#segment = [[-2,1], [-1,0], [0,1], [1,2]]
segment = [[-1000000000, 1000000000]]
print(segmentCovering_1(segment))
The file send_mail_from_local.py contains:
import smtplib, ssl
'''
port = 587  # For starttls
smtp_server = "smtp.gmail.com"
sender_email = "joglekarsumedh@gmail.com"
receiver_email = "sjogleka@uncc.edu"
password = input("Type your password and press enter:")
message = """\
Subject: Hi there

This message is sent from Python."""

context = ssl.create_default_context()
with smtplib.SMTP(smtp_server, port) as server:
    server.ehlo()  # Can be omitted
    server.starttls(context=context)
    server.ehlo()  # Can be omitted
    server.login(sender_email, password)
    server.sendmail(sender_email, receiver_email, message)
'''
fromaddr = 'joglekarsumedh@gmail.com'
toaddrs  = ['joglekarsumedh@gmail.com']
msg = '''
    From: {fromaddr}
    To: {toaddr}
    Subject: testin'     
    This is a test 
    .
'''
server.starttls()
print("Connection Opened")
server.ehlo("joglekarsumedh@gmail.com")
server.mail(fromaddr)
server.rcpt(toaddrs[0])
server.data(msg)
server.quit()
The file ShallowVsDeep_Copy.py contains:
import copy

if __name__ == '__main__':
    array1 = [1,2,2,5,6,7]
    ########################################### Assignment ###################################################
    print("###################### Assignment ##################")
    array2 = array1
    print("Before Change Array 1:-", array1)
    print("Before Change Array 2:-", array2)
    array2[1]=4
    print("Array 1 after change in array2:-",array1)
    print("Array 2 after change in array2:-", array2)
    array1[2]=3
    print("After change in array 1 Array 1:-", array1)
    print("After Change in array 1 Array 2:-", array2)
    ############################################## Deep Copy ##################################################
    print("###################### Deep copy ##################")
    array3 = copy.deepcopy(array1)
    array3[2]=10
    print("After Deep Copy",array1)
    print("After Deep Copy", array3)
    ################################################# Shallow Copy ##########################################
    print("###################### Shallow copy ##################")
    array4 = copy.copy(array1) ## Shallow copy using copy.
    print("Address of array 1:-",id(array1),"Address of array 4:-",id(array4)) ## Print address of array 1 and array4
    print("Before Change Array 1:-", array1)
    print("Before Change Array 2:-", array4)
    array1[0] = 500
    print("After Shallow Copy", array1)
    print("After Shallow Copy", array4)
    print("--------------------------------------")
    #################################### Special Case List of list ###############################
    ##### This is the actual difference between shallow copy and deep copy ########
    array5 = [[1,2,3],[4,5]]
    array6 = copy.copy(array5)
    print("Before Shallow Copy", array5)
    print("Before Shallow Copy", array6)
    array6[0][1] = 4
    print("After Shallow Copy Change", array5)
    print("After Shallow Copy Change", array6)
    print("ID of a[0]a[1]",id(array5[0]),id(array5[1]),"\nID of b[0]b[1]",id(array6[0]),id(array6[1]))
    print("Id A",id(array5),"Id of B",id(array6))
    print("--------------------------------------")
    array7 = copy.copy(array1)
    print("ID A :- ",id(array1),"ID B :- ",id(array7))

    #### Ref :- https://medium.com/@thawsitt/assignment-vs-shallow-copy-vs-deep-copy-in-python-f70c2f0ebd86 ####

The file snake_string.py contains:
### Print String sinusoidally ######
'''

e.g
 S = Hello_World


    E               _               L           ------------- 1st row
H       L       O       W       R       D       ------------- 2nd row
            L               O                   ------------- 3rd row

op = E_LHLOWRDLO

By Observation:-
1st row index = S[1],S[5] -- diff = 4
2nd row index = S[0], S[2], S[4],S[6] -- diff = 2
3rd row index = S[3],S[7] -- diff = 4
'''

def snake_string(s):
    op =[]
    if len(s)<=1:
        return s

    for i in range(1,len(s),4):
        op.append(s[i])

    for i in range(0,len(s),2):
        op.append(s[i])

    for i in range(3,len(s),4):
        op.append(s[i])

    return "".join(op)

def snake_string_1(s):

    return s[1::4]+s[::2]+s[3::4]
if __name__ == '__main__':
    print(snake_string("Hello_World"))
    print(snake_string_1("Hello_World"))
The file social_network_friends.py contains:
d = {}
#counts = [3,3,1,1,3,3,3,2,2,3,4,4,5,1,2,4,1,2,4,1,2,3]
counts = [5,5,5,3,3,1,1,2,2,1,2,1,2,3,5,5]
#counts = [1,1,1,1]
s = enumerate(counts)
import operator as op
s = sorted(s, key=op.itemgetter(1), reverse= True)
i = 0
while i < len(s):
    j = 0
    #print(s[i][1])
    while i < len(s) and j < s[i][1]:
        print(s[i][0],end=" ")
        #print(s[i][0])
        i+=1
        j+=1
    print()
The file sortMatrixByOccurences.py contains:
from collections import defaultdict
a = [[1,4,-2],[-2,3,4],[3,1,3]]


count = {}
for i in range(len(a)):
    for j in range(len(a)):
        if a[i][j] not in count:
            count[a[i][j]] = 0
        count[a[i][j]] += 1
m = []
x = defaultdict(list)
for k, v in count.items():
    x[v].append(k)

for keys in sorted(x.keys()):
    inp = sorted(x[keys])
    for digits in inp:
        m.extend(digits for x in range(keys))
print(m)
t = 0
for k in range(len(a), 0, -1):
    j = k
    i = len(a) - 1
    while (j <= len(a) - 1):
        a[i][j] = m[t]
        t += 1
        i = i - 1
        j = j + 1
for k in range(len(a) - 1, -1, -1):
    i = k
    j = 0
    while (i >= 0):
        a[i][j] = m[t]
        t += 1
        i = i - 1
        j = j + 1

print(a)
The file sort_by_frequecy_and _then_by_values.py contains:
'''from collections import Counter
def perseus_sort(l):
    counter = Counter(l)
    return sorted(l, key=lambda x: (counter[x], x))


li = [3,1,2,2,4]
print(perseus_sort(li))

'''
import heapq


def popularNToys(numToys, topToys, toys, numQuotes, quotes):
    toys_dict = {}
    for toy in toys:
        toys_dict[toy] = 0

    def toLower(quote):
        for c in quote:
            if not c.isalpha():
                quote = quote.replace(c, ' ')
        return quote.strip().lower()

    toys_count = {}
    toys_list = []

    for q in quotes:
        for word in set(toLower(q).split(' ')):
            if word in toys_dict:
                toys_dict[word] += 1

    for k, v in toys_dict.items():
        toys_list.append((-1 * v, k))

    heapq.heapify(toys_list)
    return [heapq.heappop(toys_list)[1] for x in range(topToys)]


print(popularNToys(6, 2, ["elmo", "elsa", "legos", "drone", "tablet", "warcraft"], 6,
                   ["Elmo is the hottest of the season! Elmo will be on every kid's wishlist!",
                    "The new Elmo dolls are super high quality",
                    "Expect the Elsa dolls to be very popular this year",
                    "Elsa and Elmo are the toys I'll be buying for my kids",
                    "For parents of older kids, look into buying them a drone",
                    "Warcraft is slowly rising in popularity ahead of the holiday season"]))


[""]
The file stack_using_LL.py contains:
class Node:
    def __init__(self,val):
        self.val=val
        self.next = None
class stack:
    def __init__(self):
        self.root = None

    def push(self, data):
        newnode = Node(data)
        newnode.next = self.root
        self.root = newnode

    def pop(self):
        if (self.isempty()):
            return "-1"
        temp = self.root
        self.root = self.root.next
        popped = temp.val
        return popped

    def isempty(self):
        return True if self.root is None else False


if __name__ == '__main__':
    a = [1,2,3,6,3,8,4]
    node = []
    length = len(a)
    s = stack()
    for i in range(len(a)):
        s.push(a[i])
    for i in range(len(a)):
        print (s.pop())


    '''
    for i in range(len(a)):
        node.append(Node(a[i]))
        node[i-1].next = node[i]
    print(node)
    current = node[0]
    while current!=None:
        print(current.val)
        current = current.next
    '''
The file stringAnagram.py contains:
def stringAnagram(str1,str2):
    d= {}
    for i in range(len(str1)):
        if str1[i] in d:
            d[str1[i]] +=1
        else:
            d[str1[i]] = 1

    print(d)
    for  i in range(len(str2)):
        if str2[i] in d and d[str2[i]] >0:
            d[str2[i]]-=1
        else:
            print(str2[i])
            print("Not Anagram")
            break

    return  sum(d.values())==0

if __name__ == '__main__':
    print(stringAnagram("listen","silent"))
    print(stringAnagram("triangle", "integral"))

The file stringreverse.py contains:
def reverseStr(s):
    num = str(s)
    i =0
    res =""
    if len(num) % 2 == 0:
        while i < len(num):
            res += num[i+1]+num[i]
            i=i+2
    else:
        while i < len(num)-1:
            res += num[i+1]+num[i]
            i=i+2
        res+=num[len(num)-1]
    return int(res)


print(reverseStr(1122558898))
print(reverseStr(1123))
print(reverseStr(12345))
print(reverseStr(72328))
The file String_Formation_Target_String.py contains:
from collections import OrderedDict
import itertools
def numWays(words, target):
    count = 0
    x = []
    target = list(target)
    d = OrderedDict()
    dictOrder = OrderedDict()
    for i in range(len(words)):
        temp = list(words[i])
        for j in range(len(temp)):
            if temp[j] in target:
                if temp[j] not in d:
                    d[temp[j]] = []
                d[temp[j]].append(j)
    for i in target:
        if i not in d:
            return 0
        else:
            dictOrder[i] = d[i]
    del(d)
    for i in dictOrder:
        x.append(dictOrder[i])
    res = list(itertools.product(*x))
    for i in res:
        if len(set(i))== len(target) and list(i) == sorted(i):
            count += 1
    return count


if __name__ == '__main__':
    count = 0
    # x = ["adc","aec","efg"]
    # x = ["valya","lyglb","vldoh"]
    x = ["xzu", "dfw", "eor", "mat", "jyc"]
    # target = "ac"
    # target = "val"
    target = "cf"


    print(numWays(x,target))



The file String_reversal.py contains:
a = "Sumedh"
print(len(a))
z =a[0]
for i in range(0,int(len(a)/2)):
    temp = a[len(a)-1]
    print(temp)
    #a[len(a)-1]= a[i]
    #a[i]=temp

print(a[::-1])
a =9
b =5
print(a and b)

The file strobogramaticNumber.py contains:
def findNotStobogrammaticNumbers(start,end):
    d = {"0":"0","1":"1","6":"9","8":"8","9":"6"}
    op  =[]
    for i in range(start,end+1):
        i = str(i)
        temp = ""
        for j in i:
            if j in d:
                temp+=d[j]
            else:
                temp=""
                break
        temp = temp[::-1]
        #print(i,temp)
        if i !=temp and len(temp)==len(i):
            op.append(i)

    print(op)





print(findNotStobogrammaticNumbers(1,100))
The file strokes_to_paint.py contains:
n=int(input())
s=input()
if len(set(s))==1:
    print(1)
else:
    c=0
    for i in range(len(s)-1):
        if s[i]!=s[i+1]:
            c+=1
        else:
            continue

    print(c+1)

The file subStringWithDistinct.py contains:
import collections
def subStringsWithKDistinctCharacters(s, k):
    s = list(s)
    count = 0
    right, left = 0, 0
    hmap = collections.defaultdict(int)
    for x in s:
        hmap[x] += 1

        if len(hmap) < k:
            continue

        if len(hmap) > k:
            del hmap[s[right]]
            right += 1
            left = right

        while hmap[s[right]] > 1:
            hmap[s[right]] -= 1
            right += 1
        count += right - left + 1
    return count

if __name__ == '__main__':
    print(subStringsWithKDistinctCharacters("abaca",2)
The file sum_of_odd_level.py contains:
class Node:
    def __init__(self,root):
        self.val = root
        self.left = None
        self.right = None




class bfs:
    res = []
    def oddsum(self,root):
        queue = []
        level = 0
        if root:
            queue.append((root,level))

        while len(queue)>0:
            data = queue.pop(0)
            print(data[1])
            if data[1]%2!=0:
                self.res.append(data[0].val)
            if data[0].left:
                queue.append((data[0].left,level+1))
            if data[0].right:
                queue.append((data[0].right,level+1))

            level+=1

        print(self.res)



if __name__ == '__main__':
    root = Node(1)
    root.left = Node(2)
    root.right = Node(3)
    root.left.left = Node(4)
    root.left.right = Node(5)
    traverse = bfs()
    print(traverse.oddsum(root))

The file Sum_of_prime_between_range.py contains:
from math import sqrt

def chkprime(numberToCheck):
    if numberToCheck == 1:
        return False
    for i in range(2, int(sqrt(numberToCheck)) + 1):
        if numberToCheck % i == 0:
            return False

    return True

def primeSum(l, r):
    sum = 0

    for i in range(r, (l - 1), -1):
        isPrime = chkprime(i)
        if (isPrime):
            sum += i
    return sum

if __name__ == "__main__":
    l = input()
    r = input()

    print (l)

    #l, r = 4, 13

    # Call the function with l and r
    print(primeSum(int(l), int(r)))

#primeSum(X,Y)
### Function la call kar

The file Take_data.py contains:
import os
import numpy as np
import pandas as pd
import requests
import bs4
import fastnumbers
import csv
import matplotlib.pyplot as plt
import seaborn as sns
import json
print(os.environ['PATH'])
data = pd.read_html('https://en.wikipedia.org/wiki/List_of_S%26P_500_companies')
table = data[0]
sliced_table = table[1:]
header = table.iloc[0]
corrected_table = sliced_table.rename(columns=header)
company_List = ['3M Company','Adobe Systems Inc','Allstate Corp','Amazon.com Inc.','Apple Inc.','American Express Co','JPMorgan Chase & Co.','Visa Inc.','Xilinx','Facebook, Inc.']
corrected_table = corrected_table[corrected_table.Security.isin(company_List)]
#print(len(company_List))
#corrected_table
tickers = corrected_table['Symbol'].tolist()
print (tickers)
s,s2 = 'https://www.worldtradingdata.com/api/v1/stock?symbol=','https://www.worldtradingdata.com/api/v1/stock?symbol='
for i in range(0,len(tickers)-6):
    s = s + tickers[i] + ','
s = s + tickers[len(tickers)-6] + '&api_token=p4nU2OENDDJfkKP6TePnfKAgI4W5sz2GQmsVBehWiAjwLN6srpgbqp8lfiaV'
print(s)
for i in range(len(tickers)-5,len(tickers)-1):
    s2 = s2 + tickers[i] + ','
s2 = s2 + tickers[-1] + '&api_token=p4nU2OENDDJfkKP6TePnfKAgI4W5sz2GQmsVBehWiAjwLN6srpgbqp8lfiaV'
print(s2)
################# Call get method to take response from URL ###################
#response = requests.get("https://www.worldtradingdata.com/api/v1/stock?symbol=AAPL,MSFT,HSBA.L&api_token=demo", timeout=240)
response = requests.get(s, timeout=240)
response2 = requests.get(s2, timeout=240)
#response.status_code
print(response.content)
print(response2.content)
############### Convert the content to json ################
content = response.json()
content2 = response2.json()
#content.keys()
#content = content['data']
#type(content)
#content = json.dumps(content)
keys = content['data'][0].keys()
keys2 = content2['data'][0].keys()
#keys
print(content['data'])
print(content2['data'])
### Witing JSON data into CSV ##################
#csvwriter = csv.writer(first_csv)
with open('D:\sum\Its Study Time\Academic\M.S\Spring_2019\Machine Learning\Project\Sumedh_Work\\first_csv.csv', 'a', newline='') as first_csv:
    csvwriter = csv.DictWriter(first_csv, keys,extrasaction='ignore')
    #csvwriter.writeheader()
    csvwriter.writerows(content['data'])
    csvwriter.writerows(content2['data'])

############# Play using pandas ################
data = pd.read_csv('D:\sum\Its Study Time\Academic\M.S\Spring_2019\Machine Learning\Project\Sumedh_Work\\first_csv.csv')
#data.head
#data.drop()
print(data.shape)
The file Test.py contains:
a = ['0000016c052dcf4101000d746573745f6b65795f313233340012746573745f76616c75655f31323339393038','0000016c052dcf4101000d746573745f6b65795f313233340012746573745f76616c75655f31323339393038']


raw_data = bytes.fromhex(''.join(a))
print(raw_data)
print(len(raw_data))
The file threeCharDistincts.py contains:
def threeCharDistincts(s):
    count = 0
    for i in range(len(s) - 2):
        #print(s[i])
        char_set = set()
        flag = True
        for j in range(i, i + 3):
            if s[j] in char_set:
                flag = False
                break
            else:
                char_set.add(s[j])

        if flag:
            count += 1
    return count

print(threeCharDistincts("aaaaaaabc"))
print(threeCharDistincts("abcdaaae"))
The file Tom_Sawyer.py contains:
def countWays(arr, n):
    pos = [0 for i in range(n)]
    p = 0
    for i in range(n):
        if (arr[i] == 1):
            pos[p] = i + 1
            p += 1
    if (p == 0):
        return 0
    ways = 1
    for i in range(p - 1):
        ways *= pos[i + 1] - pos[i]
    return ways

print(countWays([0,1],2))
The file topological_sort.py contains:
def topological_sort(vertex,op,visited,d):
    print(vertex,'-----------',visited)
    if not visited[vertex]:
        visited[vertex] = True
        for i in d[vertex]:
            topological_sort(i,op,visited,d)
        op.append(vertex)
        print(vertex,visited)




if __name__ == '__main__':
    d = {
        0: [],
        1: [],
        2: [3],
        3: [1],
        4: [0, 1,5],
        5: [2, 0]
    }
    output_stack = []
    recStack = [False]*len(d)
    visited = [False]*len(d)

    for k,v in d.items():
        topological_sort(k,output_stack, visited, d)


    print(output_stack)











The file traversal.py contains:
class Node:
    def __init__(self,x):
        self.val = x
        self.left = None
        self.right = None

class traversals:
    def inorder_traversal(self,root):
        def helperinorder(root,res):
            if root:
                helperinorder(root.left,res)
                res.append(root.val)
                helperinorder(root.right,res)

        res=[]
        helperinorder(root,res)
        return res

    def preorder_traversal(self,root):
        def helperpreorder(root,res):
            if root:
                res.append(root.val)
                helperpreorder(root.left,res)
                helperpreorder(root.right,res)

        res=[]
        helperpreorder(root,res)
        return res

    def postorder_traversal(self,root):
        def helperpostorder(root,res):
            if root:
                helperpostorder(root.left,res)
                helperpostorder(root.right,res)
                res.append(root.val)

        res=[]
        helperpostorder(root,res)
        return res




if __name__ == '__main__':
    root = Node(1)
    root.left =Node(2)
    root.left.left = Node(4)
    root.left.right = Node(5)
    root.right = Node(3)

    #------------- Traversal -----------#
    treaverse = traversals()
    print("Pre order traversal: -",treaverse.preorder_traversal(root))
    print("In order traversal: -",treaverse.inorder_traversal(root))
    print("Post order traversal: -",treaverse.postorder_traversal(root))

The file tst_1.py contains:
import re

def patterMatch(str1):
    result = re.findall('(?<=1)[0]+(?=1)', str1)

    print(result)



    '''
    result = re.findall(r'(10+1)',str1)
    start = 0
    s = set()
    end = len(str1)
    print(result)
    while True:
        result.append(re.findall(r'10+1',str1[start:end]))
        start+=1
        if start==end:
            break
    print(result)

    for i in range(len(result)):
        if result[i] not in s:
            s.add(result[i])

    print(s)
    '''





if __name__ == '__main__':
    patterMatch("1010001001000abc0011101")

    101
    10001
    1001
    101
The file turbulance.py contains:
def findTurbulance(arr,idx,res):
    for j in range(idx,len(arr)-2):
        if arr[j]>arr[j+1] and arr[j+1]<arr[j+2]:
            res.append(j)
            res.append(j+1)
            res.append(j + 2)
            #res.append(arr[j])
            #res.append(arr[j+1])
            #res.append(arr[j+2])
            findTurbulance(arr,j+2,res)
        else:
            break


if __name__ == '__main__':
    #arr = [9,4,2,10,7,8,8,1,9]
    arr = [9, 4, 2, 10, 7, 8, 8, 1, 9]
    maxRange = [0,0]
    for i in range(len(arr)):
        res = []
        findTurbulance(arr,i,res)
        if res and maxRange[1]-maxRange[0]<(res[-1]-res[0]):
            maxRange = [res[0],res[-1]]
        print(res)
        print(maxRange)

    #s = "leet"
    #print(list(s))
    #s = list(s)
    #print(''.join(s))

The file twoSum.py contains:
a = [2,7,11,15]
target = 9
d ={}
for i in range(len(a)):
    if a[i] not in d:
        d[target - a[i]] = i
    else:
        print([d[a[i]],i])



The file two_sum.py contains:
def twoSum(nums,target):
    nums_position = {}
    count = 0
    count_1 = 0
    for i in nums:
        if target - i in nums_position:
            count_1 +=1
        nums_position[i] = count
        count = count + 1
    return count_1


print(twoSum([10,3,5,7,2,8,9,6,1,4],7))
The file uniqueStrings.py contains:
from collections import Counter

str1 = input("Please enter a sentence: ")
words = str1.split(',')
print(words)
s = set()
for i in range(len(words)):
    s.add(words[i].lower())
print(s)
print(len(s))
#c = Counter(words)
#unique = [w for w in words if c[w] == 1]

#print("Unique words: ", unique)


The file universityCareerFair.py contains:
def universityCareerFair(arrival, duration):
    aux = sorted(
        list(zip(arrival, duration)),
        key=lambda p: (sum(p), p[1])
    )
    ans, end = 0, -float('inf')
    for arr, dur in aux:
        if arr >= end:
            ans, end = ans + 1, arr + dur
    return ans


print(universityCareerFair([1,3,5],[2,2,2]))
print(universityCareerFair([1],[5]))
The file Valid_Paranthesis.py contains:
s = input()

'''while "()" in s or "{}" in s or '[]' in s:
    print("in while")
    s = s.replace("()", "").replace('{}', "").replace('[]', "")
if s == "":
    print("True")
else:
    print("False")
'''

for i in range(len(s)):
    #print("in while")
    s = s.replace("()", "").replace('{}', "").replace('[]', "")
if s == "":
    print("True")
else:
    print("False")

#print(isValid("{([()])}"))




The file Ways_to_sum.py contains:
'''
def binomialCoeff(n, k):
    C = [[0 for i in range(k + 1)] for i in range(n + 1)]

    # Caculate value of Binomial Coefficient in bottom up manner
    for i in range(1, n + 1, 1):
        for j in range(1, min(i, k) + 1, 1):
            # Base Cases
            if (j == 0 or j == i):
                C[i][j] = 1

            # Calculate value using previosly stored values
            else:
                C[i][j] = C[i - 1][j - 1] + C[i - 1][j]
    #print(C[n][k])
    return C[n][k]

def CountWays(n,k):
    table = [0] * (n + 1)
    table[0] = 1
    for i in range(0, k):

        for j in range(i, n+1):
            table[j] += table[j - i]

    return table[n]

# Driver Code
if __name__ == '__main__':
    n = 8
    k = 2
    print("Total number of different ways are", binomialCoeff(n - 1, k - 1))
    #print("Total number of different ways are", CountWays(8,2))


'''
def findCombinationsUtil(arr, index, num,reducedNum,main_temp):
    if (reducedNum < 0):
        return 0;
    if (reducedNum == 0):
        temp = []
        for i in range(index):
            temp.append(arr[i])
        main_temp.append(temp)
        return 0;
    prev = 1 if (index == 0) else arr[index - 1];
    for k in range(prev, num + 1):
        arr[index] = k;
        findCombinationsUtil(arr, index + 1, num,reducedNum - k,main_temp);
def findCombinations(n,a):
    arr = [0] * n
    main_temp = []
    findCombinationsUtil(arr, 0, n, n,main_temp)
    count = 0
    for array in main_temp:
        print("In for")
        if max(array) <= a:
            count += 1
    print(count)

n = 100
a=10
findCombinations(n,a)
The file weeklyStockPrice.py contains:
def getWeeklyPrice(nums):
    res = []
    l,sum = 0,0

    for r in range(len(nums)):
        if r-l ==7:
            res.append(round((sum/7.0*100)/100.0,2))
            l+=1
            sum -=nums[l]

        sum+=nums[r]

    res.append(round((sum/7.0*100)/100.0,2))
    print(res)
    return "".join([str(integer) for integer in res])



if __name__ == '__main__':
    print(getWeeklyPrice([7,8,8,11,9,7,5,6]))

The file wordLadder.py contains:
import collections
'''
        adj = collections.defaultdict(list)
        for word in wordList:
            for i in range(len(word)):
                adj[word[:i] + '_' + word[i+1:]].append(word)
        #print(adj)
        visited = set()
        q = collections.deque([(beginWord, 1)])
        while q:
            word, k = q.popleft()
            if word == endWord:
                return k
            if word not in visited:
                visited.add(word)
                for i in range(len(word)):
                    neighbors = word[:i] + '_' + word[i+1:]
                    for neighbor in adj[neighbors]:
                        q.append((neighbor, k+1))
            print(q)
        return 0 

def ladderLength(beginWord, endWord, wordList):
    d = collections.defaultdict(list)

    for word in wordList:
        for letter in range(len(word)):
            d[word[:letter]+'*'+word[letter+1:]].append(word)
    visisted = set()

    queue = collections.deque([(beginWord,1)])
    dummyqueue = []
    #print(queue.popleft())
    while queue:
        print("------------")
        word,level = queue.popleft()
        if word == endWord:
            return  level
        if word not in visisted:
            visisted.add(word)
            for i in range(len(word)):
                tempArr = word[:i]+'*'+word[i+1:]
                #print(tempArr)
                for element in d[tempArr]:
                    #print(queue,element,element in dummyqueue)
                    if element not  in visisted and element not in dummyqueue:
                        dummyqueue.append(element)
                        queue.append((element,level+1))

        print(queue)
    print(d)


print(ladderLength("hit","cog",["hot","dot","dog","lot","log","cog"]))

'''
import collections

def ladderLength(beginWord,endWord,wordList):
    d = collections.defaultdict(list)

    for i in range(len(wordList)):
        for j in range(len(wordList[i])):
            temp = wordList[i]
            d[temp[:j]+'*'+temp[j+1:]].append(temp)
    #print(d)

    visited =set()

    q =collections.deque()
    q.append((beginWord,1))

    while q:
        data, level = q.popleft()
        if data==endWord:
            return level
        #print(data, level)

        if data not in visited:
            visited.add(data)
            for i in range(len(data)):
                temp = data[:i]+'*'+data[i+1:]
                #print(temp,q)
                for element in d[temp]:
                    q.append((element,level+1))

    return 0

if __name__ == '__main__':
    beginWord = "hit"
    endWord = "cog"
    wordList = ["hot", "dot", "dog", "lot", "log", "cog"]
    #print(beginWord)
    print(ladderLength(beginWord,endWord,wordList))






















The file Work_Schedule.py contains:
def sumOfDigits(s):
    sum = 0
    for i in range(len(s)):
        sum += int(s[i])
    return sum;

def findSchedules(workHours, dayHours, pattern):
    x = ()
    if '?' in pattern:
        index = pattern.index('?')
        first = str(pattern[:index])
        last = str(pattern[index+1:len(pattern)])
        for i in range(dayHours+1):
            result = findSchedules(workHours, dayHours, first + str(i) + last)
            x = x + result;
            # print(result)
            # print(x)
    else:
        #Pattern has no Question mark,
        #So, just sum digits and check if it matches WorkHours
        #print(sumOfDigits(pattern),workHours)
        if(sumOfDigits(pattern) == workHours):
            x = x + (pattern,)
    return x
res = findSchedules(56,8,'???8???')
print(res)
